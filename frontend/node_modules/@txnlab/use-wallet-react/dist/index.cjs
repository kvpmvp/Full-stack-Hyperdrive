"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.tsx
var index_exports = {};
__export(index_exports, {
  WalletProvider: () => WalletProvider,
  useNetwork: () => useNetwork,
  useWallet: () => useWallet
});
module.exports = __toCommonJS(index_exports);
var import_react_store = require("@tanstack/react-store");
var import_algosdk = __toESM(require("algosdk"), 1);
var React = __toESM(require("react"), 1);
__reExport(index_exports, require("@txnlab/use-wallet"), module.exports);
var import_jsx_runtime = require("react/jsx-runtime");
var WalletContext = React.createContext(void 0);
var WalletProvider = ({ manager, children }) => {
  const [algodClient, setAlgodClient] = React.useState(manager.algodClient);
  React.useEffect(() => {
    manager.algodClient = algodClient;
  }, [algodClient, manager]);
  const resumedRef = React.useRef(false);
  React.useEffect(() => {
    if (!resumedRef.current) {
      manager.resumeSessions();
      resumedRef.current = true;
    }
  }, [manager]);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(WalletContext.Provider, { value: { manager, algodClient, setAlgodClient }, children });
};
var useNetwork = () => {
  const context = React.useContext(WalletContext);
  if (!context) {
    throw new Error("useNetwork must be used within the WalletProvider");
  }
  const { manager, setAlgodClient } = context;
  const activeNetwork = (0, import_react_store.useStore)(manager.store, (state) => state.activeNetwork);
  const setActiveNetwork = async (networkId) => {
    if (networkId === activeNetwork) {
      return;
    }
    if (!manager.networkConfig[networkId]) {
      throw new Error(`Network "${networkId}" not found in network configuration`);
    }
    console.info(`[React] Creating new Algodv2 client...`);
    const { algod } = manager.networkConfig[networkId];
    const { token = "", baseServer, port = "", headers = {} } = algod;
    const newClient = new import_algosdk.default.Algodv2(token, baseServer, port, headers);
    setAlgodClient(newClient);
    manager.store.setState((state) => ({
      ...state,
      activeNetwork: networkId
    }));
    console.info(`[React] \u2705 Active network set to ${networkId}.`);
  };
  const updateAlgodConfig = (networkId, config) => {
    manager.updateAlgodConfig(networkId, config);
    if (networkId === activeNetwork) {
      console.info(`[React] Creating new Algodv2 client...`);
      const { algod } = manager.networkConfig[networkId];
      const { token = "", baseServer, port = "", headers = {} } = algod;
      const newClient = new import_algosdk.default.Algodv2(token, baseServer, port, headers);
      setAlgodClient(newClient);
    }
  };
  const resetNetworkConfig = (networkId) => {
    manager.resetNetworkConfig(networkId);
    if (networkId === activeNetwork) {
      console.info(`[React] Creating new Algodv2 client...`);
      const { algod } = manager.networkConfig[networkId];
      const { token = "", baseServer, port = "", headers = {} } = algod;
      const newClient = new import_algosdk.default.Algodv2(token, baseServer, port, headers);
      setAlgodClient(newClient);
    }
  };
  return {
    activeNetwork,
    networkConfig: manager.networkConfig,
    activeNetworkConfig: manager.activeNetworkConfig,
    setActiveNetwork,
    updateAlgodConfig,
    resetNetworkConfig
  };
};
var useWallet = () => {
  const context = React.useContext(WalletContext);
  if (!context) {
    throw new Error("useWallet must be used within the WalletProvider");
  }
  const { manager, algodClient, setAlgodClient } = context;
  const managerStatus = (0, import_react_store.useStore)(manager.store, (state) => state.managerStatus);
  const isReady = managerStatus === "ready";
  const walletStateMap = (0, import_react_store.useStore)(manager.store, (state) => state.wallets);
  const activeWalletId = (0, import_react_store.useStore)(manager.store, (state) => state.activeWallet);
  const transformToWallet = React.useCallback(
    (wallet) => {
      const walletState = walletStateMap[wallet.id];
      return {
        id: wallet.id,
        metadata: wallet.metadata,
        accounts: walletState?.accounts ?? [],
        activeAccount: walletState?.activeAccount ?? null,
        isConnected: !!walletState,
        isActive: wallet.id === activeWalletId,
        canSignData: wallet.canSignData ?? false,
        connect: (args) => wallet.connect(args),
        disconnect: () => wallet.disconnect(),
        setActive: () => wallet.setActive(),
        setActiveAccount: (addr) => wallet.setActiveAccount(addr)
      };
    },
    [walletStateMap, activeWalletId]
  );
  const wallets = React.useMemo(() => {
    return [...manager.wallets.values()].map(transformToWallet);
  }, [manager, transformToWallet]);
  const activeBaseWallet = activeWalletId ? manager.getWallet(activeWalletId) || null : null;
  const activeWallet = React.useMemo(() => {
    return activeBaseWallet ? transformToWallet(activeBaseWallet) : null;
  }, [activeBaseWallet, transformToWallet]);
  const activeWalletAccounts = activeWallet?.accounts ?? null;
  const activeWalletAddresses = activeWalletAccounts?.map((account) => account.address) ?? null;
  const activeAccount = activeWallet?.activeAccount ?? null;
  const activeAddress = activeAccount?.address ?? null;
  const signTransactions = (txnGroup, indexesToSign) => {
    if (!activeBaseWallet) {
      throw new Error("No active wallet");
    }
    return activeBaseWallet.signTransactions(txnGroup, indexesToSign);
  };
  const transactionSigner = (txnGroup, indexesToSign) => {
    if (!activeBaseWallet) {
      throw new Error("No active wallet");
    }
    return activeBaseWallet.transactionSigner(txnGroup, indexesToSign);
  };
  const signData = (data, metadata) => {
    if (!activeBaseWallet) {
      throw new Error("No active wallet");
    }
    return activeBaseWallet.signData(data, metadata);
  };
  return {
    wallets,
    isReady,
    algodClient,
    setAlgodClient,
    activeWallet,
    activeWalletAccounts,
    activeWalletAddresses,
    activeAccount,
    activeAddress,
    signData,
    signTransactions,
    transactionSigner
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  WalletProvider,
  useNetwork,
  useWallet,
  ...require("@txnlab/use-wallet")
});
//# sourceMappingURL=index.cjs.map