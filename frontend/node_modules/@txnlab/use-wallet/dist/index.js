var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a, b3) => (typeof require !== "undefined" ? require : a)[b3]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// ../../node_modules/.pnpm/@magic-sdk+types@24.21.0/node_modules/@magic-sdk/types/dist/es/index.mjs
var m, v, u, _, f, g, Z, E, y, x, A, R, I, N, h, T, O, S, b, C, F, U, k, L, w, D, V, G, H, q, W, J, Y, B, P, j, Q, X, z;
var init_es = __esm({
  "../../node_modules/.pnpm/@magic-sdk+types@24.21.0/node_modules/@magic-sdk/types/dist/es/index.mjs"() {
    "use strict";
    m = ((o) => (o.MissingApiKey = "MISSING_API_KEY", o.ModalNotReady = "MODAL_NOT_READY", o.ConnectionLost = "CONNECTION_WAS_LOST", o.MalformedResponse = "MALFORMED_RESPONSE", o.InvalidArgument = "INVALID_ARGUMENT", o.ExtensionNotInitialized = "EXTENSION_NOT_INITIALIZED", o.IncompatibleExtensions = "INCOMPATIBLE_EXTENSIONS", o))(m || {});
    v = ((s) => (s.SyncWeb3Method = "SYNC_WEB3_METHOD", s.DuplicateIframe = "DUPLICATE_IFRAME", s.ReactNativeEndpointConfiguration = "REACT_NATIVE_ENDPOINT_CONFIGURATION", s.DeprecationNotice = "DEPRECATION_NOTICE", s.ProductAnnouncement = "ANNOUNCEMENT", s))(v || {});
    u = ((i) => (i[i.ParseError = -32700] = "ParseError", i[i.InvalidRequest = -32600] = "InvalidRequest", i[i.MethodNotFound = -32601] = "MethodNotFound", i[i.InvalidParams = -32602] = "InvalidParams", i[i.InternalError = -32603] = "InternalError", i[i.MagicLinkFailedVerification = -1e4] = "MagicLinkFailedVerification", i[i.MagicLinkExpired = -10001] = "MagicLinkExpired", i[i.MagicLinkRateLimited = -10002] = "MagicLinkRateLimited", i[i.MagicLinkInvalidRedirectURL = -10006] = "MagicLinkInvalidRedirectURL", i[i.UserAlreadyLoggedIn = -10003] = "UserAlreadyLoggedIn", i[i.UpdateEmailFailed = -10004] = "UpdateEmailFailed", i[i.UserRequestEditEmail = -10005] = "UserRequestEditEmail", i[i.InactiveRecipient = -10010] = "InactiveRecipient", i[i.AccessDeniedToUser = -10011] = "AccessDeniedToUser", i[i.RedirectLoginComplete = -10015] = "RedirectLoginComplete", i[i.DpopInvalidated = -10019] = "DpopInvalidated", i))(u || {});
    _ = ((t) => (t.PROVIDER = "magic_3pw_provider", t.ADDRESS = "magic_3pw_address", t.CHAIN_ID = "magic_3pw_chainId", t))(_ || {});
    f = ((t) => (t.WalletConnected = "wallet_connected", t.WalletRejected = "wallet_rejected", t.Web3ModalSelected = "web3modal_selected", t))(f || {});
    g = ((e) => (e.LoginWithSms = "magic_auth_login_with_sms", e.LoginWithEmailOTP = "magic_auth_login_with_email_otp", e.LoginWithMagicLink = "magic_auth_login_with_magic_link", e.LoginWithCredential = "magic_auth_login_with_credential", e.SetAuthorizationToken = "magic_auth_set_authorization_token", e.GetIdToken = "magic_auth_get_id_token", e.GenerateIdToken = "magic_auth_generate_id_token", e.GetMetadata = "magic_auth_get_metadata", e.IsLoggedIn = "magic_is_logged_in", e.Logout = "magic_auth_logout", e.UpdateEmail = "magic_auth_update_email", e.UserSettings = "magic_auth_settings", e.UserSettingsTestMode = "magic_auth_settings_testing_mode", e.LoginWithSmsTestMode = "magic_auth_login_with_sms_testing_mode", e.LoginWithEmailOTPTestMode = "magic_auth_login_with_email_otp_testing_mode", e.LoginWithMagicLinkTestMode = "magic_login_with_magic_link_testing_mode", e.LoginWithCredentialTestMode = "magic_auth_login_with_credential_testing_mode", e.GetIdTokenTestMode = "magic_auth_get_id_token_testing_mode", e.GenerateIdTokenTestMode = "magic_auth_generate_id_token_testing_mode", e.GetMetadataTestMode = "magic_auth_get_metadata_testing_mode", e.IsLoggedInTestMode = "magic_auth_is_logged_in_testing_mode", e.LogoutTestMode = "magic_auth_logout_testing_mode", e.UpdateEmailTestMode = "magic_auth_update_email_testing_mode", e.IntermediaryEvent = "magic_intermediary_event", e.RequestAccounts = "eth_requestAccounts", e.GetInfo = "magic_get_info", e.ShowUI = "magic_wallet", e.NFTPurchase = "magic_nft_purchase", e.NFTCheckout = "magic_nft_checkout", e.NFTTransfer = "magic_nft_transfer", e.RequestUserInfoWithUI = "mc_request_user_info", e.Disconnect = "mc_disconnect", e.RecoverAccount = "magic_auth_recover_account", e.RecoverAccountTestMode = "magic_auth_recover_account_testing_mode", e.MagicBoxHeartBeat = "magic_box_heart_beat", e.AutoConnect = "mc_auto_connect", e.Login = "mc_login", e.EncryptV1 = "magic_auth_encrypt_v1", e.DecryptV1 = "magic_auth_decrypt_v1", e.ShowNFTs = "magic_show_nfts", e.ShowOnRamp = "magic_show_fiat_onramp", e.ShowSendTokensUI = "magic_show_send_tokens_ui", e.ShowAddress = "magic_show_address", e.ShowBalances = "magic_show_balances", e.SendGaslessTransaction = "eth_sendGaslessTransaction", e.RevealPK = "magic_reveal_key", e.EnableMFA = "magic_auth_enable_mfa_flow", e.DisableMFA = "magic_auth_disable_mfa_flow", e))(g || {});
    Z = ["magic_intermediary_event", "magic_nft_checkout", "mc_login"];
    E = ((c) => (c.MAGIC_HANDLE_RESPONSE = "MAGIC_HANDLE_RESPONSE", c.MAGIC_OVERLAY_READY = "MAGIC_OVERLAY_READY", c.MAGIC_SHOW_OVERLAY = "MAGIC_SHOW_OVERLAY", c.MAGIC_HIDE_OVERLAY = "MAGIC_HIDE_OVERLAY", c.MAGIC_HANDLE_EVENT = "MAGIC_HANDLE_EVENT", c.MAGIC_MG_BOX_SEND_RECEIPT = "MAGIC_MG_BOX_SEND_RECEIPT", c.MAGIC_SEND_PRODUCT_ANNOUNCEMENT = "MAGIC_SEND_PRODUCT_ANNOUNCEMENT", c.MAGIC_PONG = "MAGIC_PONG", c.MAGIC_POPUP_RESPONSE = "MAGIC_POPUP_RESPONSE", c.MAGIC_POPUP_OAUTH_VERIFY_RESPONSE = "MAGIC_POPUP_OAUTH_VERIFY_RESPONSE", c))(E || {});
    y = ((l) => (l.MAGIC_HANDLE_REQUEST = "MAGIC_HANDLE_REQUEST", l.MAGIC_PING = "MAGIC_PING", l))(y || {});
    x = ((t) => (t.UpdateEmail = "update-email", t.MFA = "mfa", t.Recovery = "recovery", t))(x || {});
    A = ((r10) => (r10.Retry = "retry", r10))(A || {});
    R = ((l) => (l.EmailSent = "email-sent", l.EmailNotDeliverable = "email-not-deliverable", l))(R || {});
    I = ((s) => (s.VerifyEmailOtp = "verify-email-otp", s.VerifyMFACode = "verify-mfa-code", s.LostDevice = "lost-device", s.VerifyRecoveryCode = "verify-recovery-code", s.Cancel = "cancel", s))(I || {});
    N = ((t) => (t.VerifySmsOtp = "verify-sms-otp", t.Cancel = "cancel", t.Retry = "retry", t))(N || {});
    h = ((t) => (t.SmsOTPSent = "sms-otp-sent", t.InvalidSmsOtp = "invalid-sms-otp", t.ExpiredSmsOtp = "expired-sms-otp", t))(h || {});
    T = ((d) => (d.EmailOTPSent = "email-otp-sent", d.InvalidEmailOtp = "invalid-email-otp", d.InvalidMfaOtp = "invalid-mfa-otp", d.ExpiredEmailOtp = "expired-email-otp", d.MfaSentHandle = "mfa-sent-handle", d.RecoveryCodeSentHandle = "recovery-code-sent-handle", d.InvalidRecoveryCode = "invalid-recovery-code", d.RecoveryCodeSuccess = "recovery-code-success", d.LoginThrottled = "login-throttled", d))(T || {});
    O = ((r10) => (r10.Retry = "device-retry", r10))(O || {});
    S = ((n) => (n.DeviceApproved = "device-approved", n.DeviceNeedsApproval = "device-needs-approval", n.DeviceVerificationLinkExpired = "device-verification-link-expired", n.DeviceVerificationEmailSent = "device-verification-email-sent", n))(S || {});
    b = ((n) => (n.Retry = "Recency/auth-factor-retry", n.Cancel = "Recency/auth-factor-verification-cancel", n.VerifyEmailOtp = "Recency/auth-factor-verify-email-otp", n.VerifyMFACode = "Recency/verify-mfa-code", n))(b || {});
    C = ((a) => (a.PrimaryAuthFactorNeedsVerification = "Recency/auth-factor-needs-verification", a.PrimaryAuthFactorVerified = "Recency/auth-factor-verified", a.InvalidEmailOtp = "Recency/auth-factor-invalid-email-otp", a.EmailExpired = "Recency/auth-factor-verification-email-expired", a.EmailSent = "Recency/auth-factor-verification-email-sent", a.EmailNotDeliverable = "Recency/auth-factor-verification-email-not-deliverable", a))(C || {});
    F = ((t) => (t.RetryWithNewEmail = "UpdateEmail/retry-with-new-email", t.Cancel = "UpdateEmail/new-email-verification-cancel", t.VerifyEmailOtp = "UpdateEmail/new-email-verify-otp", t))(F || {});
    U = ((p2) => (p2.NewAuthFactorNeedsVerification = "UpdateEmail/new-email-needs-verification", p2.EmailUpdated = "UpdateEmail/email-updated", p2.InvalidEmailOtp = "UpdateEmail/new-email-invalid-email-otp", p2.EmailExpired = "UpdateEmail/new-email-verification-email-expired", p2.EmailSent = "UpdateEmail/new-email-verification-email-sent", p2.EmailNotDeliverable = "UpdateEmail/new-email-verification-email-not-deliverable", p2.InvalidEmail = "UpdateEmail/new-email-invalid", p2.EmailAlreadyExists = "UpdateEmail/new-email-already-exists", p2))(U || {});
    k = ((r10) => (r10.IDTokenCreated = "Auth/id-token-created", r10))(k || {});
    L = ((r10) => (r10.Cancel = "Farcaster/cancel", r10))(L || {});
    w = ((t) => (t.MFASecretGenerated = "mfa-secret-generated", t.InvalidMFAOtp = "invalid-mfa-otp", t.MFARecoveryCodes = "mfa-recovery-codes", t))(w || {});
    D = ((l) => (l.VerifyMFACode = "verify-mfa-code", l.Cancel = "cancel-mfa-setup", l))(D || {});
    V = ((t) => (t.MFACodeRequested = "mfa-code-requested", t.InvalidMFAOtp = "invalid-mfa-otp", t.InvalidRecoveryCode = "invalid-recovery-code", t))(V || {});
    G = ((t) => (t.VerifyMFACode = "verify-mfa-code", t.LostDevice = "lost-device", t.Cancel = "cancel-mfa-disable", t))(G || {});
    H = ((r10) => (r10.Harmony = "HARMONY", r10))(H || {});
    q = ((r10) => (r10.ClosedByUser = "closed-by-user", r10))(q || {});
    W = ((r10) => (r10.ClosedByUser = "closed-by-user-on-received", r10))(W || {});
    J = ((o) => (o.EnterNewPhoneNumber = "enter-new-phone-number", o.EnterOtpCode = "enter-otp-code", o.RecoveryFactorAlreadyExists = "recovery-factor-already-exists", o.MalformedPhoneNumber = "malformed-phone-number", o.InvalidOtpCode = "invalid-otp-code", o.RecoveryFactorUpdated = "recovery-factor-updated", o.RecoveryFactorDeleted = "recovery-factor-deleted", o))(J || {});
    Y = ((n) => (n.SendNewPhoneNumber = "send-new-phone-number", n.SendOtpCode = "send-otp-code", n.Cancel = "cancel", n.StartEditPhoneNumber = "start-edit-phone-number", n))(Y || {});
    B = ((r10) => (r10.PhoneNumber = "phone_number", r10))(B || {});
    P = ((a) => (a.SmsOtpSent = "sms-otp-sent", a.LoginThrottled = "login-throttled", a.InvalidSmsOtp = "invalid-sms-otp", a.SmsVerified = "sms-verified", a.AccountRecovered = "account-recovered", a.UpdateEmailRequired = "update-email-required", a))(P || {});
    j = ((n) => (n.Cancel = "cancel", n.VerifyOtp = "verify-otp-code", n.ResendSms = "resend-sms-otp", n.UpdateEmail = "update-email", n))(j || {});
    Q = ((n) => (n.Success = "nft-checkout-success", n.Failure = "nft-checkout-failure", n.Initiated = "nft-checkout-initiated", n.Disconnect = "disconnect", n))(Q || {});
    X = ((r10) => (r10.WalletInfoFetched = "Wallet/wallet-info-fetched", r10))(X || {});
    z = ((r10) => (r10.CloseMagicWindow = "close-magic-window", r10))(z || {});
  }
});

// ../../node_modules/.pnpm/@magic-sdk+provider@29.4.2_localforage@1.10.0/node_modules/@magic-sdk/provider/dist/es/index.mjs
function or(r10) {
  let e = { exports: {} };
  return r10(e, e.exports), e.exports;
}
function Wr(r10) {
  return String.fromCharCode(parseInt(r10.slice(1), 16));
}
function Jr(r10) {
  return `%${`00${r10.charCodeAt(0).toString(16)}`.slice(-2)}`;
}
function Gr(r10) {
  return btoa(encodeURIComponent(r10).replace(/%[0-9A-F]{2}/g, Wr));
}
function Kr(r10) {
  return decodeURIComponent(Array.from(atob(r10), Jr).join(""));
}
function ce(r10) {
  return Gr(JSON.stringify(r10));
}
function at(r10) {
  return JSON.parse(Kr(r10));
}
function N2(r10) {
  return typeof r10 > "u";
}
function Br(r10) {
  return r10 === null;
}
function le(r10) {
  return Br(r10) || N2(r10);
}
function ct(r10) {
  return le(r10) ? false : !N2(r10.jsonrpc) && !N2(r10.id) && (!N2(r10.result) || !N2(r10.error));
}
function lt(r10) {
  return le(r10) ? false : typeof r10 == "number" && Object.values(u).includes(r10);
}
function ee(r10) {
  if (!r10) return true;
  for (let e in r10) if (Object.hasOwnProperty.call(r10, e)) return false;
  return true;
}
function Hr(r10, e) {
  return Object.assign(m2, e), r10;
}
function ut() {
  return new $(m.MissingApiKey, "Please provide an API key that you acquired from the Magic developer dashboard.");
}
function pt() {
  return new $(m.ModalNotReady, "Modal is not ready");
}
function mt() {
  return new $(m.MalformedResponse, "Response from the Magic iframe is malformed.");
}
function ht(r10) {
  return new $(m.ExtensionNotInitialized, `Extensions must be initialized with a Magic SDK instance before \`Extension.${r10}\` can be accessed. Do not invoke \`Extension.${r10}\` inside an extension constructor.`);
}
function Et(r10) {
  let e = `Some extensions are incompatible with \`${m2.sdkName}@${m2.version}\`:`;
  return r10.filter((t) => typeof t.compat < "u" && t.compat !== null).forEach((t) => {
    let s = t.compat[m2.sdkName];
    typeof s == "string" ? e += `
  - Extension \`${t.name}\` supports version(s) \`${s}\`` : s || (e += `
  - Extension \`${t.name}\` does not support ${m2.platform} environments.`);
  }), new $(m.IncompatibleExtensions, e);
}
function ft(r10) {
  let e = (t) => {
    let s = t + 1, n = s % 10, o = s % 100;
    return n === 1 && o !== 11 ? `${s}st` : n === 2 && o !== 12 ? `${s}nd` : n === 3 && o !== 13 ? `${s}rd` : `${s}th`;
  };
  return new $(m.InvalidArgument, `Invalid ${e(r10.argument)} argument given to \`${r10.procedure}\`.
  Expected: \`${r10.expected}\`
  Received: \`${r10.received}\``);
}
function Bn() {
  return new L2(v.DuplicateIframe, "Duplicate iframes found.");
}
function gt() {
  return new L2(v.SyncWeb3Method, "Non-async web3 methods are deprecated in web3 > 1.0 and are not supported by the Magic web3 provider. Please use an async method instead.");
}
function yt() {
  return new L2(v.ReactNativeEndpointConfiguration, `CUSTOM DOMAINS ARE NOT SUPPORTED WHEN USING MAGIC SDK WITH REACT NATIVE! The \`endpoint\` parameter SHOULD NOT be provided. The Magic \`<iframe>\` is automatically wrapped by a WebView pointed at \`${m2.defaultEndpoint}\`. Changing this default behavior will lead to unexpected results and potentially security-threatening bugs.`);
}
function Rt(r10) {
  let { method: e, removalVersions: t, useInstead: s } = r10, n = t[m2.sdkName], o = s ? ` Use \`${s}\` instead.` : "", i = `\`${e}\` will be removed from \`${m2.sdkName}\` in version \`${n}\`.${o}`;
  return new L2(v.DeprecationNotice, i);
}
function* zr() {
  let r10 = 0;
  for (; ; ) r10 < Number.MAX_SAFE_INTEGER ? yield ++r10 : r10 = 0;
}
function $e() {
  return Yr.next().value;
}
function O2(r10) {
  return async (...e) => (pe || (pe = await m2.configureStorage()), await pe.ready(), pe[r10](...e));
}
function vt() {
  let r10 = window.crypto.getRandomValues(new Uint8Array(16));
  r10[6] = r10[6] & 15 | 64, r10[8] = r10[8] & 191 | 128;
  let e = "";
  return e += r10[0].toString(16), e += r10[1].toString(16), e += r10[2].toString(16), e += r10[3].toString(16), e += "-", e += r10[4].toString(16), e += r10[5].toString(16), e += "-", e += r10[6].toString(16), e += r10[7].toString(16), e += "-", e += r10[8].toString(16), e += r10[9].toString(16), e += "-", e += r10[10].toString(16), e += r10[11].toString(16), e += r10[12].toString(16), e += r10[13].toString(16), e += r10[14].toString(16), e += r10[15].toString(16), e;
}
function re() {
  let r10 = typeof window < "u" && !!window.crypto, e = r10 && !!window.crypto.subtle;
  return r10 && e;
}
function bt() {
  A2(he), A2(Oe);
}
async function Pt() {
  let r10 = await sn();
  if (!r10) {
    console.info("unable to create public key or webcrypto is unsupported");
    return;
  }
  let { subtle: e } = window.crypto, t = await R2(Oe);
  if (!t || !e) {
    console.info("unable to find private key or webcrypto unsupported");
    return;
  }
  let s = { iat: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3), jti: vt() }, o = { protected: Tt(JSON.stringify({ typ: "dpop+jwt", alg: "ES256", jwk: r10 })), claims: Tt(JSON.stringify(s)) }, i = an(`${o.protected}.${o.claims}`), a = { name: It, hash: { name: "SHA-256" } }, c = ln(new Uint8Array(await e.sign(a, t, i)));
  return `${o.protected}.${o.claims}.${c}`;
}
async function sn() {
  if (!re()) {
    console.info("webcrypto is not supported");
    return;
  }
  return await R2(he) || await on(), R2(he);
}
async function on() {
  let { subtle: r10 } = window.crypto, e = await r10.generateKey(nn, false, ["sign"]), t = await r10.exportKey("jwk", e.publicKey);
  await S2(Oe, e.privateKey), await S2(he, t);
}
function Tt(r10) {
  return wt(cn(r10));
}
function an(r10) {
  return new TextEncoder().encode(r10);
}
function wt(r10) {
  return btoa(r10).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+/g, "");
}
function cn(r10) {
  return encodeURIComponent(r10).replace(/%([0-9A-F]{2})/g, (t, s) => String.fromCharCode(parseInt(s, 16)));
}
function ln(r10) {
  let e = "";
  return r10.forEach((t) => {
    e += String.fromCharCode(t);
  }), wt(e);
}
function xt(r10) {
  return Object.defineProperty(r10, St, { value: true, enumerable: false }), r10;
}
function un(r10) {
  return !!r10[St];
}
function F2(r10) {
  return un(r10) || (r10.jsonrpc = r10.jsonrpc ?? "2.0", r10.id = $e(), r10.method = r10.method ?? "noop", r10.params = r10.params ?? [], xt(r10)), r10;
}
function p(r10, e = []) {
  return xt({ params: e, method: r10, jsonrpc: "2.0", id: $e() });
}
function fe() {
  let r10 = new ke();
  return { emitter: r10, createChainingEmitterMethod: (s, n) => (...o) => (r10[s].apply(r10, o), n), createBoundEmitterMethod: (s) => (...n) => r10[s].apply(r10, n) };
}
function $t(r10) {
  return !!r10[At];
}
function b2(r10) {
  let e = De(r10), { createBoundEmitterMethod: t, createChainingEmitterMethod: s } = fe(), n = Symbol("Promise.then"), o = Symbol("Promise.catch"), i = Symbol("Promise.finally"), a = (l, u2) => (...P2) => {
    let w2 = u2[l].apply(u2, P2);
    return c(w2);
  }, c = (l) => Object.assign(l, { [At]: true, [n]: l[n] || l.then, [o]: l[o] || l.catch, [i]: l[i] || l.finally, then: a(n, l), catch: a(o, l), finally: a(i, l), on: s("on", l), once: s("once", l), addListener: s("addListener", l), off: s("off", l), removeListener: s("removeListener", l), removeAllListeners: s("removeAllListeners", l), emit: t("emit"), eventNames: t("eventNames"), listeners: t("listeners"), listenerCount: t("listenerCount") }), d = c(e.then((l) => (d.emit("done", l), d.emit("settled"), l), (l) => {
    throw d.emit("error", l), d.emit("settled"), l;
  }));
  return d.on(W.ClosedByUser, () => {
    d.emit(q.ClosedByUser);
  }), d;
}
function De(r10) {
  return new Promise((e, t) => {
    let s = r10(e, t);
    Promise.resolve(s).catch(t);
  });
}
function Lt(r10, e) {
  let [t] = r10.split(".").map(Number);
  return t >= e;
}
async function Re() {
  let r10 = [];
  await Le((e, t, s) => {
    t.startsWith(`${qe}_`) && r10.push(t);
  });
  for (let e of r10) await A2(e);
}
function _t(r10) {
  let e = "", t = new Uint8Array(r10), s = t.byteLength;
  for (let n = 0; n < s; n++) e += String.fromCharCode(t[n]);
  return window.btoa(e);
}
function kt(r10) {
  let e = window.atob(r10), t = e.length, s = new Uint8Array(t);
  for (let n = 0; n < t; n++) s[n] = e.charCodeAt(n);
  return s.buffer;
}
async function In() {
  if (!re()) {
    console.info("webcrypto is not supported");
    return;
  }
  let { crypto: r10 } = window, e = await R2(Fe);
  return e || r10.getRandomValues(new Uint8Array(12));
}
async function bn() {
  if (!re()) {
    console.info("webcrypto is not supported");
    return;
  }
  let { subtle: r10 } = window.crypto, e = await R2(Ue);
  return e || await r10.generateKey({ name: We, length: Tn }, false, ["encrypt", "decrypt"]);
}
async function Dt(r10, e) {
  let t = await In(), s = await bn();
  if (!t || !s || !r10) return;
  let n = kt(r10), { subtle: o } = window.crypto, i = await o.encrypt({ name: We, iv: t }, s, n), a = _t(i);
  await S2(`${qe}_${e}`, a), await S2(Ue, s), await S2(Fe, t);
}
async function qt(r10) {
  let e = await R2(`${qe}_${r10}`), t = await R2(Fe), s = await R2(Ue);
  if (!t || !e || !s || !re()) return;
  let { subtle: n } = window.crypto, o = await n.decrypt({ name: We, iv: t }, s, kt(e));
  return _t(o);
}
function Je(r10, e) {
  return e ? new URL(r10, e) : new URL(r10);
}
function Wt(r10) {
  return r10.compat && r10.compat[m2.sdkName] != null ? typeof r10.compat[m2.sdkName] == "string" ? ot(it(m2.version), r10.compat[m2.sdkName]) : !!r10.compat[m2.sdkName] : true;
}
function wn(r10, e, t) {
  return !e && !t ? `${r10}_eth_mainnet` : t ? `${r10}_${JSON.stringify(t)}` : e ? typeof e == "string" ? `${r10}_eth_${e}` : `${r10}_${e.rpcUrl}_${e.chainId}_${e.chainType}` : `${r10}_unknown`;
}
function Sn(r10) {
  let e = r10?.extensions ?? [], t = {}, s = [];
  if (Array.isArray(e) ? e.forEach((n) => {
    Wt(n) ? (n.init(this), n.name && (this[n.name] = n), ee(n.config) || (t[n.name] = n.config)) : s.push(n);
  }) : Object.keys(e).forEach((n) => {
    if (Wt(e[n])) {
      e[n].init(this);
      let o = e[n];
      this[n] = o, ee(o.config) || (t[e[n].name] = o.config);
    } else s.push(e[n]);
  }), s.length) throw Et(s);
  return t;
}
function xn(r10, e) {
  return e && Array.isArray(r10) ? r10.find((t) => t.id === e) : r10;
}
function Jt(r10, e) {
  let t = e.data.response?.id, s = xn(r10, t);
  if (t && s) {
    let n = new K(s).applyResult(e.data.response.result).applyError(e.data.response.error);
    return { id: t, response: n };
  }
  return {};
}
async function Gt(r10, e, t) {
  let s = await R2("rt"), n;
  if (m2.platform === "web") try {
    n = await R2("jwt") ?? await Pt();
  } catch (a) {
    console.error("webcrypto error", a);
  }
  let o = { msgType: r10, payload: e };
  n && (o.jwt = n), n && s && (o.rt = s);
  let i = await qt(t);
  return i && (o.deviceShare = i), o;
}
async function Kt(r10) {
  r10.data.rt && await S2("rt", r10.data.rt);
}
function jt(r10, e) {
  let t = null;
  return function(...s) {
    t && clearTimeout(t), t = setTimeout(() => {
      r10(...s);
    }, e);
  };
}
function $n(r10) {
  let e = Object.getPrototypeOf(r10), t = [e];
  for (; e !== f2.prototype; ) e = Object.getPrototypeOf(e), t.push(e);
  return t;
}
var zt, Ce, Yt, Qt, Zt, er, tr, rr, nr, sr, Ct, ir, Ae, ar, h2, Z2, Xe, st, cr, lr, ze, oe, Ye, Qe, X2, M, dr, J2, ur, pr, mr, hr, Er, fr, gr, yr, Rr, vr, Tr, Ir, br, Ne, z2, Y2, Ze, et, Q2, y2, E2, Pr, wr, Sr, tt, xr, T2, Mr, Cr, Nr, Ar, $r, Lr, Or, _r, kr, Dr, ot, qr, rt, nt, Ur, Fr, ie, ae, it, m2, dt, $, U2, L2, de, te, Yr, me, pe, R2, S2, A2, Qr, Zr, en, tn, Le, Oe, he, It, rn, nn, St, K, Nt, ke, At, f2, vn, ye, qe, Ue, Fe, We, Tn, Te, Ie, Pe, we, H2, Se, Me, Ke, Nn, Bt, Vt, An, je, Ht, Ve, Be, He;
var init_es2 = __esm({
  "../../node_modules/.pnpm/@magic-sdk+provider@29.4.2_localforage@1.10.0/node_modules/@magic-sdk/provider/dist/es/index.mjs"() {
    "use strict";
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    init_es();
    zt = Object.create;
    Ce = Object.defineProperty;
    Yt = Object.getOwnPropertyDescriptor;
    Qt = Object.getOwnPropertyNames;
    Zt = Object.getPrototypeOf;
    er = Object.prototype.hasOwnProperty;
    tr = (r10, e) => () => (e || r10((e = { exports: {} }).exports, e), e.exports);
    rr = (r10, e) => {
      for (var t in e) Ce(r10, t, { get: e[t], enumerable: true });
    };
    nr = (r10, e, t, s) => {
      if (e && typeof e == "object" || typeof e == "function") for (let n of Qt(e)) !er.call(r10, n) && n !== t && Ce(r10, n, { get: () => e[n], enumerable: !(s = Yt(e, n)) || s.enumerable });
      return r10;
    };
    sr = (r10, e, t) => (t = r10 != null ? zt(Zt(r10)) : {}, nr(e || !r10 || !r10.__esModule ? Ce(t, "default", { value: r10, enumerable: true }) : t, r10));
    Ct = tr((ls, _e) => {
      "use strict";
      var pn = Object.prototype.hasOwnProperty, I2 = "~";
      function ne() {
      }
      Object.create && (ne.prototype = /* @__PURE__ */ Object.create(null), new ne().__proto__ || (I2 = false));
      function mn(r10, e, t) {
        this.fn = r10, this.context = e, this.once = t || false;
      }
      function Mt(r10, e, t, s, n) {
        if (typeof t != "function") throw new TypeError("The listener must be a function");
        var o = new mn(t, s || r10, n), i = I2 ? I2 + e : e;
        return r10._events[i] ? r10._events[i].fn ? r10._events[i] = [r10._events[i], o] : r10._events[i].push(o) : (r10._events[i] = o, r10._eventsCount++), r10;
      }
      function Ee(r10, e) {
        --r10._eventsCount === 0 ? r10._events = new ne() : delete r10._events[e];
      }
      function v2() {
        this._events = new ne(), this._eventsCount = 0;
      }
      v2.prototype.eventNames = function() {
        var e = [], t, s;
        if (this._eventsCount === 0) return e;
        for (s in t = this._events) pn.call(t, s) && e.push(I2 ? s.slice(1) : s);
        return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(t)) : e;
      };
      v2.prototype.listeners = function(e) {
        var t = I2 ? I2 + e : e, s = this._events[t];
        if (!s) return [];
        if (s.fn) return [s.fn];
        for (var n = 0, o = s.length, i = new Array(o); n < o; n++) i[n] = s[n].fn;
        return i;
      };
      v2.prototype.listenerCount = function(e) {
        var t = I2 ? I2 + e : e, s = this._events[t];
        return s ? s.fn ? 1 : s.length : 0;
      };
      v2.prototype.emit = function(e, t, s, n, o, i) {
        var a = I2 ? I2 + e : e;
        if (!this._events[a]) return false;
        var c = this._events[a], d = arguments.length, l, u2;
        if (c.fn) {
          switch (c.once && this.removeListener(e, c.fn, void 0, true), d) {
            case 1:
              return c.fn.call(c.context), true;
            case 2:
              return c.fn.call(c.context, t), true;
            case 3:
              return c.fn.call(c.context, t, s), true;
            case 4:
              return c.fn.call(c.context, t, s, n), true;
            case 5:
              return c.fn.call(c.context, t, s, n, o), true;
            case 6:
              return c.fn.call(c.context, t, s, n, o, i), true;
          }
          for (u2 = 1, l = new Array(d - 1); u2 < d; u2++) l[u2 - 1] = arguments[u2];
          c.fn.apply(c.context, l);
        } else {
          var P2 = c.length, w2;
          for (u2 = 0; u2 < P2; u2++) switch (c[u2].once && this.removeListener(e, c[u2].fn, void 0, true), d) {
            case 1:
              c[u2].fn.call(c[u2].context);
              break;
            case 2:
              c[u2].fn.call(c[u2].context, t);
              break;
            case 3:
              c[u2].fn.call(c[u2].context, t, s);
              break;
            case 4:
              c[u2].fn.call(c[u2].context, t, s, n);
              break;
            default:
              if (!l) for (w2 = 1, l = new Array(d - 1); w2 < d; w2++) l[w2 - 1] = arguments[w2];
              c[u2].fn.apply(c[u2].context, l);
          }
        }
        return true;
      };
      v2.prototype.on = function(e, t, s) {
        return Mt(this, e, t, s, false);
      };
      v2.prototype.once = function(e, t, s) {
        return Mt(this, e, t, s, true);
      };
      v2.prototype.removeListener = function(e, t, s, n) {
        var o = I2 ? I2 + e : e;
        if (!this._events[o]) return this;
        if (!t) return Ee(this, o), this;
        var i = this._events[o];
        if (i.fn) i.fn === t && (!n || i.once) && (!s || i.context === s) && Ee(this, o);
        else {
          for (var a = 0, c = [], d = i.length; a < d; a++) (i[a].fn !== t || n && !i[a].once || s && i[a].context !== s) && c.push(i[a]);
          c.length ? this._events[o] = c.length === 1 ? c[0] : c : Ee(this, o);
        }
        return this;
      };
      v2.prototype.removeAllListeners = function(e) {
        var t;
        return e ? (t = I2 ? I2 + e : e, this._events[t] && Ee(this, t)) : (this._events = new ne(), this._eventsCount = 0), this;
      };
      v2.prototype.off = v2.prototype.removeListener;
      v2.prototype.addListener = v2.prototype.on;
      v2.prefixed = I2;
      v2.EventEmitter = v2;
      typeof _e < "u" && (_e.exports = v2);
    });
    ir = Number.MAX_SAFE_INTEGER || 9007199254740991;
    Ae = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: ir, MAX_SAFE_COMPONENT_LENGTH: 16 };
    ar = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...r10) => console.error("SEMVER", ...r10) : () => {
    };
    h2 = ar;
    Z2 = or(function(r10, e) {
      let { MAX_SAFE_COMPONENT_LENGTH: t } = Ae, s = (e = r10.exports = {}).re = [], n = e.src = [], o = e.t = {}, i = 0, a = (c, d, l) => {
        let u2 = i++;
        h2(u2, d), o[c] = u2, n[u2] = d, s[u2] = new RegExp(d, l ? "g" : void 0);
      };
      a("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a("MAINVERSION", `(${n[o.NUMERICIDENTIFIER]})\\.(${n[o.NUMERICIDENTIFIER]})\\.(${n[o.NUMERICIDENTIFIER]})`), a("MAINVERSIONLOOSE", `(${n[o.NUMERICIDENTIFIERLOOSE]})\\.(${n[o.NUMERICIDENTIFIERLOOSE]})\\.(${n[o.NUMERICIDENTIFIERLOOSE]})`), a("PRERELEASEIDENTIFIER", `(?:${n[o.NUMERICIDENTIFIER]}|${n[o.NONNUMERICIDENTIFIER]})`), a("PRERELEASEIDENTIFIERLOOSE", `(?:${n[o.NUMERICIDENTIFIERLOOSE]}|${n[o.NONNUMERICIDENTIFIER]})`), a("PRERELEASE", `(?:-(${n[o.PRERELEASEIDENTIFIER]}(?:\\.${n[o.PRERELEASEIDENTIFIER]})*))`), a("PRERELEASELOOSE", `(?:-?(${n[o.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[o.PRERELEASEIDENTIFIERLOOSE]})*))`), a("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a("BUILD", `(?:\\+(${n[o.BUILDIDENTIFIER]}(?:\\.${n[o.BUILDIDENTIFIER]})*))`), a("FULLPLAIN", `v?${n[o.MAINVERSION]}${n[o.PRERELEASE]}?${n[o.BUILD]}?`), a("FULL", `^${n[o.FULLPLAIN]}$`), a("LOOSEPLAIN", `[v=\\s]*${n[o.MAINVERSIONLOOSE]}${n[o.PRERELEASELOOSE]}?${n[o.BUILD]}?`), a("LOOSE", `^${n[o.LOOSEPLAIN]}$`), a("GTLT", "((?:<|>)?=?)"), a("XRANGEIDENTIFIERLOOSE", `${n[o.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), a("XRANGEIDENTIFIER", `${n[o.NUMERICIDENTIFIER]}|x|X|\\*`), a("XRANGEPLAIN", `[v=\\s]*(${n[o.XRANGEIDENTIFIER]})(?:\\.(${n[o.XRANGEIDENTIFIER]})(?:\\.(${n[o.XRANGEIDENTIFIER]})(?:${n[o.PRERELEASE]})?${n[o.BUILD]}?)?)?`), a("XRANGEPLAINLOOSE", `[v=\\s]*(${n[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[o.XRANGEIDENTIFIERLOOSE]})(?:${n[o.PRERELEASELOOSE]})?${n[o.BUILD]}?)?)?`), a("XRANGE", `^${n[o.GTLT]}\\s*${n[o.XRANGEPLAIN]}$`), a("XRANGELOOSE", `^${n[o.GTLT]}\\s*${n[o.XRANGEPLAINLOOSE]}$`), a("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), a("COERCERTL", n[o.COERCE], true), a("LONETILDE", "(?:~>?)"), a("TILDETRIM", `(\\s*)${n[o.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", a("TILDE", `^${n[o.LONETILDE]}${n[o.XRANGEPLAIN]}$`), a("TILDELOOSE", `^${n[o.LONETILDE]}${n[o.XRANGEPLAINLOOSE]}$`), a("LONECARET", "(?:\\^)"), a("CARETTRIM", `(\\s*)${n[o.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", a("CARET", `^${n[o.LONECARET]}${n[o.XRANGEPLAIN]}$`), a("CARETLOOSE", `^${n[o.LONECARET]}${n[o.XRANGEPLAINLOOSE]}$`), a("COMPARATORLOOSE", `^${n[o.GTLT]}\\s*(${n[o.LOOSEPLAIN]})$|^$`), a("COMPARATOR", `^${n[o.GTLT]}\\s*(${n[o.FULLPLAIN]})$|^$`), a("COMPARATORTRIM", `(\\s*)${n[o.GTLT]}\\s*(${n[o.LOOSEPLAIN]}|${n[o.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", a("HYPHENRANGE", `^\\s*(${n[o.XRANGEPLAIN]})\\s+-\\s+(${n[o.XRANGEPLAIN]})\\s*$`), a("HYPHENRANGELOOSE", `^\\s*(${n[o.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[o.XRANGEPLAINLOOSE]})\\s*$`), a("STAR", "(<|>)?=?\\s*\\*"), a("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), a("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
    });
    Xe = /^[0-9]+$/;
    st = (r10, e) => {
      let t = Xe.test(r10), s = Xe.test(e);
      return t && s && (r10 = +r10, e = +e), r10 === e ? 0 : t && !s ? -1 : s && !t ? 1 : r10 < e ? -1 : 1;
    };
    cr = (r10, e) => st(e, r10);
    lr = { compareIdentifiers: st, rcompareIdentifiers: cr };
    ({ MAX_LENGTH: ze, MAX_SAFE_INTEGER: oe } = Ae);
    ({ re: Ye, t: Qe } = Z2);
    ({ compareIdentifiers: X2 } = lr);
    M = class r {
      constructor(e, t) {
        if (t && typeof t == "object" || (t = { loose: !!t, includePrerelease: false }), e instanceof r) {
          if (e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease) return e;
          e = e.version;
        } else if (typeof e != "string") throw new TypeError(`Invalid Version: ${e}`);
        if (e.length > ze) throw new TypeError(`version is longer than ${ze} characters`);
        h2("SemVer", e, t), this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease;
        let s = e.trim().match(t.loose ? Ye[Qe.LOOSE] : Ye[Qe.FULL]);
        if (!s) throw new TypeError(`Invalid Version: ${e}`);
        if (this.raw = e, this.major = +s[1], this.minor = +s[2], this.patch = +s[3], this.major > oe || this.major < 0) throw new TypeError("Invalid major version");
        if (this.minor > oe || this.minor < 0) throw new TypeError("Invalid minor version");
        if (this.patch > oe || this.patch < 0) throw new TypeError("Invalid patch version");
        s[4] ? this.prerelease = s[4].split(".").map((n) => {
          if (/^[0-9]+$/.test(n)) {
            let o = +n;
            if (o >= 0 && o < oe) return o;
          }
          return n;
        }) : this.prerelease = [], this.build = s[5] ? s[5].split(".") : [], this.format();
      }
      format() {
        return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
      }
      toString() {
        return this.version;
      }
      compare(e) {
        if (h2("SemVer.compare", this.version, this.options, e), !(e instanceof r)) {
          if (typeof e == "string" && e === this.version) return 0;
          e = new r(e, this.options);
        }
        return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
      }
      compareMain(e) {
        return e instanceof r || (e = new r(e, this.options)), X2(this.major, e.major) || X2(this.minor, e.minor) || X2(this.patch, e.patch);
      }
      comparePre(e) {
        if (e instanceof r || (e = new r(e, this.options)), this.prerelease.length && !e.prerelease.length) return -1;
        if (!this.prerelease.length && e.prerelease.length) return 1;
        if (!this.prerelease.length && !e.prerelease.length) return 0;
        let t = 0;
        do {
          let s = this.prerelease[t], n = e.prerelease[t];
          if (h2("prerelease compare", t, s, n), s === void 0 && n === void 0) return 0;
          if (n === void 0) return 1;
          if (s === void 0) return -1;
          if (s !== n) return X2(s, n);
        } while (++t);
      }
      compareBuild(e) {
        e instanceof r || (e = new r(e, this.options));
        let t = 0;
        do {
          let s = this.build[t], n = e.build[t];
          if (h2("prerelease compare", t, s, n), s === void 0 && n === void 0) return 0;
          if (n === void 0) return 1;
          if (s === void 0) return -1;
          if (s !== n) return X2(s, n);
        } while (++t);
      }
      inc(e, t) {
        switch (e) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", t), this.inc("pre", t);
            break;
          case "prerelease":
            this.prerelease.length === 0 && this.inc("patch", t), this.inc("pre", t);
            break;
          case "major":
            this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            this.prerelease.length === 0 && this.patch++, this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) this.prerelease = [0];
            else {
              let s = this.prerelease.length;
              for (; --s >= 0; ) typeof this.prerelease[s] == "number" && (this.prerelease[s]++, s = -2);
              s === -1 && this.prerelease.push(0);
            }
            t && (this.prerelease[0] === t ? isNaN(this.prerelease[1]) && (this.prerelease = [t, 0]) : this.prerelease = [t, 0]);
            break;
          default:
            throw new Error(`invalid increment argument: ${e}`);
        }
        return this.format(), this.raw = this.version, this;
      }
    };
    dr = (r10, e, t) => new M(r10, t).compare(new M(e, t));
    J2 = dr;
    ur = (r10, e, t) => J2(r10, e, t) === 0;
    pr = ur;
    mr = (r10, e, t) => J2(r10, e, t) !== 0;
    hr = mr;
    Er = (r10, e, t) => J2(r10, e, t) > 0;
    fr = Er;
    gr = (r10, e, t) => J2(r10, e, t) >= 0;
    yr = gr;
    Rr = (r10, e, t) => J2(r10, e, t) < 0;
    vr = Rr;
    Tr = (r10, e, t) => J2(r10, e, t) <= 0;
    Ir = Tr;
    br = (r10, e, t, s) => {
      switch (e) {
        case "===":
          return typeof r10 == "object" && (r10 = r10.version), typeof t == "object" && (t = t.version), r10 === t;
        case "!==":
          return typeof r10 == "object" && (r10 = r10.version), typeof t == "object" && (t = t.version), r10 !== t;
        case "":
        case "=":
        case "==":
          return pr(r10, t, s);
        case "!=":
          return hr(r10, t, s);
        case ">":
          return fr(r10, t, s);
        case ">=":
          return yr(r10, t, s);
        case "<":
          return vr(r10, t, s);
        case "<=":
          return Ir(r10, t, s);
        default:
          throw new TypeError(`Invalid operator: ${e}`);
      }
    };
    Ne = br;
    z2 = Symbol("SemVer ANY");
    Y2 = class r2 {
      static get ANY() {
        return z2;
      }
      constructor(e, t) {
        if (t && typeof t == "object" || (t = { loose: !!t, includePrerelease: false }), e instanceof r2) {
          if (e.loose === !!t.loose) return e;
          e = e.value;
        }
        h2("comparator", e, t), this.options = t, this.loose = !!t.loose, this.parse(e), this.semver === z2 ? this.value = "" : this.value = this.operator + this.semver.version, h2("comp", this);
      }
      parse(e) {
        let t = this.options.loose ? Ze[et.COMPARATORLOOSE] : Ze[et.COMPARATOR], s = e.match(t);
        if (!s) throw new TypeError(`Invalid comparator: ${e}`);
        this.operator = s[1] !== void 0 ? s[1] : "", this.operator === "=" && (this.operator = ""), s[2] ? this.semver = new M(s[2], this.options.loose) : this.semver = z2;
      }
      toString() {
        return this.value;
      }
      test(e) {
        if (h2("Comparator.test", e, this.options.loose), this.semver === z2 || e === z2) return true;
        if (typeof e == "string") try {
          e = new M(e, this.options);
        } catch {
          return false;
        }
        return Ne(e, this.operator, this.semver, this.options);
      }
      intersects(e, t) {
        if (!(e instanceof r2)) throw new TypeError("a Comparator is required");
        if (t && typeof t == "object" || (t = { loose: !!t, includePrerelease: false }), this.operator === "") return this.value === "" || new Q2(e.value, t).test(this.value);
        if (e.operator === "") return e.value === "" || new Q2(this.value, t).test(e.semver);
        let s = !(this.operator !== ">=" && this.operator !== ">" || e.operator !== ">=" && e.operator !== ">"), n = !(this.operator !== "<=" && this.operator !== "<" || e.operator !== "<=" && e.operator !== "<"), o = this.semver.version === e.semver.version, i = !(this.operator !== ">=" && this.operator !== "<=" || e.operator !== ">=" && e.operator !== "<="), a = Ne(this.semver, "<", e.semver, t) && (this.operator === ">=" || this.operator === ">") && (e.operator === "<=" || e.operator === "<"), c = Ne(this.semver, ">", e.semver, t) && (this.operator === "<=" || this.operator === "<") && (e.operator === ">=" || e.operator === ">");
        return s || n || o && i || a || c;
      }
    };
    ({ re: Ze, t: et } = Z2);
    Q2 = class r3 {
      constructor(e, t) {
        if (t && typeof t == "object" || (t = { loose: !!t, includePrerelease: false }), e instanceof r3) return e.loose === !!t.loose && e.includePrerelease === !!t.includePrerelease ? e : new r3(e.raw, t);
        if (e instanceof Y2) return this.raw = e.value, this.set = [[e]], this.format(), this;
        if (this.options = t, this.loose = !!t.loose, this.includePrerelease = !!t.includePrerelease, this.raw = e, this.set = e.split(/\s*\|\|\s*/).map((s) => this.parseRange(s.trim())).filter((s) => s.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${e}`);
        this.format();
      }
      format() {
        return this.range = this.set.map((e) => e.join(" ").trim()).join("||").trim(), this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(e) {
        let { loose: t } = this.options;
        e = e.trim();
        let s = t ? y2[E2.HYPHENRANGELOOSE] : y2[E2.HYPHENRANGE];
        e = e.replace(s, kr(this.options.includePrerelease)), h2("hyphen replace", e), e = e.replace(y2[E2.COMPARATORTRIM], Pr), h2("comparator trim", e, y2[E2.COMPARATORTRIM]), e = (e = (e = e.replace(y2[E2.TILDETRIM], wr)).replace(y2[E2.CARETTRIM], Sr)).split(/\s+/).join(" ");
        let n = t ? y2[E2.COMPARATORLOOSE] : y2[E2.COMPARATOR];
        return e.split(" ").map((o) => xr(o, this.options)).join(" ").split(/\s+/).map((o) => _r(o, this.options)).filter(this.options.loose ? (o) => !!o.match(n) : () => true).map((o) => new Y2(o, this.options));
      }
      intersects(e, t) {
        if (!(e instanceof r3)) throw new TypeError("a Range is required");
        return this.set.some((s) => tt(s, t) && e.set.some((n) => tt(n, t) && s.every((o) => n.every((i) => o.intersects(i, t)))));
      }
      test(e) {
        if (!e) return false;
        if (typeof e == "string") try {
          e = new M(e, this.options);
        } catch {
          return false;
        }
        for (let t = 0; t < this.set.length; t++) if (Dr(this.set[t], e, this.options)) return true;
        return false;
      }
    };
    ({ re: y2, t: E2, comparatorTrimReplace: Pr, tildeTrimReplace: wr, caretTrimReplace: Sr } = Z2);
    tt = (r10, e) => {
      let t = true, s = r10.slice(), n = s.pop();
      for (; t && s.length; ) t = s.every((o) => n.intersects(o, e)), n = s.pop();
      return t;
    };
    xr = (r10, e) => (h2("comp", r10, e), r10 = Nr(r10, e), h2("caret", r10), r10 = Mr(r10, e), h2("tildes", r10), r10 = $r(r10, e), h2("xrange", r10), r10 = Or(r10, e), h2("stars", r10), r10);
    T2 = (r10) => !r10 || r10.toLowerCase() === "x" || r10 === "*";
    Mr = (r10, e) => r10.trim().split(/\s+/).map((t) => Cr(t, e)).join(" ");
    Cr = (r10, e) => {
      let t = e.loose ? y2[E2.TILDELOOSE] : y2[E2.TILDE];
      return r10.replace(t, (s, n, o, i, a) => {
        let c;
        return h2("tilde", r10, s, n, o, i, a), T2(n) ? c = "" : T2(o) ? c = `>=${n}.0.0 <${+n + 1}.0.0-0` : T2(i) ? c = `>=${n}.${o}.0 <${n}.${+o + 1}.0-0` : a ? (h2("replaceTilde pr", a), c = `>=${n}.${o}.${i}-${a} <${n}.${+o + 1}.0-0`) : c = `>=${n}.${o}.${i} <${n}.${+o + 1}.0-0`, h2("tilde return", c), c;
      });
    };
    Nr = (r10, e) => r10.trim().split(/\s+/).map((t) => Ar(t, e)).join(" ");
    Ar = (r10, e) => {
      h2("caret", r10, e);
      let t = e.loose ? y2[E2.CARETLOOSE] : y2[E2.CARET], s = e.includePrerelease ? "-0" : "";
      return r10.replace(t, (n, o, i, a, c) => {
        let d;
        return h2("caret", r10, n, o, i, a, c), T2(o) ? d = "" : T2(i) ? d = `>=${o}.0.0${s} <${+o + 1}.0.0-0` : T2(a) ? d = o === "0" ? `>=${o}.${i}.0${s} <${o}.${+i + 1}.0-0` : `>=${o}.${i}.0${s} <${+o + 1}.0.0-0` : c ? (h2("replaceCaret pr", c), d = o === "0" ? i === "0" ? `>=${o}.${i}.${a}-${c} <${o}.${i}.${+a + 1}-0` : `>=${o}.${i}.${a}-${c} <${o}.${+i + 1}.0-0` : `>=${o}.${i}.${a}-${c} <${+o + 1}.0.0-0`) : (h2("no pr"), d = o === "0" ? i === "0" ? `>=${o}.${i}.${a}${s} <${o}.${i}.${+a + 1}-0` : `>=${o}.${i}.${a}${s} <${o}.${+i + 1}.0-0` : `>=${o}.${i}.${a} <${+o + 1}.0.0-0`), h2("caret return", d), d;
      });
    };
    $r = (r10, e) => (h2("replaceXRanges", r10, e), r10.split(/\s+/).map((t) => Lr(t, e)).join(" "));
    Lr = (r10, e) => {
      r10 = r10.trim();
      let t = e.loose ? y2[E2.XRANGELOOSE] : y2[E2.XRANGE];
      return r10.replace(t, (s, n, o, i, a, c) => {
        h2("xRange", r10, s, n, o, i, a, c);
        let d = T2(o), l = d || T2(i), u2 = l || T2(a), P2 = u2;
        return n === "=" && P2 && (n = ""), c = e.includePrerelease ? "-0" : "", d ? s = n === ">" || n === "<" ? "<0.0.0-0" : "*" : n && P2 ? (l && (i = 0), a = 0, n === ">" ? (n = ">=", l ? (o = +o + 1, i = 0, a = 0) : (i = +i + 1, a = 0)) : n === "<=" && (n = "<", l ? o = +o + 1 : i = +i + 1), n === "<" && (c = "-0"), s = `${n + o}.${i}.${a}${c}`) : l ? s = `>=${o}.0.0${c} <${+o + 1}.0.0-0` : u2 && (s = `>=${o}.${i}.0${c} <${o}.${+i + 1}.0-0`), h2("xRange return", s), s;
      });
    };
    Or = (r10, e) => (h2("replaceStars", r10, e), r10.trim().replace(y2[E2.STAR], ""));
    _r = (r10, e) => (h2("replaceGTE0", r10, e), r10.trim().replace(y2[e.includePrerelease ? E2.GTE0PRE : E2.GTE0], ""));
    kr = (r10) => (e, t, s, n, o, i, a, c, d, l, u2, P2, w2) => `${t = T2(s) ? "" : T2(n) ? `>=${s}.0.0${r10 ? "-0" : ""}` : T2(o) ? `>=${s}.${n}.0${r10 ? "-0" : ""}` : i ? `>=${t}` : `>=${t}${r10 ? "-0" : ""}`} ${c = T2(d) ? "" : T2(l) ? `<${+d + 1}.0.0-0` : T2(u2) ? `<${d}.${+l + 1}.0-0` : P2 ? `<=${d}.${l}.${u2}-${P2}` : r10 ? `<${d}.${l}.${+u2 + 1}-0` : `<=${c}`}`.trim();
    Dr = (r10, e, t) => {
      for (let s = 0; s < r10.length; s++) if (!r10[s].test(e)) return false;
      if (e.prerelease.length && !t.includePrerelease) {
        for (let s = 0; s < r10.length; s++) if (h2(r10[s].semver), r10[s].semver !== Y2.ANY && r10[s].semver.prerelease.length > 0) {
          let n = r10[s].semver;
          if (n.major === e.major && n.minor === e.minor && n.patch === e.patch) return true;
        }
        return false;
      }
      return true;
    };
    ot = (r10, e, t) => {
      try {
        e = new Q2(e, t);
      } catch {
        return false;
      }
      return e.test(r10);
    };
    ({ MAX_LENGTH: qr } = Ae);
    ({ re: rt, t: nt } = Z2);
    Ur = (r10, e) => {
      if (e && typeof e == "object" || (e = { loose: !!e, includePrerelease: false }), r10 instanceof M) return r10;
      if (typeof r10 != "string" || r10.length > qr || !(e.loose ? rt[nt.LOOSE] : rt[nt.FULL]).test(r10)) return null;
      try {
        return new M(r10, e);
      } catch {
        return null;
      }
    };
    Fr = Ur;
    ({ re: ie, t: ae } = Z2);
    it = (r10, e) => {
      if (r10 instanceof M) return r10;
      if (typeof r10 == "number" && (r10 = String(r10)), typeof r10 != "string") return null;
      let t = null;
      if ((e = e || {}).rtl) {
        let s;
        for (; (s = ie[ae.COERCERTL].exec(r10)) && (!t || t.index + t[0].length !== r10.length); ) t && s.index + s[0].length === t.index + t[0].length || (t = s), ie[ae.COERCERTL].lastIndex = s.index + s[1].length + s[2].length;
        ie[ae.COERCERTL].lastIndex = -1;
      } else t = r10.match(ie[ae.COERCE]);
      return t === null ? null : Fr(`${t[2]}.${t[3] || "0"}.${t[4] || "0"}`, e);
    };
    m2 = {};
    dt = { "magic-sdk": "magic-sdk", "@magic-sdk/react-native": "magic-sdk-rn", "@magic-sdk/react-native-bare": "magic-sdk-rn-bare", "@magic-sdk/react-native-expo": "magic-sdk-rn-expo" };
    $ = class r4 extends Error {
      constructor(t, s) {
        super(`Magic SDK Error: [${t}] ${s}`);
        this.code = t;
        this.rawMessage = s;
        Object.setPrototypeOf(this, r4.prototype);
      }
      __proto__ = Error;
    };
    U2 = class r5 extends Error {
      __proto__ = Error;
      code;
      rawMessage;
      data;
      constructor(e) {
        super();
        let t = Number(e?.code);
        this.rawMessage = e?.message || "Internal error", this.code = lt(t) ? t : u.InternalError, this.message = `Magic RPC Error: [${this.code}] ${this.rawMessage}`, this.data = e?.data || void 0, Object.setPrototypeOf(this, r5.prototype);
      }
    };
    L2 = class {
      constructor(e, t) {
        this.code = e;
        this.rawMessage = t;
        this.message = `Magic SDK Warning: [${e}] ${t}`;
      }
      message;
      log() {
        console.warn(this.message);
      }
    };
    de = class r6 extends Error {
      constructor(t, s, n, o) {
        super(`Magic Extension Error (${t.name}): [${s}] ${n}`);
        this.code = s;
        this.rawMessage = n;
        this.data = o;
        Object.setPrototypeOf(this, r6.prototype);
      }
      __proto__ = Error;
    };
    te = class {
      constructor(e, t, s) {
        this.code = t;
        this.rawMessage = s;
        this.message = `Magic Extension Warning (${e.name}): [${t}] ${s}`;
      }
      message;
      log() {
        console.warn(this.message);
      }
    };
    Yr = zr();
    me = {};
    rr(me, { clear: () => Qr, getItem: () => R2, iterate: () => Le, key: () => en, keys: () => tn, length: () => Zr, removeItem: () => A2, setItem: () => S2 });
    R2 = O2("getItem");
    S2 = O2("setItem");
    A2 = O2("removeItem");
    Qr = O2("clear");
    Zr = O2("length");
    en = O2("key");
    tn = O2("keys");
    Le = O2("iterate");
    Oe = "STORE_KEY_PRIVATE_KEY";
    he = "STORE_KEY_PUBLIC_JWK";
    It = "ECDSA";
    rn = "P-256";
    nn = { name: It, namedCurve: rn };
    St = Symbol("Payload pre-processed by Magic SDK");
    K = class r7 {
      _jsonrpc;
      _id;
      _result;
      _error;
      constructor(e) {
        e instanceof r7 ? (this._jsonrpc = e.payload.jsonrpc, this._id = e.payload.id, this._result = e.payload.result, this._error = e.payload.error) : ct(e) ? (this._jsonrpc = e.jsonrpc, this._id = e.id, this._result = e.result, this._error = e.error) : (this._jsonrpc = e.jsonrpc, this._id = e.id, this._result = void 0, this._error = void 0);
      }
      applyError(e) {
        return this._error = e, this;
      }
      applyResult(e) {
        return this._result = e, this;
      }
      get hasError() {
        return this._error?.code === u.DpopInvalidated && bt(), typeof this._error < "u" && this._error !== null;
      }
      get hasResult() {
        return typeof this._result < "u";
      }
      get payload() {
        return { jsonrpc: this._jsonrpc, id: this._id, result: this._result, error: this._error };
      }
    };
    Nt = sr(Ct());
    ke = class extends Nt.default {
    };
    At = Symbol("isPromiEvent");
    f2 = class {
      constructor(e) {
        this.sdk = e;
      }
      get overlay() {
        return this.sdk.overlay;
      }
      request(e) {
        if (this.sdk.thirdPartyWallets.isConnected && !Z.includes(e.method)) return b2((i, a) => {
          this.sdk.thirdPartyWallets.requestOverride(e).then(i).catch(a);
        });
        let t = this.overlay.post(y.MAGIC_HANDLE_REQUEST, F2(e)), s = b2((o, i) => {
          t.then((a) => {
            if (n(), a.hasError) i(new U2(a.payload.error));
            else if (a.hasResult) o(a.payload.result);
            else throw mt();
          }).catch((a) => {
            n(), i(a);
          });
        }), n = this.overlay.on(E.MAGIC_HANDLE_EVENT, (o) => {
          let { response: i } = o.data;
          if (i.id === e.id && i.result?.event) {
            let { event: a, params: c = [] } = i.result;
            s.emit(a, ...c);
          }
        });
        return s;
      }
      createIntermediaryEvent(e, t) {
        return (n) => {
          let o = p(g.IntermediaryEvent, [{ payloadId: t, eventType: e, args: n }]);
          this.request(o);
        };
      }
    };
    vn = { "magic-sdk": "v18.0.0", "@magic-sdk/react-native": "v14.0.0", "@magic-sdk/react-native-bare": "v19.0.0", "@magic-sdk/react-native-expo": "v19.0.0" };
    ye = class extends f2 {
      loginWithMagicLink(e) {
        let t = m2.sdkName === "@magic-sdk/react-native" || m2.sdkName === "@magic-sdk/react-native-bare" || m2.sdkName === "@magic-sdk/react-native-expo";
        if (t && Lt(m2.version, 19)) throw new Error("loginWithMagicLink() is deprecated for this package, please utilize a passcode method like loginWithSMS or loginWithEmailOTP instead.");
        t && Rt({ method: "auth.loginWithMagicLink()", removalVersions: vn, useInstead: "auth.loginWithEmailOTP()" }).log();
        let { email: s, showUI: n = true, redirectURI: o, overrides: i, lifespan: a } = e, c = p(this.sdk.testMode ? g.LoginWithMagicLinkTestMode : g.LoginWithMagicLink, [{ email: s, showUI: n, redirectURI: o, overrides: i, lifespan: a }]);
        return this.request(c);
      }
      loginWithSMS(e) {
        let { phoneNumber: t, showUI: s = true, lifespan: n } = e, o = p(this.sdk.testMode ? g.LoginWithSmsTestMode : g.LoginWithSms, [{ phoneNumber: t, showUI: s, lifespan: n }]), i = this.request(o);
        return !s && i && (i.on(N.VerifySmsOtp, (a) => {
          this.createIntermediaryEvent(N.VerifySmsOtp, o.id)(a);
        }), i.on(N.Cancel, () => {
          this.createIntermediaryEvent(N.Cancel, o.id)();
        })), i;
      }
      loginWithEmailOTP(e) {
        let { email: t, showUI: s, deviceCheckUI: n, overrides: o, lifespan: i } = e, a = p(this.sdk.testMode ? g.LoginWithEmailOTPTestMode : g.LoginWithEmailOTP, [{ email: t, showUI: s, deviceCheckUI: n, overrides: o, lifespan: i }]), c = this.request(a);
        return !n && c && c.on(O.Retry, () => {
          this.createIntermediaryEvent(O.Retry, a.id)();
        }), !s && c && (c.on(I.VerifyEmailOtp, (d) => {
          this.createIntermediaryEvent(I.VerifyEmailOtp, a.id)(d);
        }), c.on(I.VerifyMFACode, (d) => {
          this.createIntermediaryEvent(I.VerifyMFACode, a.id)(d);
        }), c.on(I.LostDevice, () => {
          this.createIntermediaryEvent(I.LostDevice, a.id)();
        }), c.on(I.VerifyRecoveryCode, (d) => {
          this.createIntermediaryEvent(I.VerifyRecoveryCode, a.id)(d);
        }), c.on(I.Cancel, () => {
          this.createIntermediaryEvent(I.Cancel, a.id)();
        })), c;
      }
      loginWithCredential(e) {
        let { credentialOrQueryString: t, lifespan: s } = e || {}, n = t ?? "";
        if (!t && m2.platform === "web") {
          n = window.location.search;
          let i = window.location.origin + window.location.pathname;
          window.history.replaceState(null, "", i);
        }
        let o = p(this.sdk.testMode ? g.LoginWithCredentialTestMode : g.LoginWithCredential, [n, s]);
        return this.request(o);
      }
      setAuthorizationToken(e) {
        let t = p(g.SetAuthorizationToken, [{ jwt: e }]);
        return this.request(t);
      }
      updateEmailWithUI(e) {
        let { email: t, showUI: s = true } = e, n = p(this.sdk.testMode ? g.UpdateEmailTestMode : g.UpdateEmail, [{ email: t, showUI: s }]), o = this.request(n);
        return s || (o.on(b.Retry, () => {
          this.createIntermediaryEvent(b.Retry, n.id)();
        }), o.on(b.Cancel, () => {
          this.createIntermediaryEvent(b.Cancel, n.id)();
        }), o.on(b.VerifyEmailOtp, (i) => {
          this.createIntermediaryEvent(b.VerifyEmailOtp, n.id)(i);
        }), o.on(b.VerifyMFACode, (i) => {
          this.createIntermediaryEvent(b.VerifyMFACode, n.id)(i);
        }), o.on(F.RetryWithNewEmail, (i) => {
          this.createIntermediaryEvent(F.RetryWithNewEmail, n.id)(i);
        }), o.on(F.Cancel, () => {
          this.createIntermediaryEvent(F.Cancel, n.id)();
        }), o.on(F.VerifyEmailOtp, (i) => {
          this.createIntermediaryEvent(F.VerifyEmailOtp, n.id)(i);
        })), o;
      }
    };
    qe = "ds";
    Ue = "ek";
    Fe = "iv";
    We = "AES-GCM";
    Tn = 256;
    Te = class extends f2 {
      getIdToken(e) {
        let t = p(this.sdk.testMode ? g.GetIdTokenTestMode : g.GetIdToken, [e]);
        return this.request(t);
      }
      generateIdToken(e) {
        let t = p(this.sdk.testMode ? g.GenerateIdTokenTestMode : g.GenerateIdToken, [e]);
        return this.request(t);
      }
      getInfo() {
        let e = p(g.GetInfo, []);
        return this.request(e);
      }
      isLoggedIn() {
        return b2(async (e, t) => {
          try {
            let s = false;
            this.sdk.useStorageCache && (s = await R2(this.localForageIsLoggedInKey) === "true", s && e(true));
            let n = p(this.sdk.testMode ? g.IsLoggedInTestMode : g.IsLoggedIn), o = await this.request(n);
            this.sdk.useStorageCache && (o ? S2(this.localForageIsLoggedInKey, true) : A2(this.localForageIsLoggedInKey), s && !o && this.emitUserLoggedOut(true)), e(o);
          } catch (s) {
            t(s);
          }
        });
      }
      logout() {
        return A2(this.localForageIsLoggedInKey), Re(), b2(async (e, t) => {
          try {
            let s = p(this.sdk.testMode ? g.LogoutTestMode : g.Logout), n = await this.request(s);
            this.sdk.useStorageCache && this.emitUserLoggedOut(n), e(n);
          } catch (s) {
            t(s);
          }
        });
      }
      requestInfoWithUI(e) {
        let t = p(g.RequestUserInfoWithUI, e ? [e] : []);
        return this.request(t);
      }
      showSettings(e) {
        let { showUI: t = true } = e || {}, s = p(this.sdk.testMode ? g.UserSettingsTestMode : g.UserSettings, [e]), n = this.request(s);
        return !t && n && (n.on(Y.SendNewPhoneNumber, (o) => {
          this.createIntermediaryEvent(Y.SendNewPhoneNumber, s.id)(o);
        }), n.on(Y.SendOtpCode, (o) => {
          this.createIntermediaryEvent(Y.SendOtpCode, s.id)(o);
        }), n.on(Y.StartEditPhoneNumber, () => {
          this.createIntermediaryEvent(Y.StartEditPhoneNumber, s.id)();
        }), n.on(Y.Cancel, () => {
          this.createIntermediaryEvent(Y.Cancel, s.id)();
        }), n.on(b.VerifyEmailOtp, (o) => {
          this.createIntermediaryEvent(b.VerifyEmailOtp, s.id)(o);
        })), n;
      }
      recoverAccount(e) {
        let { email: t, showUI: s } = e, n = p(this.sdk.testMode ? g.RecoverAccountTestMode : g.RecoverAccount, [{ email: t, showUI: s }]), o = this.request(n);
        return !s && o && (o.on(j.Cancel, () => {
          this.createIntermediaryEvent(j.Cancel, n.id)();
        }), o.on(j.ResendSms, () => {
          this.createIntermediaryEvent(j.ResendSms, n.id)();
        }), o.on(j.VerifyOtp, (i) => {
          this.createIntermediaryEvent(j.VerifyOtp, n.id)(i);
        }), o.on(j.UpdateEmail, (i) => {
          this.createIntermediaryEvent(j.UpdateEmail, n.id)(i);
        }), o.on(F.Cancel, () => {
          this.createIntermediaryEvent(F.Cancel, n.id)();
        }), o.on(F.RetryWithNewEmail, (i) => {
          this.createIntermediaryEvent(F.RetryWithNewEmail, n.id)(i);
        }), o.on(F.VerifyEmailOtp, (i) => {
          this.createIntermediaryEvent(F.VerifyEmailOtp, n.id)(i);
        })), o;
      }
      revealPrivateKey() {
        let e = p(g.RevealPK);
        return this.request(e);
      }
      onUserLoggedOut(e) {
        this.userLoggedOutCallbacks.push(e);
      }
      enableMFA(e) {
        let { showUI: t = true } = e, s = p(g.EnableMFA, [{ showUI: t }]), n = this.request(s);
        return !t && n && (n.on(D.VerifyMFACode, (o) => {
          this.createIntermediaryEvent(D.VerifyMFACode, s.id)(o);
        }), n.on(D.Cancel, () => {
          this.createIntermediaryEvent(D.Cancel, s.id)();
        })), n;
      }
      disableMFA(e) {
        let { showUI: t = true } = e, s = p(g.DisableMFA, [{ showUI: t }]), n = this.request(s);
        return !t && n && (n.on(G.VerifyMFACode, (o) => {
          this.createIntermediaryEvent(G.VerifyMFACode, s.id)(o);
        }), n.on(G.LostDevice, (o) => {
          this.createIntermediaryEvent(G.LostDevice, s.id)(o);
        }), n.on(G.Cancel, () => {
          this.createIntermediaryEvent(G.Cancel, s.id)();
        })), n;
      }
      emitUserLoggedOut(e) {
        this.userLoggedOutCallbacks.forEach((t) => {
          t(e);
        });
      }
      localForageIsLoggedInKey = "magic_auth_is_logged_in";
      userLoggedOutCallbacks = [];
    };
    Ie = class extends f2 {
      connectWithUI(e) {
        let t = b2(async (s, n) => {
          try {
            let o = p(g.Login, [{ enabledWallets: this.sdk.thirdPartyWallets.enabledWallets, ...e }]), i = this.request(o);
            this.sdk.thirdPartyWallets.eventListeners.forEach(({ event: c, callback: d }) => {
              i.on(c, () => d(o.id));
            }), i.on("id-token-created", (c) => {
              t.emit("id-token-created", c);
            });
            let a = await i;
            a.error && n(a), s(a);
          } catch (o) {
            n(o);
          }
        });
        return t;
      }
      showUI(e) {
        return this.request(p(g.ShowUI, [e]));
      }
      showAddress() {
        return this.request(p(g.ShowAddress));
      }
      showSendTokensUI() {
        return this.request(p(g.ShowSendTokensUI));
      }
      showOnRamp() {
        return this.request(p(g.ShowOnRamp));
      }
      showNFTs() {
        return this.request(p(g.ShowNFTs));
      }
      showBalances() {
        return this.request(p(g.ShowBalances));
      }
      sendGaslessTransaction(e, t) {
        return this.request(p(g.SendGaslessTransaction, [e, t]));
      }
    };
    Pe = class extends f2 {
      eventListeners = [];
      enabledWallets = {};
      isConnected = false;
      resetThirdPartyWalletState() {
        localStorage.removeItem(_.PROVIDER), localStorage.removeItem(_.ADDRESS), localStorage.removeItem(_.CHAIN_ID), this.isConnected = false;
      }
      requestOverride(e) {
        if (e.method === g.Login) return this.resetThirdPartyWalletState(), super.request(e);
        if (e.method === g.GetInfo) return this.getInfo(e);
        if (e.method === g.IsLoggedIn) return this.isLoggedIn(e);
        if (e.method === g.Logout) return this.logout(e);
        switch (localStorage.getItem(_.PROVIDER)) {
          case "web3modal":
            return this.web3modalRequest(e);
          default:
            return this.resetThirdPartyWalletState(), super.request(e);
        }
      }
      isLoggedIn(e) {
        switch (localStorage.getItem(_.PROVIDER)) {
          case "web3modal":
            return this.web3modalIsLoggedIn();
          default:
            return this.resetThirdPartyWalletState(), super.request(e);
        }
      }
      getInfo(e) {
        switch (localStorage.getItem(_.PROVIDER)) {
          case "web3modal":
            return this.web3modalGetInfo();
          default:
            return this.resetThirdPartyWalletState(), super.request(e);
        }
      }
      logout(e) {
        let t = localStorage.getItem(_.PROVIDER);
        switch (this.resetThirdPartyWalletState(), t) {
          case "web3modal":
            return this.web3modalLogout();
          default:
            return super.request(e);
        }
      }
      web3modalRequest(e) {
        return b2((t, s) => {
          this.sdk.web3modal.modal.getWalletProvider().request(e).then(t).catch(s);
        });
      }
      web3modalIsLoggedIn() {
        return b2((e) => {
          let t = this.sdk.web3modal.modal.getStatus();
          if (t === "connected" && e(true), t === "disconnected" && (this.resetThirdPartyWalletState(), e(false)), t === "reconnecting") {
            let s = this.sdk.web3modal.modal.subscribeProvider(({ status: n }) => {
              n === "connected" && (s(), e(true)), n === "disconnected" && (s(), this.resetThirdPartyWalletState(), e(false));
            });
          }
        });
      }
      formatWeb3modalGetInfoResponse() {
        let e = this.sdk.web3modal.modal.getWalletInfo()?.name, t = this.sdk.web3modal.modal.getAddress();
        return { publicAddress: t, email: null, issuer: `did:ethr:${t}`, phoneNumber: null, isMfaEnabled: false, recoveryFactors: [], walletType: e || "web3modal", firstLoginAt: null };
      }
      web3modalGetInfo() {
        return b2((e, t) => {
          let s = this.sdk.web3modal.modal.getStatus();
          if (s === "connected" && e(this.formatWeb3modalGetInfoResponse()), s === "disconnected" && (this.resetThirdPartyWalletState(), t("Magic RPC Error: [-32603] Internal error: User denied account access.")), s === "reconnecting") {
            let n = this.sdk.web3modal.modal.subscribeProvider(({ status: o }) => {
              o === "connected" && (n(), e(this.formatWeb3modalGetInfoResponse())), o === "disconnected" && (n(), this.resetThirdPartyWalletState(), t("Magic RPC Error: [-32603] Internal error: User denied account access."));
            });
          }
        });
      }
      web3modalLogout() {
        return b2(async (e) => {
          try {
            await this.sdk.web3modal.modal.disconnect();
          } catch (t) {
            console.error(t);
          }
          e(true);
        });
      }
    };
    ({ createBoundEmitterMethod: we, createChainingEmitterMethod: H2 } = fe());
    Se = class extends f2 {
      isMagic = true;
      sendAsync(e, t) {
        if (!t) throw ft({ procedure: "Magic.rpcProvider.sendAsync", argument: 1, expected: "function", received: t === null ? "null" : typeof t });
        if (Array.isArray(e)) this.overlay.post(y.MAGIC_HANDLE_REQUEST, e.map((s) => {
          let n = F2(s);
          return this.prefixPayloadMethodForTestMode(n), n;
        })).then((s) => {
          t(null, s.map((n) => ({ ...n.payload, error: n.hasError ? new U2(n.payload.error) : null })));
        });
        else {
          let s = F2(e);
          this.prefixPayloadMethodForTestMode(s), this.overlay.post(y.MAGIC_HANDLE_REQUEST, s).then((n) => {
            t(n.hasError ? new U2(n.payload.error) : null, n.payload);
          });
        }
      }
      send(e, t) {
        if (typeof e == "string") {
          let n = p(e, Array.isArray(t) ? t : []);
          return this.request(n);
        }
        if (Array.isArray(e) || t) {
          this.sendAsync(e, t);
          return;
        }
        let s = gt();
        return s.log(), new K(e).applyError({ code: -32603, message: s.rawMessage }).payload;
      }
      enable() {
        let e = p(g.Login);
        return this.request(e);
      }
      request(e) {
        return this.prefixPayloadMethodForTestMode(e), super.request(e);
      }
      prefixPayloadMethodForTestMode(e) {
        let t = "testMode/eth/";
        this.sdk.testMode && (e.method = `${t}${e.method}`);
      }
      on = H2("on", this);
      once = H2("once", this);
      addListener = H2("addListener", this);
      off = H2("off", this);
      removeListener = H2("removeListener", this);
      removeAllListeners = H2("removeAllListeners", this);
      emit = we("emit");
      eventNames = we("eventNames");
      listeners = we("listeners");
      listenerCount = we("listenerCount");
    };
    Me = class extends f2 {
      purchase(e) {
        let t = p(g.NFTPurchase, [e]);
        return this.request(t);
      }
      checkout(e) {
        let t = this.sdk.thirdPartyWallets.isConnected, s = p(g.NFTCheckout, [{ ...e, walletProvider: t ? "web3modal" : "magic" }]), n = this.request(s);
        return t && (n.on(Q.Initiated, async (o) => {
          try {
            let i = await this.request({ method: "eth_sendTransaction", params: [o] });
            this.createIntermediaryEvent(Q.Success, s.id)(i);
          } catch {
            this.createIntermediaryEvent(Q.Failure, s.id)();
          }
        }), n.on(Q.Disconnect, () => {
          this.sdk.thirdPartyWallets.resetThirdPartyWalletState(), n.emit("disconnect");
        })), n;
      }
      transfer(e) {
        let t = p(g.NFTTransfer, [e]);
        return this.request(t);
      }
    };
    Ke = class r8 {
      constructor(e, t) {
        this.apiKey = e;
        if (!e) throw ut();
        m2.platform === "react-native" && t?.endpoint && yt().log();
        let { defaultEndpoint: s, version: n } = m2;
        this.testMode = !!t?.testMode, this.useStorageCache = !!t?.useStorageCache, this.endpoint = Je(t?.endpoint ?? s).origin, this.auth = new ye(this), this.user = new Te(this), this.wallet = new Ie(this), this.nft = new Me(this), this.thirdPartyWallets = new Pe(this), this.rpcProvider = new Se(this);
        let o = Sn.call(this, t);
        this.parameters = ce({ API_KEY: this.apiKey, DOMAIN_ORIGIN: typeof window < "u" && window?.location ? window?.location.origin : "", ETH_NETWORK: t?.network, host: Je(this.endpoint).host, sdk: dt[m2.sdkName], version: n, ext: ee(o) ? void 0 : o, locale: t?.locale || "en_US", authConfig: t?.authConfig ? { ...t.authConfig } : void 0, ...m2.bundleId ? { bundleId: m2.bundleId } : {}, meta: t?.meta }), this.networkHash = wn(this.apiKey, t?.network, ee(o) ? void 0 : o), t?.deferPreload || this.preload();
      }
      static __overlays__ = /* @__PURE__ */ new Map();
      endpoint;
      parameters;
      networkHash;
      testMode;
      useStorageCache;
      auth;
      user;
      wallet;
      nft;
      thirdPartyWallets;
      rpcProvider;
      get overlay() {
        if (!r8.__overlays__.has(this.parameters)) {
          let e = new m2.ViewController(this.endpoint, this.parameters, this.networkHash);
          e.init(), r8.__overlays__.set(this.parameters, e);
        }
        return r8.__overlays__.get(this.parameters);
      }
      async preload() {
        await this.overlay.waitForReady();
      }
    };
    Nn = 1e3;
    Bt = 60 * Nn;
    Vt = 5 * Bt;
    An = 60 * Bt;
    je = class {
      constructor(e, t, s) {
        this.endpoint = e;
        this.parameters = t;
        this.networkHash = s;
        this.listen();
      }
      isReadyForRequest = false;
      messageHandlers = /* @__PURE__ */ new Set();
      isConnectedToInternet = true;
      lastPongTime = null;
      heartbeatIntervalTimer = null;
      heartbeatDebounce = jt(() => {
        this.endpoint === "https://auth.magic.link/" && this.heartBeatCheck();
      }, An);
      async post(e, t) {
        return De(async (s, n) => {
          if (!this.isConnectedToInternet) {
            let l = pt();
            n(l);
          }
          await this.checkRelayerExistsInDOM() || (this.isReadyForRequest = false, await this.reloadRelayer()), this.isReadyForRequest || await this.waitForReady();
          let o = [], i = Array.isArray(t) ? t.map((l) => l.id) : [], a = await Gt(`${e}-${this.parameters}`, t, this.networkHash);
          await this._post(a);
          let c = (l) => (u2) => {
            let { id: P2, response: w2 } = Jt(t, u2);
            if (Kt(u2), w2?.payload.error?.message === "User denied account access.") Re();
            else if (u2.data.deviceShare) {
              let { deviceShare: Xt } = u2.data;
              Dt(Xt, this.networkHash);
            }
            P2 && w2 && Array.isArray(t) && i.includes(P2) ? (o.push(w2), o.length === t.length && (l(), s(o))) : P2 && w2 && !Array.isArray(t) && P2 === t.id && (l(), s(w2));
          }, d = this.on(E.MAGIC_HANDLE_RESPONSE, c(() => d()));
        });
      }
      on(e, t) {
        let s = t.bind(window), n = (o) => {
          o.data.msgType === `${e}-${this.parameters}` && s(o);
        };
        return this.messageHandlers.add(n), () => this.messageHandlers.delete(n);
      }
      waitForReady() {
        return new Promise((e) => {
          let t = this.on(E.MAGIC_OVERLAY_READY, () => {
            this.isReadyForRequest = true, e(), t();
          });
        });
      }
      listen() {
        this.on(E.MAGIC_HIDE_OVERLAY, () => {
          this.hideOverlay();
        }), this.on(E.MAGIC_SHOW_OVERLAY, () => {
          this.showOverlay();
        }), this.on(E.MAGIC_SEND_PRODUCT_ANNOUNCEMENT, (e) => {
          e.data.response.result.product_announcement && new L2(v.ProductAnnouncement, e.data.response.result.product_announcement).log();
        });
      }
      heartBeatCheck() {
        let e = true, t = async () => {
          let s = { msgType: `${y.MAGIC_PING}-${this.parameters}`, payload: [] };
          await this._post(s);
        };
        this.heartbeatIntervalTimer = setInterval(async () => {
          if (this.lastPongTime) {
            if (Date.now() - this.lastPongTime > Vt * 2) {
              this.reloadRelayer(), e = true;
              return;
            }
          } else if (!e) {
            this.reloadRelayer(), e = true;
            return;
          }
          await t(), e = false;
        }, Vt);
      }
      stopHeartBeat() {
        this.heartbeatDebounce(), this.lastPongTime = null, this.heartbeatIntervalTimer && (clearInterval(this.heartbeatIntervalTimer), this.heartbeatIntervalTimer = null);
      }
    };
    Ht = ["request", "overlay", "sdk"];
    Ve = class extends f2 {
      compat;
      __sdk_access_field_descriptors__ = /* @__PURE__ */ new Map();
      __is_initialized__ = false;
      utils = { createPromiEvent: b2, isPromiEvent: $t, encodeJSON: ce, decodeJSON: at, createJsonRpcRequestPayload: p, standardizeJsonRpcRequestPayload: F2, storage: me };
      constructor() {
        super(void 0);
        let e = [this, ...$n(this)];
        Ht.forEach((t) => {
          let s = e.map((a) => Object.getOwnPropertyDescriptor(a, t)), n = s.findIndex((a) => !!a), o = n > 0, i = s[n];
          i && (this.__sdk_access_field_descriptors__.set(t, { descriptor: i, isPrototypeField: o }), Object.defineProperty(this, t, { configurable: true, get: () => {
            throw ht(t);
          } }));
        });
      }
      init(e) {
        this.__is_initialized__ || (Ht.forEach((t) => {
          if (this.__sdk_access_field_descriptors__.has(t)) {
            let { descriptor: s, isPrototypeField: n } = this.__sdk_access_field_descriptors__.get(t);
            n ? delete this[t] : Object.defineProperty(this, t, s);
          }
        }), this.sdk = e, this.__is_initialized__ = true);
      }
      createDeprecationWarning(e) {
        let { method: t, removalVersion: s, useInstead: n } = e, o = n ? ` Use \`${n}\` instead.` : "", i = `\`${t}\` will be removed from this Extension in version \`${s}\`.${o}`;
        return new te(this, "DEPRECATION_NOTICE", i);
      }
      createWarning(e, t) {
        return new te(this, e, t);
      }
      createError(e, t, s) {
        return new de(this, e, t, s);
      }
    };
    Be = class extends Ve {
    };
    He = class {
      static Internal = Be;
    };
  }
});

// ../../node_modules/.pnpm/@magic-sdk+commons@25.4.2_@magic-sdk+provider@29.4.2_localforage@1.10.0__@magic-sdk+types@24.21.0/node_modules/@magic-sdk/commons/dist/es/index.mjs
var init_es3 = __esm({
  "../../node_modules/.pnpm/@magic-sdk+commons@25.4.2_@magic-sdk+provider@29.4.2_localforage@1.10.0__@magic-sdk+types@24.21.0/node_modules/@magic-sdk/commons/dist/es/index.mjs"() {
    "use strict";
    init_es2();
    init_es();
  }
});

// ../../node_modules/.pnpm/magic-sdk@29.4.2/node_modules/magic-sdk/dist/es/index.mjs
var es_exports = {};
__export(es_exports, {
  AuthEventOnReceived: () => k,
  DeepLinkPage: () => x,
  DeviceVerificationEventEmit: () => O,
  DeviceVerificationEventOnReceived: () => S,
  DisableMFAEventEmit: () => G,
  DisableMFAEventOnReceived: () => V,
  EnableMFAEventEmit: () => D,
  EnableMFAEventOnReceived: () => w,
  EthChainType: () => H,
  Extension: () => He,
  ExtensionError: () => de,
  ExtensionWarning: () => te,
  FarcasterLoginEventEmit: () => L,
  LocalStorageKeys: () => _,
  LoginWithEmailOTPEventEmit: () => I,
  LoginWithEmailOTPEventOnReceived: () => T,
  LoginWithMagicLinkEventEmit: () => A,
  LoginWithMagicLinkEventOnReceived: () => R,
  LoginWithSmsOTPEventEmit: () => N,
  LoginWithSmsOTPEventOnReceived: () => h,
  Magic: () => wt2,
  MagicIncomingWindowMessage: () => E,
  MagicOutgoingWindowMessage: () => y,
  MagicPayloadMethod: () => g,
  NftCheckoutIntermediaryEvents: () => Q,
  RPCError: () => U2,
  RPCErrorCode: () => u,
  RecencyCheckEventEmit: () => b,
  RecencyCheckEventOnReceived: () => C,
  RecoverAccountEventEmit: () => j,
  RecoverAccountEventOnReceived: () => P,
  RecoveryFactorEventEmit: () => Y,
  RecoveryFactorEventOnReceived: () => J,
  RecoveryMethodType: () => B,
  SDKError: () => $,
  SDKErrorCode: () => m,
  SDKWarning: () => L2,
  SDKWarningCode: () => v,
  ThirdPartyWalletEvents: () => f,
  UiEventsEmit: () => z,
  UpdateEmailEventEmit: () => F,
  UpdateEmailEventOnReceived: () => U,
  UserEventsEmit: () => q,
  UserEventsOnReceived: () => W,
  WalletEventOnReceived: () => X,
  isPromiEvent: () => $t,
  routeToMagicMethods: () => Z
});
function ft2(_2) {
  for (let [y3, O3] of Object.entries(at2)) _2.style[y3] = O3;
}
function st2(_2) {
  return !![].slice.call(document.querySelectorAll(".magic-iframe")).find((O3) => O3.src.includes(_2));
}
var $r2, Qe2, Zr2, qr2, kr2, et2, de2, Je2, rt2, $e2, qe2, er2, pe2, Te2, at2, ye2, wt2;
var init_es4 = __esm({
  "../../node_modules/.pnpm/magic-sdk@29.4.2/node_modules/magic-sdk/dist/es/index.mjs"() {
    "use strict";
    init_es2();
    init_es2();
    init_es();
    init_es3();
    $r2 = Object.create;
    Qe2 = Object.defineProperty;
    Zr2 = Object.getOwnPropertyDescriptor;
    qr2 = Object.getOwnPropertyNames;
    kr2 = Object.getPrototypeOf;
    et2 = Object.prototype.hasOwnProperty;
    de2 = ((_2) => typeof __require < "u" ? __require : typeof Proxy < "u" ? new Proxy(_2, { get: (y3, O3) => (typeof __require < "u" ? __require : y3)[O3] }) : _2)(function(_2) {
      if (typeof __require < "u") return __require.apply(this, arguments);
      throw Error('Dynamic require of "' + _2 + '" is not supported');
    });
    Je2 = (_2, y3) => () => (y3 || _2((y3 = { exports: {} }).exports, y3), y3.exports);
    rt2 = (_2, y3, O3, C2) => {
      if (y3 && typeof y3 == "object" || typeof y3 == "function") for (let W2 of qr2(y3)) !et2.call(_2, W2) && W2 !== O3 && Qe2(_2, W2, { get: () => y3[W2], enumerable: !(C2 = Zr2(y3, W2)) || C2.enumerable });
      return _2;
    };
    $e2 = (_2, y3, O3) => (O3 = _2 != null ? $r2(kr2(_2)) : {}, rt2(y3 || !_2 || !_2.__esModule ? Qe2(O3, "default", { value: _2, enumerable: true }) : O3, _2));
    qe2 = Je2((Ze2, De2) => {
      "use strict";
      (function(_2) {
        if (typeof Ze2 == "object" && typeof De2 < "u") De2.exports = _2();
        else if (typeof define == "function" && define.amd) define([], _2);
        else {
          var y3;
          typeof window < "u" ? y3 = window : typeof global < "u" ? y3 = global : typeof self < "u" ? y3 = self : y3 = this, y3.localforage = _2();
        }
      })(function() {
        var _2, y3, O3;
        return (function C2(W2, Z3, L3) {
          function V2(K2, J3) {
            if (!Z3[K2]) {
              if (!W2[K2]) {
                var m3 = typeof de2 == "function" && de2;
                if (!J3 && m3) return m3(K2, true);
                if (D2) return D2(K2, true);
                var w2 = new Error("Cannot find module '" + K2 + "'");
                throw w2.code = "MODULE_NOT_FOUND", w2;
              }
              var T3 = Z3[K2] = { exports: {} };
              W2[K2][0].call(T3.exports, function(F3) {
                var $2 = W2[K2][1][F3];
                return V2($2 || F3);
              }, T3, T3.exports, C2, W2, Z3, L3);
            }
            return Z3[K2].exports;
          }
          for (var D2 = typeof de2 == "function" && de2, z3 = 0; z3 < L3.length; z3++) V2(L3[z3]);
          return V2;
        })({ 1: [function(C2, W2, Z3) {
          (function(L3) {
            "use strict";
            var V2 = L3.MutationObserver || L3.WebKitMutationObserver, D2;
            if (V2) {
              var z3 = 0, K2 = new V2(F3), J3 = L3.document.createTextNode("");
              K2.observe(J3, { characterData: true }), D2 = function() {
                J3.data = z3 = ++z3 % 2;
              };
            } else if (!L3.setImmediate && typeof L3.MessageChannel < "u") {
              var m3 = new L3.MessageChannel();
              m3.port1.onmessage = F3, D2 = function() {
                m3.port2.postMessage(0);
              };
            } else "document" in L3 && "onreadystatechange" in L3.document.createElement("script") ? D2 = function() {
              var P2 = L3.document.createElement("script");
              P2.onreadystatechange = function() {
                F3(), P2.onreadystatechange = null, P2.parentNode.removeChild(P2), P2 = null;
              }, L3.document.documentElement.appendChild(P2);
            } : D2 = function() {
              setTimeout(F3, 0);
            };
            var w2, T3 = [];
            function F3() {
              w2 = true;
              for (var P2, k2, M2 = T3.length; M2; ) {
                for (k2 = T3, T3 = [], P2 = -1; ++P2 < M2; ) k2[P2]();
                M2 = T3.length;
              }
              w2 = false;
            }
            W2.exports = $2;
            function $2(P2) {
              T3.push(P2) === 1 && !w2 && D2();
            }
          }).call(this, typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {});
        }, {}], 2: [function(C2, W2, Z3) {
          "use strict";
          var L3 = C2(1);
          function V2() {
          }
          var D2 = {}, z3 = ["REJECTED"], K2 = ["FULFILLED"], J3 = ["PENDING"];
          W2.exports = m3;
          function m3(h3) {
            if (typeof h3 != "function") throw new TypeError("resolver must be a function");
            this.state = J3, this.queue = [], this.outcome = void 0, h3 !== V2 && $2(this, h3);
          }
          m3.prototype.catch = function(h3) {
            return this.then(null, h3);
          }, m3.prototype.then = function(h3, A3) {
            if (typeof h3 != "function" && this.state === K2 || typeof A3 != "function" && this.state === z3) return this;
            var E3 = new this.constructor(V2);
            if (this.state !== J3) {
              var N3 = this.state === K2 ? h3 : A3;
              T3(E3, N3, this.outcome);
            } else this.queue.push(new w2(E3, h3, A3));
            return E3;
          };
          function w2(h3, A3, E3) {
            this.promise = h3, typeof A3 == "function" && (this.onFulfilled = A3, this.callFulfilled = this.otherCallFulfilled), typeof E3 == "function" && (this.onRejected = E3, this.callRejected = this.otherCallRejected);
          }
          w2.prototype.callFulfilled = function(h3) {
            D2.resolve(this.promise, h3);
          }, w2.prototype.otherCallFulfilled = function(h3) {
            T3(this.promise, this.onFulfilled, h3);
          }, w2.prototype.callRejected = function(h3) {
            D2.reject(this.promise, h3);
          }, w2.prototype.otherCallRejected = function(h3) {
            T3(this.promise, this.onRejected, h3);
          };
          function T3(h3, A3, E3) {
            L3(function() {
              var N3;
              try {
                N3 = A3(E3);
              } catch (H3) {
                return D2.reject(h3, H3);
              }
              N3 === h3 ? D2.reject(h3, new TypeError("Cannot resolve promise with itself")) : D2.resolve(h3, N3);
            });
          }
          D2.resolve = function(h3, A3) {
            var E3 = P2(F3, A3);
            if (E3.status === "error") return D2.reject(h3, E3.value);
            var N3 = E3.value;
            if (N3) $2(h3, N3);
            else {
              h3.state = K2, h3.outcome = A3;
              for (var H3 = -1, j2 = h3.queue.length; ++H3 < j2; ) h3.queue[H3].callFulfilled(A3);
            }
            return h3;
          }, D2.reject = function(h3, A3) {
            h3.state = z3, h3.outcome = A3;
            for (var E3 = -1, N3 = h3.queue.length; ++E3 < N3; ) h3.queue[E3].callRejected(A3);
            return h3;
          };
          function F3(h3) {
            var A3 = h3 && h3.then;
            if (h3 && (typeof h3 == "object" || typeof h3 == "function") && typeof A3 == "function") return function() {
              A3.apply(h3, arguments);
            };
          }
          function $2(h3, A3) {
            var E3 = false;
            function N3(Q3) {
              E3 || (E3 = true, D2.reject(h3, Q3));
            }
            function H3(Q3) {
              E3 || (E3 = true, D2.resolve(h3, Q3));
            }
            function j2() {
              A3(H3, N3);
            }
            var X3 = P2(j2);
            X3.status === "error" && N3(X3.value);
          }
          function P2(h3, A3) {
            var E3 = {};
            try {
              E3.value = h3(A3), E3.status = "success";
            } catch (N3) {
              E3.status = "error", E3.value = N3;
            }
            return E3;
          }
          m3.resolve = k2;
          function k2(h3) {
            return h3 instanceof this ? h3 : D2.resolve(new this(V2), h3);
          }
          m3.reject = M2;
          function M2(h3) {
            var A3 = new this(V2);
            return D2.reject(A3, h3);
          }
          m3.all = ae2;
          function ae2(h3) {
            var A3 = this;
            if (Object.prototype.toString.call(h3) !== "[object Array]") return this.reject(new TypeError("must be an array"));
            var E3 = h3.length, N3 = false;
            if (!E3) return this.resolve([]);
            for (var H3 = new Array(E3), j2 = 0, X3 = -1, Q3 = new this(V2); ++X3 < E3; ) ee2(h3[X3], X3);
            return Q3;
            function ee2(oe2, a) {
              A3.resolve(oe2).then(u2, function(v2) {
                N3 || (N3 = true, D2.reject(Q3, v2));
              });
              function u2(v2) {
                H3[a] = v2, ++j2 === E3 && !N3 && (N3 = true, D2.resolve(Q3, H3));
              }
            }
          }
          m3.race = re2;
          function re2(h3) {
            var A3 = this;
            if (Object.prototype.toString.call(h3) !== "[object Array]") return this.reject(new TypeError("must be an array"));
            var E3 = h3.length, N3 = false;
            if (!E3) return this.resolve([]);
            for (var H3 = -1, j2 = new this(V2); ++H3 < E3; ) X3(h3[H3]);
            return j2;
            function X3(Q3) {
              A3.resolve(Q3).then(function(ee2) {
                N3 || (N3 = true, D2.resolve(j2, ee2));
              }, function(ee2) {
                N3 || (N3 = true, D2.reject(j2, ee2));
              });
            }
          }
        }, { 1: 1 }], 3: [function(C2, W2, Z3) {
          (function(L3) {
            "use strict";
            typeof L3.Promise != "function" && (L3.Promise = C2(2));
          }).call(this, typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {});
        }, { 2: 2 }], 4: [function(C2, W2, Z3) {
          "use strict";
          var L3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
            return typeof e;
          } : function(e) {
            return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
          };
          function V2(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
          }
          function D2() {
            try {
              if (typeof indexedDB < "u") return indexedDB;
              if (typeof webkitIndexedDB < "u") return webkitIndexedDB;
              if (typeof mozIndexedDB < "u") return mozIndexedDB;
              if (typeof OIndexedDB < "u") return OIndexedDB;
              if (typeof msIndexedDB < "u") return msIndexedDB;
            } catch {
              return;
            }
          }
          var z3 = D2();
          function K2() {
            try {
              if (!z3 || !z3.open) return false;
              var e = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), t = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
              return (!e || t) && typeof indexedDB < "u" && typeof IDBKeyRange < "u";
            } catch {
              return false;
            }
          }
          function J3(e, t) {
            e = e || [], t = t || {};
            try {
              return new Blob(e, t);
            } catch (n) {
              if (n.name !== "TypeError") throw n;
              for (var r10 = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, o = new r10(), i = 0; i < e.length; i += 1) o.append(e[i]);
              return o.getBlob(t.type);
            }
          }
          typeof Promise > "u" && C2(3);
          var m3 = Promise;
          function w2(e, t) {
            t && e.then(function(r10) {
              t(null, r10);
            }, function(r10) {
              t(r10);
            });
          }
          function T3(e, t, r10) {
            typeof t == "function" && e.then(t), typeof r10 == "function" && e.catch(r10);
          }
          function F3(e) {
            return typeof e != "string" && (console.warn(e + " used as a key, but it is not a string."), e = String(e)), e;
          }
          function $2() {
            if (arguments.length && typeof arguments[arguments.length - 1] == "function") return arguments[arguments.length - 1];
          }
          var P2 = "local-forage-detect-blob-support", k2 = void 0, M2 = {}, ae2 = Object.prototype.toString, re2 = "readonly", h3 = "readwrite";
          function A3(e) {
            for (var t = e.length, r10 = new ArrayBuffer(t), o = new Uint8Array(r10), i = 0; i < t; i++) o[i] = e.charCodeAt(i);
            return r10;
          }
          function E3(e) {
            return new m3(function(t) {
              var r10 = e.transaction(P2, h3), o = J3([""]);
              r10.objectStore(P2).put(o, "key"), r10.onabort = function(i) {
                i.preventDefault(), i.stopPropagation(), t(false);
              }, r10.oncomplete = function() {
                var i = navigator.userAgent.match(/Chrome\/(\d+)/), n = navigator.userAgent.match(/Edge\//);
                t(n || !i || parseInt(i[1], 10) >= 43);
              };
            }).catch(function() {
              return false;
            });
          }
          function N3(e) {
            return typeof k2 == "boolean" ? m3.resolve(k2) : E3(e).then(function(t) {
              return k2 = t, k2;
            });
          }
          function H3(e) {
            var t = M2[e.name], r10 = {};
            r10.promise = new m3(function(o, i) {
              r10.resolve = o, r10.reject = i;
            }), t.deferredOperations.push(r10), t.dbReady ? t.dbReady = t.dbReady.then(function() {
              return r10.promise;
            }) : t.dbReady = r10.promise;
          }
          function j2(e) {
            var t = M2[e.name], r10 = t.deferredOperations.pop();
            if (r10) return r10.resolve(), r10.promise;
          }
          function X3(e, t) {
            var r10 = M2[e.name], o = r10.deferredOperations.pop();
            if (o) return o.reject(t), o.promise;
          }
          function Q3(e, t) {
            return new m3(function(r10, o) {
              if (M2[e.name] = M2[e.name] || G2(), e.db) if (t) H3(e), e.db.close();
              else return r10(e.db);
              var i = [e.name];
              t && i.push(e.version);
              var n = z3.open.apply(z3, i);
              t && (n.onupgradeneeded = function(f3) {
                var s = n.result;
                try {
                  s.createObjectStore(e.storeName), f3.oldVersion <= 1 && s.createObjectStore(P2);
                } catch (c) {
                  if (c.name === "ConstraintError") console.warn('The database "' + e.name + '" has been upgraded from version ' + f3.oldVersion + " to version " + f3.newVersion + ', but the storage "' + e.storeName + '" already exists.');
                  else throw c;
                }
              }), n.onerror = function(f3) {
                f3.preventDefault(), o(n.error);
              }, n.onsuccess = function() {
                var f3 = n.result;
                f3.onversionchange = function(s) {
                  s.target.close();
                }, r10(f3), j2(e);
              };
            });
          }
          function ee2(e) {
            return Q3(e, false);
          }
          function oe2(e) {
            return Q3(e, true);
          }
          function a(e, t) {
            if (!e.db) return true;
            var r10 = !e.db.objectStoreNames.contains(e.storeName), o = e.version < e.db.version, i = e.version > e.db.version;
            if (o && (e.version !== t && console.warn('The database "' + e.name + `" can't be downgraded from version ` + e.db.version + " to version " + e.version + "."), e.version = e.db.version), i || r10) {
              if (r10) {
                var n = e.db.version + 1;
                n > e.version && (e.version = n);
              }
              return true;
            }
            return false;
          }
          function u2(e) {
            return new m3(function(t, r10) {
              var o = new FileReader();
              o.onerror = r10, o.onloadend = function(i) {
                var n = btoa(i.target.result || "");
                t({ __local_forage_encoded_blob: true, data: n, type: e.type });
              }, o.readAsBinaryString(e);
            });
          }
          function v2(e) {
            var t = A3(atob(e.data));
            return J3([t], { type: e.type });
          }
          function g2(e) {
            return e && e.__local_forage_encoded_blob;
          }
          function b3(e) {
            var t = this, r10 = t._initReady().then(function() {
              var o = M2[t._dbInfo.name];
              if (o && o.dbReady) return o.dbReady;
            });
            return T3(r10, e, e), r10;
          }
          function I2(e) {
            H3(e);
            for (var t = M2[e.name], r10 = t.forages, o = 0; o < r10.length; o++) {
              var i = r10[o];
              i._dbInfo.db && (i._dbInfo.db.close(), i._dbInfo.db = null);
            }
            return e.db = null, ee2(e).then(function(n) {
              return e.db = n, a(e) ? oe2(e) : n;
            }).then(function(n) {
              e.db = t.db = n;
              for (var f3 = 0; f3 < r10.length; f3++) r10[f3]._dbInfo.db = n;
            }).catch(function(n) {
              throw X3(e, n), n;
            });
          }
          function R3(e, t, r10, o) {
            o === void 0 && (o = 1);
            try {
              var i = e.db.transaction(e.storeName, t);
              r10(null, i);
            } catch (n) {
              if (o > 0 && (!e.db || n.name === "InvalidStateError" || n.name === "NotFoundError")) return m3.resolve().then(function() {
                if (!e.db || n.name === "NotFoundError" && !e.db.objectStoreNames.contains(e.storeName) && e.version <= e.db.version) return e.db && (e.version = e.db.version + 1), oe2(e);
              }).then(function() {
                return I2(e).then(function() {
                  R3(e, t, r10, o - 1);
                });
              }).catch(r10);
              r10(n);
            }
          }
          function G2() {
            return { forages: [], db: null, dbReady: null, deferredOperations: [] };
          }
          function fe2(e) {
            var t = this, r10 = { db: null };
            if (e) for (var o in e) r10[o] = e[o];
            var i = M2[r10.name];
            i || (i = G2(), M2[r10.name] = i), i.forages.push(t), t._initReady || (t._initReady = t.ready, t.ready = b3);
            var n = [];
            function f3() {
              return m3.resolve();
            }
            for (var s = 0; s < i.forages.length; s++) {
              var c = i.forages[s];
              c !== t && n.push(c._initReady().catch(f3));
            }
            var l = i.forages.slice(0);
            return m3.all(n).then(function() {
              return r10.db = i.db, ee2(r10);
            }).then(function(d) {
              return r10.db = d, a(r10, t._defaultConfig.version) ? oe2(r10) : d;
            }).then(function(d) {
              r10.db = i.db = d, t._dbInfo = r10;
              for (var p2 = 0; p2 < l.length; p2++) {
                var S3 = l[p2];
                S3 !== t && (S3._dbInfo.db = r10.db, S3._dbInfo.version = r10.version);
              }
            });
          }
          function ie2(e, t) {
            var r10 = this;
            e = F3(e);
            var o = new m3(function(i, n) {
              r10.ready().then(function() {
                R3(r10._dbInfo, re2, function(f3, s) {
                  if (f3) return n(f3);
                  try {
                    var c = s.objectStore(r10._dbInfo.storeName), l = c.get(e);
                    l.onsuccess = function() {
                      var d = l.result;
                      d === void 0 && (d = null), g2(d) && (d = v2(d)), i(d);
                    }, l.onerror = function() {
                      n(l.error);
                    };
                  } catch (d) {
                    n(d);
                  }
                });
              }).catch(n);
            });
            return w2(o, t), o;
          }
          function ue(e, t) {
            var r10 = this, o = new m3(function(i, n) {
              r10.ready().then(function() {
                R3(r10._dbInfo, re2, function(f3, s) {
                  if (f3) return n(f3);
                  try {
                    var c = s.objectStore(r10._dbInfo.storeName), l = c.openCursor(), d = 1;
                    l.onsuccess = function() {
                      var p2 = l.result;
                      if (p2) {
                        var S3 = p2.value;
                        g2(S3) && (S3 = v2(S3));
                        var B2 = e(S3, p2.key, d++);
                        B2 !== void 0 ? i(B2) : p2.continue();
                      } else i();
                    }, l.onerror = function() {
                      n(l.error);
                    };
                  } catch (p2) {
                    n(p2);
                  }
                });
              }).catch(n);
            });
            return w2(o, t), o;
          }
          function tr2(e, t, r10) {
            var o = this;
            e = F3(e);
            var i = new m3(function(n, f3) {
              var s;
              o.ready().then(function() {
                return s = o._dbInfo, ae2.call(t) === "[object Blob]" ? N3(s.db).then(function(c) {
                  return c ? t : u2(t);
                }) : t;
              }).then(function(c) {
                R3(o._dbInfo, h3, function(l, d) {
                  if (l) return f3(l);
                  try {
                    var p2 = d.objectStore(o._dbInfo.storeName);
                    c === null && (c = void 0);
                    var S3 = p2.put(c, e);
                    d.oncomplete = function() {
                      c === void 0 && (c = null), n(c);
                    }, d.onabort = d.onerror = function() {
                      var B2 = S3.error ? S3.error : S3.transaction.error;
                      f3(B2);
                    };
                  } catch (B2) {
                    f3(B2);
                  }
                });
              }).catch(f3);
            });
            return w2(i, r10), i;
          }
          function nr2(e, t) {
            var r10 = this;
            e = F3(e);
            var o = new m3(function(i, n) {
              r10.ready().then(function() {
                R3(r10._dbInfo, h3, function(f3, s) {
                  if (f3) return n(f3);
                  try {
                    var c = s.objectStore(r10._dbInfo.storeName), l = c.delete(e);
                    s.oncomplete = function() {
                      i();
                    }, s.onerror = function() {
                      n(l.error);
                    }, s.onabort = function() {
                      var d = l.error ? l.error : l.transaction.error;
                      n(d);
                    };
                  } catch (d) {
                    n(d);
                  }
                });
              }).catch(n);
            });
            return w2(o, t), o;
          }
          function or2(e) {
            var t = this, r10 = new m3(function(o, i) {
              t.ready().then(function() {
                R3(t._dbInfo, h3, function(n, f3) {
                  if (n) return i(n);
                  try {
                    var s = f3.objectStore(t._dbInfo.storeName), c = s.clear();
                    f3.oncomplete = function() {
                      o();
                    }, f3.onabort = f3.onerror = function() {
                      var l = c.error ? c.error : c.transaction.error;
                      i(l);
                    };
                  } catch (l) {
                    i(l);
                  }
                });
              }).catch(i);
            });
            return w2(r10, e), r10;
          }
          function ir2(e) {
            var t = this, r10 = new m3(function(o, i) {
              t.ready().then(function() {
                R3(t._dbInfo, re2, function(n, f3) {
                  if (n) return i(n);
                  try {
                    var s = f3.objectStore(t._dbInfo.storeName), c = s.count();
                    c.onsuccess = function() {
                      o(c.result);
                    }, c.onerror = function() {
                      i(c.error);
                    };
                  } catch (l) {
                    i(l);
                  }
                });
              }).catch(i);
            });
            return w2(r10, e), r10;
          }
          function ar2(e, t) {
            var r10 = this, o = new m3(function(i, n) {
              if (e < 0) {
                i(null);
                return;
              }
              r10.ready().then(function() {
                R3(r10._dbInfo, re2, function(f3, s) {
                  if (f3) return n(f3);
                  try {
                    var c = s.objectStore(r10._dbInfo.storeName), l = false, d = c.openKeyCursor();
                    d.onsuccess = function() {
                      var p2 = d.result;
                      if (!p2) {
                        i(null);
                        return;
                      }
                      e === 0 || l ? i(p2.key) : (l = true, p2.advance(e));
                    }, d.onerror = function() {
                      n(d.error);
                    };
                  } catch (p2) {
                    n(p2);
                  }
                });
              }).catch(n);
            });
            return w2(o, t), o;
          }
          function fr2(e) {
            var t = this, r10 = new m3(function(o, i) {
              t.ready().then(function() {
                R3(t._dbInfo, re2, function(n, f3) {
                  if (n) return i(n);
                  try {
                    var s = f3.objectStore(t._dbInfo.storeName), c = s.openKeyCursor(), l = [];
                    c.onsuccess = function() {
                      var d = c.result;
                      if (!d) {
                        o(l);
                        return;
                      }
                      l.push(d.key), d.continue();
                    }, c.onerror = function() {
                      i(c.error);
                    };
                  } catch (d) {
                    i(d);
                  }
                });
              }).catch(i);
            });
            return w2(r10, e), r10;
          }
          function sr2(e, t) {
            t = $2.apply(this, arguments);
            var r10 = this.config();
            e = typeof e != "function" && e || {}, e.name || (e.name = e.name || r10.name, e.storeName = e.storeName || r10.storeName);
            var o = this, i;
            if (!e.name) i = m3.reject("Invalid arguments");
            else {
              var n = e.name === r10.name && o._dbInfo.db, f3 = n ? m3.resolve(o._dbInfo.db) : ee2(e).then(function(s) {
                var c = M2[e.name], l = c.forages;
                c.db = s;
                for (var d = 0; d < l.length; d++) l[d]._dbInfo.db = s;
                return s;
              });
              e.storeName ? i = f3.then(function(s) {
                if (s.objectStoreNames.contains(e.storeName)) {
                  var c = s.version + 1;
                  H3(e);
                  var l = M2[e.name], d = l.forages;
                  s.close();
                  for (var p2 = 0; p2 < d.length; p2++) {
                    var S3 = d[p2];
                    S3._dbInfo.db = null, S3._dbInfo.version = c;
                  }
                  var B2 = new m3(function(x2, Y3) {
                    var U3 = z3.open(e.name, c);
                    U3.onerror = function(q2) {
                      var le2 = U3.result;
                      le2.close(), Y3(q2);
                    }, U3.onupgradeneeded = function() {
                      var q2 = U3.result;
                      q2.deleteObjectStore(e.storeName);
                    }, U3.onsuccess = function() {
                      var q2 = U3.result;
                      q2.close(), x2(q2);
                    };
                  });
                  return B2.then(function(x2) {
                    l.db = x2;
                    for (var Y3 = 0; Y3 < d.length; Y3++) {
                      var U3 = d[Y3];
                      U3._dbInfo.db = x2, j2(U3._dbInfo);
                    }
                  }).catch(function(x2) {
                    throw (X3(e, x2) || m3.resolve()).catch(function() {
                    }), x2;
                  });
                }
              }) : i = f3.then(function(s) {
                H3(e);
                var c = M2[e.name], l = c.forages;
                s.close();
                for (var d = 0; d < l.length; d++) {
                  var p2 = l[d];
                  p2._dbInfo.db = null;
                }
                var S3 = new m3(function(B2, x2) {
                  var Y3 = z3.deleteDatabase(e.name);
                  Y3.onerror = function() {
                    var U3 = Y3.result;
                    U3 && U3.close(), x2(Y3.error);
                  }, Y3.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + e.name + '" until all open connections are closed');
                  }, Y3.onsuccess = function() {
                    var U3 = Y3.result;
                    U3 && U3.close(), B2(U3);
                  };
                });
                return S3.then(function(B2) {
                  c.db = B2;
                  for (var x2 = 0; x2 < l.length; x2++) {
                    var Y3 = l[x2];
                    j2(Y3._dbInfo);
                  }
                }).catch(function(B2) {
                  throw (X3(e, B2) || m3.resolve()).catch(function() {
                  }), B2;
                });
              });
            }
            return w2(i, t), i;
          }
          var ur2 = { _driver: "asyncStorage", _initStorage: fe2, _support: K2(), iterate: ue, getItem: ie2, setItem: tr2, removeItem: nr2, clear: or2, length: ir2, key: ar2, keys: fr2, dropInstance: sr2 };
          function cr2() {
            return typeof openDatabase == "function";
          }
          var te2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", lr2 = "~~local_forage_type~", Be2 = /^~~local_forage_type~([^~]+)~/, ve = "__lfsc__:", ge = ve.length, be = "arbf", _e = "blob", Ne2 = "si08", xe = "ui08", Oe2 = "uic8", Ce2 = "si16", Le2 = "si32", Pe2 = "ur16", Me2 = "ui32", Fe2 = "fl32", Ue2 = "fl64", We2 = ge + be.length, ze2 = Object.prototype.toString;
          function Ye2(e) {
            var t = e.length * 0.75, r10 = e.length, o, i = 0, n, f3, s, c;
            e[e.length - 1] === "=" && (t--, e[e.length - 2] === "=" && t--);
            var l = new ArrayBuffer(t), d = new Uint8Array(l);
            for (o = 0; o < r10; o += 4) n = te2.indexOf(e[o]), f3 = te2.indexOf(e[o + 1]), s = te2.indexOf(e[o + 2]), c = te2.indexOf(e[o + 3]), d[i++] = n << 2 | f3 >> 4, d[i++] = (f3 & 15) << 4 | s >> 2, d[i++] = (s & 3) << 6 | c & 63;
            return l;
          }
          function we2(e) {
            var t = new Uint8Array(e), r10 = "", o;
            for (o = 0; o < t.length; o += 3) r10 += te2[t[o] >> 2], r10 += te2[(t[o] & 3) << 4 | t[o + 1] >> 4], r10 += te2[(t[o + 1] & 15) << 2 | t[o + 2] >> 6], r10 += te2[t[o + 2] & 63];
            return t.length % 3 === 2 ? r10 = r10.substring(0, r10.length - 1) + "=" : t.length % 3 === 1 && (r10 = r10.substring(0, r10.length - 2) + "=="), r10;
          }
          function dr2(e, t) {
            var r10 = "";
            if (e && (r10 = ze2.call(e)), e && (r10 === "[object ArrayBuffer]" || e.buffer && ze2.call(e.buffer) === "[object ArrayBuffer]")) {
              var o, i = ve;
              e instanceof ArrayBuffer ? (o = e, i += be) : (o = e.buffer, r10 === "[object Int8Array]" ? i += Ne2 : r10 === "[object Uint8Array]" ? i += xe : r10 === "[object Uint8ClampedArray]" ? i += Oe2 : r10 === "[object Int16Array]" ? i += Ce2 : r10 === "[object Uint16Array]" ? i += Pe2 : r10 === "[object Int32Array]" ? i += Le2 : r10 === "[object Uint32Array]" ? i += Me2 : r10 === "[object Float32Array]" ? i += Fe2 : r10 === "[object Float64Array]" ? i += Ue2 : t(new Error("Failed to get type for BinaryArray"))), t(i + we2(o));
            } else if (r10 === "[object Blob]") {
              var n = new FileReader();
              n.onload = function() {
                var f3 = lr2 + e.type + "~" + we2(this.result);
                t(ve + _e + f3);
              }, n.readAsArrayBuffer(e);
            } else try {
              t(JSON.stringify(e));
            } catch (f3) {
              console.error("Couldn't convert value into a JSON string: ", e), t(null, f3);
            }
          }
          function vr2(e) {
            if (e.substring(0, ge) !== ve) return JSON.parse(e);
            var t = e.substring(We2), r10 = e.substring(ge, We2), o;
            if (r10 === _e && Be2.test(t)) {
              var i = t.match(Be2);
              o = i[1], t = t.substring(i[0].length);
            }
            var n = Ye2(t);
            switch (r10) {
              case be:
                return n;
              case _e:
                return J3([n], { type: o });
              case Ne2:
                return new Int8Array(n);
              case xe:
                return new Uint8Array(n);
              case Oe2:
                return new Uint8ClampedArray(n);
              case Ce2:
                return new Int16Array(n);
              case Pe2:
                return new Uint16Array(n);
              case Le2:
                return new Int32Array(n);
              case Me2:
                return new Uint32Array(n);
              case Fe2:
                return new Float32Array(n);
              case Ue2:
                return new Float64Array(n);
              default:
                throw new Error("Unkown type: " + r10);
            }
          }
          var Ie2 = { serialize: dr2, deserialize: vr2, stringToBuffer: Ye2, bufferToString: we2 };
          function Ke2(e, t, r10, o) {
            e.executeSql("CREATE TABLE IF NOT EXISTS " + t.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], r10, o);
          }
          function hr2(e) {
            var t = this, r10 = { db: null };
            if (e) for (var o in e) r10[o] = typeof e[o] != "string" ? e[o].toString() : e[o];
            var i = new m3(function(n, f3) {
              try {
                r10.db = openDatabase(r10.name, String(r10.version), r10.description, r10.size);
              } catch (s) {
                return f3(s);
              }
              r10.db.transaction(function(s) {
                Ke2(s, r10, function() {
                  t._dbInfo = r10, n();
                }, function(c, l) {
                  f3(l);
                });
              }, f3);
            });
            return r10.serializer = Ie2, i;
          }
          function ne(e, t, r10, o, i, n) {
            e.executeSql(r10, o, i, function(f3, s) {
              s.code === s.SYNTAX_ERR ? f3.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [t.storeName], function(c, l) {
                l.rows.length ? n(c, s) : Ke2(c, t, function() {
                  c.executeSql(r10, o, i, n);
                }, n);
              }, n) : n(f3, s);
            }, n);
          }
          function mr2(e, t) {
            var r10 = this;
            e = F3(e);
            var o = new m3(function(i, n) {
              r10.ready().then(function() {
                var f3 = r10._dbInfo;
                f3.db.transaction(function(s) {
                  ne(s, f3, "SELECT * FROM " + f3.storeName + " WHERE key = ? LIMIT 1", [e], function(c, l) {
                    var d = l.rows.length ? l.rows.item(0).value : null;
                    d && (d = f3.serializer.deserialize(d)), i(d);
                  }, function(c, l) {
                    n(l);
                  });
                });
              }).catch(n);
            });
            return w2(o, t), o;
          }
          function yr2(e, t) {
            var r10 = this, o = new m3(function(i, n) {
              r10.ready().then(function() {
                var f3 = r10._dbInfo;
                f3.db.transaction(function(s) {
                  ne(s, f3, "SELECT * FROM " + f3.storeName, [], function(c, l) {
                    for (var d = l.rows, p2 = d.length, S3 = 0; S3 < p2; S3++) {
                      var B2 = d.item(S3), x2 = B2.value;
                      if (x2 && (x2 = f3.serializer.deserialize(x2)), x2 = e(x2, B2.key, S3 + 1), x2 !== void 0) {
                        i(x2);
                        return;
                      }
                    }
                    i();
                  }, function(c, l) {
                    n(l);
                  });
                });
              }).catch(n);
            });
            return w2(o, t), o;
          }
          function He2(e, t, r10, o) {
            var i = this;
            e = F3(e);
            var n = new m3(function(f3, s) {
              i.ready().then(function() {
                t === void 0 && (t = null);
                var c = t, l = i._dbInfo;
                l.serializer.serialize(t, function(d, p2) {
                  p2 ? s(p2) : l.db.transaction(function(S3) {
                    ne(S3, l, "INSERT OR REPLACE INTO " + l.storeName + " (key, value) VALUES (?, ?)", [e, d], function() {
                      f3(c);
                    }, function(B2, x2) {
                      s(x2);
                    });
                  }, function(S3) {
                    if (S3.code === S3.QUOTA_ERR) {
                      if (o > 0) {
                        f3(He2.apply(i, [e, c, r10, o - 1]));
                        return;
                      }
                      s(S3);
                    }
                  });
                });
              }).catch(s);
            });
            return w2(n, r10), n;
          }
          function pr2(e, t, r10) {
            return He2.apply(this, [e, t, r10, 1]);
          }
          function gr2(e, t) {
            var r10 = this;
            e = F3(e);
            var o = new m3(function(i, n) {
              r10.ready().then(function() {
                var f3 = r10._dbInfo;
                f3.db.transaction(function(s) {
                  ne(s, f3, "DELETE FROM " + f3.storeName + " WHERE key = ?", [e], function() {
                    i();
                  }, function(c, l) {
                    n(l);
                  });
                });
              }).catch(n);
            });
            return w2(o, t), o;
          }
          function br2(e) {
            var t = this, r10 = new m3(function(o, i) {
              t.ready().then(function() {
                var n = t._dbInfo;
                n.db.transaction(function(f3) {
                  ne(f3, n, "DELETE FROM " + n.storeName, [], function() {
                    o();
                  }, function(s, c) {
                    i(c);
                  });
                });
              }).catch(i);
            });
            return w2(r10, e), r10;
          }
          function _r2(e) {
            var t = this, r10 = new m3(function(o, i) {
              t.ready().then(function() {
                var n = t._dbInfo;
                n.db.transaction(function(f3) {
                  ne(f3, n, "SELECT COUNT(key) as c FROM " + n.storeName, [], function(s, c) {
                    var l = c.rows.item(0).c;
                    o(l);
                  }, function(s, c) {
                    i(c);
                  });
                });
              }).catch(i);
            });
            return w2(r10, e), r10;
          }
          function wr2(e, t) {
            var r10 = this, o = new m3(function(i, n) {
              r10.ready().then(function() {
                var f3 = r10._dbInfo;
                f3.db.transaction(function(s) {
                  ne(s, f3, "SELECT key FROM " + f3.storeName + " WHERE id = ? LIMIT 1", [e + 1], function(c, l) {
                    var d = l.rows.length ? l.rows.item(0).key : null;
                    i(d);
                  }, function(c, l) {
                    n(l);
                  });
                });
              }).catch(n);
            });
            return w2(o, t), o;
          }
          function Ir2(e) {
            var t = this, r10 = new m3(function(o, i) {
              t.ready().then(function() {
                var n = t._dbInfo;
                n.db.transaction(function(f3) {
                  ne(f3, n, "SELECT key FROM " + n.storeName, [], function(s, c) {
                    for (var l = [], d = 0; d < c.rows.length; d++) l.push(c.rows.item(d).key);
                    o(l);
                  }, function(s, c) {
                    i(c);
                  });
                });
              }).catch(i);
            });
            return w2(r10, e), r10;
          }
          function Er2(e) {
            return new m3(function(t, r10) {
              e.transaction(function(o) {
                o.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(i, n) {
                  for (var f3 = [], s = 0; s < n.rows.length; s++) f3.push(n.rows.item(s).name);
                  t({ db: e, storeNames: f3 });
                }, function(i, n) {
                  r10(n);
                });
              }, function(o) {
                r10(o);
              });
            });
          }
          function Sr2(e, t) {
            t = $2.apply(this, arguments);
            var r10 = this.config();
            e = typeof e != "function" && e || {}, e.name || (e.name = e.name || r10.name, e.storeName = e.storeName || r10.storeName);
            var o = this, i;
            return e.name ? i = new m3(function(n) {
              var f3;
              e.name === r10.name ? f3 = o._dbInfo.db : f3 = openDatabase(e.name, "", "", 0), e.storeName ? n({ db: f3, storeNames: [e.storeName] }) : n(Er2(f3));
            }).then(function(n) {
              return new m3(function(f3, s) {
                n.db.transaction(function(c) {
                  function l(B2) {
                    return new m3(function(x2, Y3) {
                      c.executeSql("DROP TABLE IF EXISTS " + B2, [], function() {
                        x2();
                      }, function(U3, q2) {
                        Y3(q2);
                      });
                    });
                  }
                  for (var d = [], p2 = 0, S3 = n.storeNames.length; p2 < S3; p2++) d.push(l(n.storeNames[p2]));
                  m3.all(d).then(function() {
                    f3();
                  }).catch(function(B2) {
                    s(B2);
                  });
                }, function(c) {
                  s(c);
                });
              });
            }) : i = m3.reject("Invalid arguments"), w2(i, t), i;
          }
          var Ar2 = { _driver: "webSQLStorage", _initStorage: hr2, _support: cr2(), iterate: yr2, getItem: mr2, setItem: pr2, removeItem: gr2, clear: br2, length: _r2, key: wr2, keys: Ir2, dropInstance: Sr2 };
          function Rr2() {
            try {
              return typeof localStorage < "u" && "setItem" in localStorage && !!localStorage.setItem;
            } catch {
              return false;
            }
          }
          function Ve2(e, t) {
            var r10 = e.name + "/";
            return e.storeName !== t.storeName && (r10 += e.storeName + "/"), r10;
          }
          function Dr2() {
            var e = "_localforage_support_test";
            try {
              return localStorage.setItem(e, true), localStorage.removeItem(e), false;
            } catch {
              return true;
            }
          }
          function Tr2() {
            return !Dr2() || localStorage.length > 0;
          }
          function Br2(e) {
            var t = this, r10 = {};
            if (e) for (var o in e) r10[o] = e[o];
            return r10.keyPrefix = Ve2(e, t._defaultConfig), Tr2() ? (t._dbInfo = r10, r10.serializer = Ie2, m3.resolve()) : m3.reject();
          }
          function Nr2(e) {
            var t = this, r10 = t.ready().then(function() {
              for (var o = t._dbInfo.keyPrefix, i = localStorage.length - 1; i >= 0; i--) {
                var n = localStorage.key(i);
                n.indexOf(o) === 0 && localStorage.removeItem(n);
              }
            });
            return w2(r10, e), r10;
          }
          function xr2(e, t) {
            var r10 = this;
            e = F3(e);
            var o = r10.ready().then(function() {
              var i = r10._dbInfo, n = localStorage.getItem(i.keyPrefix + e);
              return n && (n = i.serializer.deserialize(n)), n;
            });
            return w2(o, t), o;
          }
          function Or2(e, t) {
            var r10 = this, o = r10.ready().then(function() {
              for (var i = r10._dbInfo, n = i.keyPrefix, f3 = n.length, s = localStorage.length, c = 1, l = 0; l < s; l++) {
                var d = localStorage.key(l);
                if (d.indexOf(n) === 0) {
                  var p2 = localStorage.getItem(d);
                  if (p2 && (p2 = i.serializer.deserialize(p2)), p2 = e(p2, d.substring(f3), c++), p2 !== void 0) return p2;
                }
              }
            });
            return w2(o, t), o;
          }
          function Cr2(e, t) {
            var r10 = this, o = r10.ready().then(function() {
              var i = r10._dbInfo, n;
              try {
                n = localStorage.key(e);
              } catch {
                n = null;
              }
              return n && (n = n.substring(i.keyPrefix.length)), n;
            });
            return w2(o, t), o;
          }
          function Lr2(e) {
            var t = this, r10 = t.ready().then(function() {
              for (var o = t._dbInfo, i = localStorage.length, n = [], f3 = 0; f3 < i; f3++) {
                var s = localStorage.key(f3);
                s.indexOf(o.keyPrefix) === 0 && n.push(s.substring(o.keyPrefix.length));
              }
              return n;
            });
            return w2(r10, e), r10;
          }
          function Pr2(e) {
            var t = this, r10 = t.keys().then(function(o) {
              return o.length;
            });
            return w2(r10, e), r10;
          }
          function Mr2(e, t) {
            var r10 = this;
            e = F3(e);
            var o = r10.ready().then(function() {
              var i = r10._dbInfo;
              localStorage.removeItem(i.keyPrefix + e);
            });
            return w2(o, t), o;
          }
          function Fr2(e, t, r10) {
            var o = this;
            e = F3(e);
            var i = o.ready().then(function() {
              t === void 0 && (t = null);
              var n = t;
              return new m3(function(f3, s) {
                var c = o._dbInfo;
                c.serializer.serialize(t, function(l, d) {
                  if (d) s(d);
                  else try {
                    localStorage.setItem(c.keyPrefix + e, l), f3(n);
                  } catch (p2) {
                    (p2.name === "QuotaExceededError" || p2.name === "NS_ERROR_DOM_QUOTA_REACHED") && s(p2), s(p2);
                  }
                });
              });
            });
            return w2(i, r10), i;
          }
          function Ur2(e, t) {
            if (t = $2.apply(this, arguments), e = typeof e != "function" && e || {}, !e.name) {
              var r10 = this.config();
              e.name = e.name || r10.name, e.storeName = e.storeName || r10.storeName;
            }
            var o = this, i;
            return e.name ? i = new m3(function(n) {
              e.storeName ? n(Ve2(e, o._defaultConfig)) : n(e.name + "/");
            }).then(function(n) {
              for (var f3 = localStorage.length - 1; f3 >= 0; f3--) {
                var s = localStorage.key(f3);
                s.indexOf(n) === 0 && localStorage.removeItem(s);
              }
            }) : i = m3.reject("Invalid arguments"), w2(i, t), i;
          }
          var Wr2 = { _driver: "localStorageWrapper", _initStorage: Br2, _support: Rr2(), iterate: Or2, getItem: xr2, setItem: Fr2, removeItem: Mr2, clear: Nr2, length: Pr2, key: Cr2, keys: Lr2, dropInstance: Ur2 }, zr2 = function(t, r10) {
            return t === r10 || typeof t == "number" && typeof r10 == "number" && isNaN(t) && isNaN(r10);
          }, Yr2 = function(t, r10) {
            for (var o = t.length, i = 0; i < o; ) {
              if (zr2(t[i], r10)) return true;
              i++;
            }
            return false;
          }, Ge = Array.isArray || function(e) {
            return Object.prototype.toString.call(e) === "[object Array]";
          }, ce2 = {}, je2 = {}, se = { INDEXEDDB: ur2, WEBSQL: Ar2, LOCALSTORAGE: Wr2 }, Kr2 = [se.INDEXEDDB._driver, se.WEBSQL._driver, se.LOCALSTORAGE._driver], he2 = ["dropInstance"], Ee = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(he2), Hr2 = { description: "", driver: Kr2.slice(), name: "localforage", size: 4980736, storeName: "keyvaluepairs", version: 1 };
          function Vr(e, t) {
            e[t] = function() {
              var r10 = arguments;
              return e.ready().then(function() {
                return e[t].apply(e, r10);
              });
            };
          }
          function Se2() {
            for (var e = 1; e < arguments.length; e++) {
              var t = arguments[e];
              if (t) for (var r10 in t) t.hasOwnProperty(r10) && (Ge(t[r10]) ? arguments[0][r10] = t[r10].slice() : arguments[0][r10] = t[r10]);
            }
            return arguments[0];
          }
          var Gr2 = (function() {
            function e(t) {
              V2(this, e);
              for (var r10 in se) if (se.hasOwnProperty(r10)) {
                var o = se[r10], i = o._driver;
                this[r10] = i, ce2[i] || this.defineDriver(o);
              }
              this._defaultConfig = Se2({}, Hr2), this._config = Se2({}, this._defaultConfig, t), this._driverSet = null, this._initDriver = null, this._ready = false, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
              });
            }
            return e.prototype.config = function(r10) {
              if ((typeof r10 > "u" ? "undefined" : L3(r10)) === "object") {
                if (this._ready) return new Error("Can't call config() after localforage has been used.");
                for (var o in r10) {
                  if (o === "storeName" && (r10[o] = r10[o].replace(/\W/g, "_")), o === "version" && typeof r10[o] != "number") return new Error("Database version must be a number.");
                  this._config[o] = r10[o];
                }
                return "driver" in r10 && r10.driver ? this.setDriver(this._config.driver) : true;
              } else return typeof r10 == "string" ? this._config[r10] : this._config;
            }, e.prototype.defineDriver = function(r10, o, i) {
              var n = new m3(function(f3, s) {
                try {
                  var c = r10._driver, l = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                  if (!r10._driver) {
                    s(l);
                    return;
                  }
                  for (var d = Ee.concat("_initStorage"), p2 = 0, S3 = d.length; p2 < S3; p2++) {
                    var B2 = d[p2], x2 = !Yr2(he2, B2);
                    if ((x2 || r10[B2]) && typeof r10[B2] != "function") {
                      s(l);
                      return;
                    }
                  }
                  var Y3 = function() {
                    for (var le2 = function(Qr2) {
                      return function() {
                        var Jr2 = new Error("Method " + Qr2 + " is not implemented by the current driver"), Xe2 = m3.reject(Jr2);
                        return w2(Xe2, arguments[arguments.length - 1]), Xe2;
                      };
                    }, Ae2 = 0, Xr = he2.length; Ae2 < Xr; Ae2++) {
                      var Re2 = he2[Ae2];
                      r10[Re2] || (r10[Re2] = le2(Re2));
                    }
                  };
                  Y3();
                  var U3 = function(le2) {
                    ce2[c] && console.info("Redefining LocalForage driver: " + c), ce2[c] = r10, je2[c] = le2, f3();
                  };
                  "_support" in r10 ? r10._support && typeof r10._support == "function" ? r10._support().then(U3, s) : U3(!!r10._support) : U3(true);
                } catch (q2) {
                  s(q2);
                }
              });
              return T3(n, o, i), n;
            }, e.prototype.driver = function() {
              return this._driver || null;
            }, e.prototype.getDriver = function(r10, o, i) {
              var n = ce2[r10] ? m3.resolve(ce2[r10]) : m3.reject(new Error("Driver not found."));
              return T3(n, o, i), n;
            }, e.prototype.getSerializer = function(r10) {
              var o = m3.resolve(Ie2);
              return T3(o, r10), o;
            }, e.prototype.ready = function(r10) {
              var o = this, i = o._driverSet.then(function() {
                return o._ready === null && (o._ready = o._initDriver()), o._ready;
              });
              return T3(i, r10, r10), i;
            }, e.prototype.setDriver = function(r10, o, i) {
              var n = this;
              Ge(r10) || (r10 = [r10]);
              var f3 = this._getSupportedDrivers(r10);
              function s() {
                n._config.driver = n.driver();
              }
              function c(p2) {
                return n._extend(p2), s(), n._ready = n._initStorage(n._config), n._ready;
              }
              function l(p2) {
                return function() {
                  var S3 = 0;
                  function B2() {
                    for (; S3 < p2.length; ) {
                      var x2 = p2[S3];
                      return S3++, n._dbInfo = null, n._ready = null, n.getDriver(x2).then(c).catch(B2);
                    }
                    s();
                    var Y3 = new Error("No available storage method found.");
                    return n._driverSet = m3.reject(Y3), n._driverSet;
                  }
                  return B2();
                };
              }
              var d = this._driverSet !== null ? this._driverSet.catch(function() {
                return m3.resolve();
              }) : m3.resolve();
              return this._driverSet = d.then(function() {
                var p2 = f3[0];
                return n._dbInfo = null, n._ready = null, n.getDriver(p2).then(function(S3) {
                  n._driver = S3._driver, s(), n._wrapLibraryMethodsWithReady(), n._initDriver = l(f3);
                });
              }).catch(function() {
                s();
                var p2 = new Error("No available storage method found.");
                return n._driverSet = m3.reject(p2), n._driverSet;
              }), T3(this._driverSet, o, i), this._driverSet;
            }, e.prototype.supports = function(r10) {
              return !!je2[r10];
            }, e.prototype._extend = function(r10) {
              Se2(this, r10);
            }, e.prototype._getSupportedDrivers = function(r10) {
              for (var o = [], i = 0, n = r10.length; i < n; i++) {
                var f3 = r10[i];
                this.supports(f3) && o.push(f3);
              }
              return o;
            }, e.prototype._wrapLibraryMethodsWithReady = function() {
              for (var r10 = 0, o = Ee.length; r10 < o; r10++) Vr(this, Ee[r10]);
            }, e.prototype.createInstance = function(r10) {
              return new e(r10);
            }, e;
          })(), jr = new Gr2();
          W2.exports = jr;
        }, { 3: 3 }] }, {}, [4])(4);
      });
    });
    er2 = Je2((me2, ke2) => {
      "use strict";
      (function(_2, y3) {
        typeof me2 == "object" && typeof ke2 < "u" ? y3(me2) : typeof define == "function" && define.amd ? define("localforage-driver-memory", ["exports"], y3) : y3(_2.LocalforageDriverMemory = {});
      })(typeof self < "u" ? self : me2, function(_2) {
        "use strict";
        var y3 = "localforage-driver-memory";
        function O3(a) {
          var u2 = typeof Symbol == "function" && a[Symbol.iterator], v2 = 0;
          return u2 ? u2.call(a) : { next: function() {
            return a && v2 >= a.length && (a = void 0), { value: a && a[v2++], done: !a };
          } };
        }
        function C2(a, u2) {
          a = a || [], u2 = u2 || {};
          try {
            return new Blob(a, u2);
          } catch (I2) {
            if (I2.name !== "TypeError") throw I2;
            for (var v2 = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, g2 = new v2(), b3 = 0; b3 < a.length; b3 += 1) g2.append(a[b3]);
            return g2.getBlob(u2.type);
          }
        }
        var W2 = /^~~local_forage_type~([^~]+)~/, Z3 = 9, L3 = Z3 + 4, V2 = Object.prototype.toString;
        function D2(a) {
          var u2 = a.length * 0.75, v2 = a.length;
          a[a.length - 1] === "=" && (u2--, a[a.length - 2] === "=" && u2--);
          for (var g2 = new ArrayBuffer(u2), b3 = new Uint8Array(g2), I2 = 0, R3 = 0; I2 < v2; I2 += 4) {
            var G2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a[I2]), fe2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a[I2 + 1]), ie2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a[I2 + 2]), ue = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(a[I2 + 3]);
            b3[R3++] = G2 << 2 | fe2 >> 4, b3[R3++] = (fe2 & 15) << 4 | ie2 >> 2, b3[R3++] = (ie2 & 3) << 6 | ue & 63;
          }
          return g2;
        }
        function z3(a) {
          for (var u2 = new Uint8Array(a), v2 = "", g2 = 0; g2 < u2.length; g2 += 3) v2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[u2[g2] >> 2], v2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(u2[g2] & 3) << 4 | u2[g2 + 1] >> 4], v2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(u2[g2 + 1] & 15) << 2 | u2[g2 + 2] >> 6], v2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[u2[g2 + 2] & 63];
          return u2.length % 3 === 2 ? v2 = v2.substring(0, v2.length - 1) + "=" : u2.length % 3 === 1 && (v2 = v2.substring(0, v2.length - 2) + "=="), v2;
        }
        function K2(a, u2) {
          var v2 = "";
          if (a && (v2 = V2.call(a)), a && (v2 === "[object ArrayBuffer]" || a.buffer && V2.call(a.buffer) === "[object ArrayBuffer]")) {
            var g2 = void 0, b3 = "__lfsc__:";
            a instanceof ArrayBuffer ? (g2 = a, b3 += "arbf") : (g2 = a.buffer, v2 === "[object Int8Array]" ? b3 += "si08" : v2 === "[object Uint8Array]" ? b3 += "ui08" : v2 === "[object Uint8ClampedArray]" ? b3 += "uic8" : v2 === "[object Int16Array]" ? b3 += "si16" : v2 === "[object Uint16Array]" ? b3 += "ur16" : v2 === "[object Int32Array]" ? b3 += "si32" : v2 === "[object Uint32Array]" ? b3 += "ui32" : v2 === "[object Float32Array]" ? b3 += "fl32" : v2 === "[object Float64Array]" ? b3 += "fl64" : u2(new Error("Failed to get type for BinaryArray"))), u2(b3 + z3(g2));
          } else if (v2 === "[object Blob]") {
            var I2 = new FileReader();
            I2.onload = function() {
              var R3 = "~~local_forage_type~" + a.type + "~" + z3(this.result);
              u2("__lfsc__:blob" + R3);
            }, I2.readAsArrayBuffer(a);
          } else try {
            u2(JSON.stringify(a));
          } catch (R3) {
            console.error("Couldn't convert value into a JSON string: ", a), u2(null, R3);
          }
        }
        function J3(a) {
          if (a.substring(0, Z3) !== "__lfsc__:") return JSON.parse(a);
          var u2 = a.substring(L3), v2 = a.substring(Z3, L3), g2;
          if (v2 === "blob" && W2.test(u2)) {
            var b3 = u2.match(W2);
            g2 = b3[1], u2 = u2.substring(b3[0].length);
          }
          var I2 = D2(u2);
          switch (v2) {
            case "arbf":
              return I2;
            case "blob":
              return C2([I2], { type: g2 });
            case "si08":
              return new Int8Array(I2);
            case "ui08":
              return new Uint8Array(I2);
            case "uic8":
              return new Uint8ClampedArray(I2);
            case "si16":
              return new Int16Array(I2);
            case "ur16":
              return new Uint16Array(I2);
            case "si32":
              return new Int32Array(I2);
            case "ui32":
              return new Uint32Array(I2);
            case "fl32":
              return new Float32Array(I2);
            case "fl64":
              return new Float64Array(I2);
            default:
              throw new Error("Unkown type: " + v2);
          }
        }
        function m3(a) {
          var u2, v2;
          if (a === null || typeof a != "object" || "isActiveClone" in a) return a;
          var g2 = a instanceof Date ? new Date(a) : a.constructor();
          try {
            for (var b3 = O3(Object.keys(a)), I2 = b3.next(); !I2.done; I2 = b3.next()) {
              var R3 = I2.value;
              Object.prototype.hasOwnProperty.call(a, R3) && (a.isActiveClone = null, g2[R3] = m3(a[R3]), delete a.isActiveClone);
            }
          } catch (G2) {
            u2 = { error: G2 };
          } finally {
            try {
              I2 && !I2.done && (v2 = b3.return) && v2.call(b3);
            } finally {
              if (u2) throw u2.error;
            }
          }
          return g2;
        }
        function w2(a, u2) {
          return (a.name || u2.name) + "/" + (a.storeName || u2.storeName) + "/";
        }
        function T3(a, u2) {
          u2 && a.then(function(v2) {
            u2(null, v2);
          }, function(v2) {
            u2(v2);
          });
        }
        function F3() {
          for (var a = [], u2 = 0; u2 < arguments.length; u2++) a[u2] = arguments[u2];
          if (arguments.length && typeof arguments[arguments.length - 1] == "function") return arguments[arguments.length - 1];
        }
        function $2(a, u2) {
          var v2 = this;
          if (u2 = F3.apply(this, arguments), a = typeof a != "function" && a || {}, !a.name) {
            var g2 = this.config();
            a.name = a.name || g2.name, a.storeName = a.storeName || g2.storeName;
          }
          var b3;
          return a.name ? b3 = new Promise(function(I2) {
            a.storeName ? I2(w2(a, v2._defaultConfig)) : I2(a.name + "/");
          }) : b3 = Promise.reject("Invalid arguments"), { promise: b3, callback: u2 };
        }
        function P2(a) {
          return typeof a != "string" && (console.warn(a + " used as a key, but it is not a string."), a = String(a)), a;
        }
        var k2 = { bufferToString: z3, deserialize: J3, serialize: K2, stringToBuffer: D2 }, M2 = {}, ae2 = (function() {
          function a(u2) {
            this.kp = u2, this.data = {};
          }
          return a.resolve = function(u2) {
            return M2[u2] || (M2[u2] = new a(u2)), M2[u2];
          }, a.prototype.clear = function() {
            this.data = {};
          }, a.prototype.drop = function() {
            this.clear(), delete M2[this.kp];
          }, a.prototype.get = function(u2) {
            return this.data[u2];
          }, a.prototype.key = function(u2) {
            return this.keys()[u2];
          }, a.prototype.keys = function() {
            return Object.keys(this.data);
          }, a.prototype.rm = function(u2) {
            delete this.data[u2];
          }, a.prototype.set = function(u2, v2) {
            this.data[u2] = v2;
          }, a;
        })();
        function re2(a) {
          var u2 = a ? m3(a) : {}, v2 = w2(u2, this._defaultConfig), g2 = ae2.resolve(v2);
          return this._dbInfo = u2, this._dbInfo.serializer = k2, this._dbInfo.keyPrefix = v2, this._dbInfo.mStore = g2, Promise.resolve();
        }
        function h3(a) {
          var u2 = this, v2 = this.ready().then(function() {
            u2._dbInfo.mStore.clear();
          });
          return T3(v2, a), v2;
        }
        function A3(a, u2) {
          var v2 = $2.apply(this, arguments), g2 = v2.promise, b3 = v2.callback, I2 = g2.then(function(R3) {
            ae2.resolve(R3).drop();
          });
          return T3(I2, b3), g2;
        }
        function E3(a, u2) {
          var v2 = this;
          a = P2(a);
          var g2 = this.ready().then(function() {
            var b3 = v2._dbInfo.mStore.get(a);
            return b3 == null ? null : v2._dbInfo.serializer.deserialize(b3);
          });
          return T3(g2, u2), g2;
        }
        function N3(a, u2) {
          var v2 = this, g2 = this.ready().then(function() {
            for (var b3 = v2._dbInfo.mStore, I2 = b3.keys(), R3 = 0; R3 < I2.length; R3++) {
              var G2 = b3.get(I2[R3]);
              if (G2 && (G2 = v2._dbInfo.serializer.deserialize(G2)), G2 = a(G2, I2[R3], R3 + 1), G2 !== void 0) return G2;
            }
          });
          return T3(g2, u2), g2;
        }
        function H3(a, u2) {
          var v2 = this, g2 = this.ready().then(function() {
            var b3;
            try {
              b3 = v2._dbInfo.mStore.key(a), b3 === void 0 && (b3 = null);
            } catch {
              b3 = null;
            }
            return b3;
          });
          return T3(g2, u2), g2;
        }
        function j2(a) {
          var u2 = this, v2 = this.ready().then(function() {
            return u2._dbInfo.mStore.keys();
          });
          return T3(v2, a), v2;
        }
        function X3(a) {
          var u2 = this.keys().then(function(v2) {
            return v2.length;
          });
          return T3(u2, a), u2;
        }
        function Q3(a, u2) {
          var v2 = this;
          a = P2(a);
          var g2 = this.ready().then(function() {
            v2._dbInfo.mStore.rm(a);
          });
          return T3(g2, u2), g2;
        }
        function ee2(a, u2, v2) {
          var g2 = this;
          a = P2(a);
          var b3 = this.ready().then(function() {
            u2 === void 0 && (u2 = null);
            var I2 = u2;
            return new Promise(function(R3, G2) {
              g2._dbInfo.serializer.serialize(u2, function(fe2, ie2) {
                if (ie2) G2(ie2);
                else try {
                  g2._dbInfo.mStore.set(a, fe2), R3(I2);
                } catch (ue) {
                  G2(ue);
                }
              });
            });
          });
          return T3(b3, v2), b3;
        }
        var oe2 = true;
        _2._support = oe2, _2._driver = y3, _2._initStorage = re2, _2.clear = h3, _2.dropInstance = A3, _2.getItem = E3, _2.iterate = N3, _2.key = H3, _2.keys = j2, _2.length = X3, _2.removeItem = Q3, _2.setItem = ee2, Object.defineProperty(_2, "__esModule", { value: true });
      });
    });
    pe2 = $e2(qe2());
    Te2 = $e2(er2());
    at2 = { display: "none", position: "fixed", top: "0", right: "0", width: "100%", height: "100%", borderRadius: "0", border: "none", opacity: "0", zIndex: "-1" };
    ye2 = class extends je {
      activeElement = null;
      iframe;
      relayerSrc = Je(`/send?params=${encodeURIComponent(this.parameters)}`, this.endpoint).href;
      init() {
        this.test = "hello", this.iframe = new Promise((y3) => {
          let O3 = () => {
            if (st2(encodeURIComponent(this.parameters))) Bn().log();
            else {
              let C2 = document.createElement("iframe");
              C2.classList.add("magic-iframe"), C2.dataset.magicIframeLabel = Je(this.endpoint).host, C2.title = "Secure Modal", C2.src = this.relayerSrc, C2.allow = "clipboard-read; clipboard-write", ft2(C2), document.body.appendChild(C2), y3(C2);
            }
          };
          ["loaded", "interactive", "complete"].includes(document.readyState) ? O3() : window.addEventListener("load", O3, false);
        }), this.iframe.then((y3) => {
          y3 instanceof HTMLIFrameElement && y3.addEventListener("load", async () => {
            this.heartbeatDebounce();
          });
        }), window.addEventListener("message", (y3) => {
          if (y3.origin === this.endpoint && y3.data.msgType && (y3.data.msgType.includes(E.MAGIC_PONG) && (this.lastPongTime = Date.now()), y3.data && this.messageHandlers.size)) {
            y3.data.response = y3.data.response ?? {}, this.stopHeartBeat();
            for (let O3 of this.messageHandlers.values()) O3(y3);
          }
        }), window.addEventListener("beforeunload", () => {
          this.stopHeartBeat();
        });
      }
      async showOverlay() {
        let y3 = await this.iframe;
        y3.style.display = "block", y3.style.zIndex = "2147483647", y3.style.opacity = "1", this.activeElement = document.activeElement, y3.focus();
      }
      async hideOverlay() {
        let y3 = await this.iframe;
        y3.style.display = "none", y3.style.zIndex = "-1", y3.style.opacity = "0", this.activeElement?.focus && this.activeElement.focus(), this.activeElement = null;
      }
      async _post(y3) {
        let O3 = await this.iframe;
        if (O3 && O3.contentWindow) O3.contentWindow.postMessage(y3, this.endpoint);
        else throw pt();
      }
      async checkRelayerExistsInDOM() {
        let y3 = await this.iframe;
        return !y3 || !y3.contentWindow ? false : !![].slice.call(document.querySelectorAll(".magic-iframe")).find((C2) => C2.src.includes(encodeURIComponent(this.parameters)));
      }
      async reloadRelayer() {
        let y3 = await this.iframe;
        if (this.stopHeartBeat(), !y3) {
          this.init(), console.warn("Magic SDK: Modal lost, re-initiating");
          return;
        }
        if (!y3.contentWindow) {
          document.body.appendChild(y3), console.warn("Magic SDK: Modal did not append in the iframe, re-initiating");
          return;
        }
        y3 && (y3.src = this.relayerSrc);
      }
    };
    wt2 = Hr(Ke, { platform: "web", sdkName: "magic-sdk", version: "29.4.2", defaultEndpoint: "https://auth.magic.link/", ViewController: ye2, configureStorage: async () => {
      let _2 = pe2.default.createInstance({ name: "MagicAuthLocalStorageDB", storeName: "MagicAuthLocalStorage" });
      return await _2.defineDriver(Te2), await _2.setDriver([pe2.default.INDEXEDDB, pe2.default.LOCALSTORAGE, Te2._driver]), _2;
    } });
  }
});

// ../../node_modules/.pnpm/@magic-ext+algorand@24.4.2/node_modules/@magic-ext/algorand/dist/es/index.mjs
var es_exports2 = {};
__export(es_exports2, {
  AlgorandExtension: () => r9
});
var r9;
var init_es5 = __esm({
  "../../node_modules/.pnpm/@magic-ext+algorand@24.4.2/node_modules/@magic-ext/algorand/dist/es/index.mjs"() {
    "use strict";
    init_es3();
    r9 = class extends He.Internal {
      constructor(n) {
        super();
        this.algorandConfig = n;
        this.config = { rpcUrl: n.rpcUrl, chainType: "ALGOD" };
      }
      name = "algod";
      config = {};
      async signTransaction(n) {
        return this.request(this.utils.createJsonRpcRequestPayload("algod_signTransaction", n));
      }
      async signBid(n) {
        return this.request(this.utils.createJsonRpcRequestPayload("algod_signBid", n));
      }
      async getWallet() {
        return this.request(this.utils.createJsonRpcRequestPayload("algod_getWallet", []));
      }
      async signGroupTransaction(n) {
        return this.request(this.utils.createJsonRpcRequestPayload("algod_signGroupTransaction", n));
      }
      async signGroupTransactionV2(n) {
        return this.request(this.utils.createJsonRpcRequestPayload("algod_signGroupTransactionV2", n));
      }
    };
  }
});

// src/logger.ts
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["INFO"] = 1] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 2] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 3] = "ERROR";
  return LogLevel2;
})(LogLevel || {});
var Logger = class _Logger {
  static instance = null;
  level;
  isClient;
  constructor() {
    this.level = 2 /* WARN */;
    this.isClient = typeof window !== "undefined";
  }
  static getInstance() {
    if (!_Logger.instance) {
      _Logger.instance = new _Logger();
    }
    return _Logger.instance;
  }
  static setLevel(level) {
    _Logger.getInstance().level = level;
  }
  log(level, scope, message, ...args) {
    if (level >= this.level && this.isClient) {
      const formattedMessage = scope ? `[${scope}] ${message}` : message;
      switch (level) {
        case 0 /* DEBUG */:
        case 1 /* INFO */:
          console.info(formattedMessage, ...args);
          break;
        case 2 /* WARN */:
          console.warn(formattedMessage, ...args);
          break;
        case 3 /* ERROR */:
          console.error(formattedMessage, ...args);
          break;
      }
    }
  }
  createScopedLogger(scope) {
    return {
      debug: (message, ...args) => this.log(0 /* DEBUG */, scope, message, ...args),
      info: (message, ...args) => this.log(1 /* INFO */, scope, message, ...args),
      warn: (message, ...args) => this.log(2 /* WARN */, scope, message, ...args),
      error: (message, ...args) => this.log(3 /* ERROR */, scope, message, ...args)
    };
  }
  debug(message, ...args) {
    this.log(0 /* DEBUG */, void 0, message, ...args);
  }
  info(message, ...args) {
    this.log(1 /* INFO */, void 0, message, ...args);
  }
  warn(message, ...args) {
    this.log(2 /* WARN */, void 0, message, ...args);
  }
  error(message, ...args) {
    this.log(3 /* ERROR */, void 0, message, ...args);
  }
  // For testing purposes
  setIsClient(isClient) {
    this.isClient = isClient;
  }
};
var logger = Logger.getInstance();

// src/manager.ts
import { Store } from "@tanstack/store";
import algosdk13 from "algosdk";

// src/network.ts
var DEFAULT_NETWORK_CONFIG = {
  mainnet: {
    algod: {
      token: "",
      baseServer: "https://mainnet-api.4160.nodely.dev",
      headers: {}
    },
    isTestnet: false,
    genesisHash: "wGHE2Pwdvd7S12BL5FaOP20EGYesN73ktiC1qzkkit8=",
    genesisId: "mainnet-v1.0",
    caipChainId: "algorand:wGHE2Pwdvd7S12BL5FaOP20EGYesN73k"
  },
  testnet: {
    algod: {
      token: "",
      baseServer: "https://testnet-api.4160.nodely.dev",
      headers: {}
    },
    isTestnet: true,
    genesisHash: "SGO1GKSzyE7IEPItTxCByw9x8FmnrCDexi9/cOUJOiI=",
    genesisId: "testnet-v1.0",
    caipChainId: "algorand:SGO1GKSzyE7IEPItTxCByw9x8FmnrCDe"
  },
  betanet: {
    algod: {
      token: "",
      baseServer: "https://betanet-api.4160.nodely.dev",
      headers: {}
    },
    isTestnet: true,
    genesisHash: "mFgazF-2uRS1tMiL9dsj01hJGySEmPN2OvOTQHJ6iQg=",
    genesisId: "betanet-v1.0",
    caipChainId: "algorand:mFgazF-2uRS1tMiL9dsj01hJGySEmPN2"
  },
  fnet: {
    algod: {
      token: "",
      baseServer: "https://fnet-api.4160.nodely.dev",
      headers: {}
    },
    isTestnet: true,
    genesisHash: "kUt08LxeVAAGHnh4JoAoAMM9ql_hBwSoRrQQKWSVgxk=",
    genesisId: "fnet-v1",
    caipChainId: "algorand:kUt08LxeVAAGHnh4JoAoAMM9ql_hBwSo"
  },
  localnet: {
    algod: {
      token: "a".repeat(64),
      baseServer: "http://localhost",
      port: 4001,
      headers: {}
    },
    isTestnet: true
  }
};
var NetworkConfigBuilder = class {
  networks;
  constructor() {
    this.networks = new Map(Object.entries(DEFAULT_NETWORK_CONFIG));
  }
  // Methods to customize default networks
  mainnet(config) {
    this.networks.set("mainnet", {
      ...DEFAULT_NETWORK_CONFIG.mainnet,
      ...config,
      genesisHash: DEFAULT_NETWORK_CONFIG.mainnet.genesisHash,
      genesisId: DEFAULT_NETWORK_CONFIG.mainnet.genesisId,
      caipChainId: DEFAULT_NETWORK_CONFIG.mainnet.caipChainId,
      algod: {
        ...DEFAULT_NETWORK_CONFIG.mainnet.algod,
        ...config.algod || {}
      }
    });
    return this;
  }
  testnet(config) {
    this.networks.set("testnet", {
      ...DEFAULT_NETWORK_CONFIG.testnet,
      ...config,
      genesisHash: DEFAULT_NETWORK_CONFIG.testnet.genesisHash,
      genesisId: DEFAULT_NETWORK_CONFIG.testnet.genesisId,
      caipChainId: DEFAULT_NETWORK_CONFIG.testnet.caipChainId,
      algod: {
        ...DEFAULT_NETWORK_CONFIG.testnet.algod,
        ...config.algod || {}
      }
    });
    return this;
  }
  betanet(config) {
    this.networks.set("betanet", {
      ...DEFAULT_NETWORK_CONFIG.betanet,
      ...config,
      genesisHash: DEFAULT_NETWORK_CONFIG.betanet.genesisHash,
      genesisId: DEFAULT_NETWORK_CONFIG.betanet.genesisId,
      caipChainId: DEFAULT_NETWORK_CONFIG.betanet.caipChainId,
      algod: {
        ...DEFAULT_NETWORK_CONFIG.betanet.algod,
        ...config.algod || {}
      }
    });
    return this;
  }
  fnet(config) {
    this.networks.set("fnet", {
      ...DEFAULT_NETWORK_CONFIG.fnet,
      ...config,
      genesisHash: DEFAULT_NETWORK_CONFIG.fnet.genesisHash,
      genesisId: DEFAULT_NETWORK_CONFIG.fnet.genesisId,
      caipChainId: DEFAULT_NETWORK_CONFIG.fnet.caipChainId,
      algod: {
        ...DEFAULT_NETWORK_CONFIG.fnet.algod,
        ...config.algod || {}
      }
    });
    return this;
  }
  localnet(config) {
    this.networks.set("localnet", {
      ...DEFAULT_NETWORK_CONFIG.localnet,
      ...config,
      algod: {
        ...DEFAULT_NETWORK_CONFIG.localnet.algod,
        ...config.algod || {}
      }
    });
    return this;
  }
  // Method to add custom networks (still needs full NetworkConfig)
  addNetwork(id, config) {
    if (DEFAULT_NETWORK_CONFIG[id]) {
      throw new Error(
        `Cannot add network with reserved id "${id}". Use the ${id}() method instead.`
      );
    }
    this.networks.set(id, config);
    return this;
  }
  build() {
    return Object.fromEntries(this.networks);
  }
};
var createNetworkConfig = () => new NetworkConfigBuilder().build();
function isValidToken(token) {
  if (typeof token === "string") return true;
  if (typeof token !== "object" || token === null) return false;
  if ("X-Algo-API-Token" in token && typeof token["X-Algo-API-Token"] === "string") return true;
  if ("get" in token && "post" in token && "delete" in token) return true;
  return Object.values(token).every((value) => typeof value === "string");
}
function isNetworkConfig(config) {
  if (typeof config !== "object" || config === null) return false;
  const { algod, isTestnet, genesisHash, genesisId, caipChainId } = config;
  const isValidAlgod = typeof algod === "object" && algod !== null && isValidToken(algod.token) && typeof algod.baseServer === "string";
  return isValidAlgod && (isTestnet === void 0 || typeof isTestnet === "boolean") && (genesisHash === void 0 || typeof genesisHash === "string") && (genesisId === void 0 || typeof genesisId === "string") && (caipChainId === void 0 || typeof caipChainId === "string");
}
var NetworkId = /* @__PURE__ */ ((NetworkId4) => {
  NetworkId4["MAINNET"] = "mainnet";
  NetworkId4["TESTNET"] = "testnet";
  NetworkId4["BETANET"] = "betanet";
  NetworkId4["FNET"] = "fnet";
  NetworkId4["LOCALNET"] = "localnet";
  return NetworkId4;
})(NetworkId || {});

// src/storage.ts
var StorageAdapter = class {
  static getItem(key) {
    if (typeof window === "undefined") {
      return null;
    }
    return localStorage.getItem(key);
  }
  static setItem(key, value) {
    if (typeof window === "undefined") {
      return;
    }
    localStorage.setItem(key, value);
  }
  static removeItem(key) {
    if (typeof window === "undefined") {
      return;
    }
    localStorage.removeItem(key);
  }
};

// src/store.ts
import algosdk from "algosdk";

// src/wallets/types.ts
var WalletId = /* @__PURE__ */ ((WalletId2) => {
  WalletId2["BIATEC"] = "biatec";
  WalletId2["DEFLY"] = "defly";
  WalletId2["DEFLY_WEB"] = "defly-web";
  WalletId2["CUSTOM"] = "custom";
  WalletId2["EXODUS"] = "exodus";
  WalletId2["KIBISIS"] = "kibisis";
  WalletId2["KMD"] = "kmd";
  WalletId2["LUTE"] = "lute";
  WalletId2["MAGIC"] = "magic";
  WalletId2["MNEMONIC"] = "mnemonic";
  WalletId2["PERA"] = "pera";
  WalletId2["WALLETCONNECT"] = "walletconnect";
  WalletId2["W3_WALLET"] = "w3-wallet";
  return WalletId2;
})(WalletId || {});
var SignTxnsError = class extends Error {
  code;
  data;
  constructor(message, code, data) {
    super(message);
    this.name = "SignTxnsError";
    this.code = code;
    this.data = data;
  }
};
var SignDataError = class extends Error {
  code;
  data;
  constructor(message, code, data) {
    super(message);
    this.name = "SignDataError";
    this.code = code;
    this.data = data;
  }
};
var ScopeType = /* @__PURE__ */ ((ScopeType2) => {
  ScopeType2[ScopeType2["UNKNOWN"] = -1] = "UNKNOWN";
  ScopeType2[ScopeType2["AUTH"] = 1] = "AUTH";
  return ScopeType2;
})(ScopeType || {});

// src/store.ts
var DEFAULT_STATE = {
  wallets: {},
  activeWallet: null,
  activeNetwork: "testnet",
  algodClient: new algosdk.Algodv2("", "https://testnet-api.4160.nodely.dev/"),
  managerStatus: "initializing",
  networkConfig: DEFAULT_NETWORK_CONFIG,
  customNetworkConfigs: {}
};
var LOCAL_STORAGE_KEY = "@txnlab/use-wallet:v4";
function addWallet(store, { walletId, wallet }) {
  store.setState((state) => {
    const updatedWallets = {
      ...state.wallets,
      [walletId]: {
        accounts: wallet.accounts.map((account) => ({ ...account })),
        activeAccount: wallet.activeAccount ? { ...wallet.activeAccount } : null
      }
    };
    return {
      ...state,
      wallets: updatedWallets,
      activeWallet: walletId
    };
  });
}
function removeWallet(store, { walletId }) {
  store.setState((state) => {
    const updatedWallets = { ...state.wallets };
    delete updatedWallets[walletId];
    return {
      ...state,
      wallets: updatedWallets,
      activeWallet: state.activeWallet === walletId ? null : state.activeWallet
    };
  });
}
function setActiveWallet(store, { walletId }) {
  store.setState((state) => ({
    ...state,
    activeWallet: walletId
  }));
}
function setActiveAccount(store, { walletId, address }) {
  store.setState((state) => {
    const wallet = state.wallets[walletId];
    if (!wallet) {
      logger.warn(`Wallet with id "${walletId}" not found`);
      return state;
    }
    const newActiveAccount = wallet.accounts.find((a) => a.address === address);
    if (!newActiveAccount) {
      logger.warn(`Account with address ${address} not found in wallet "${walletId}"`);
      return state;
    }
    const updatedWallet = {
      ...wallet,
      accounts: wallet.accounts.map((account) => ({ ...account })),
      activeAccount: { ...newActiveAccount }
    };
    const updatedWallets = {
      ...state.wallets,
      [walletId]: updatedWallet
    };
    return {
      ...state,
      wallets: updatedWallets
    };
  });
}
function setAccounts(store, { walletId, accounts }) {
  store.setState((state) => {
    const wallet = state.wallets[walletId];
    if (!wallet) {
      logger.warn(`Wallet with id "${walletId}" not found`);
      return state;
    }
    const newAccounts = accounts.map((account) => ({ ...account }));
    const isActiveAccountConnected = newAccounts.some(
      (account) => account.address === wallet.activeAccount?.address
    );
    const newActiveAccount = isActiveAccountConnected ? { ...wallet.activeAccount } : newAccounts[0] || null;
    const updatedWallet = {
      ...wallet,
      accounts: newAccounts,
      activeAccount: newActiveAccount
    };
    const updatedWallets = {
      ...state.wallets,
      [walletId]: updatedWallet
    };
    return {
      ...state,
      wallets: updatedWallets
    };
  });
}
function setActiveNetwork(store, { networkId, algodClient }) {
  store.setState((state) => ({
    ...state,
    activeNetwork: networkId,
    algodClient
  }));
}
function isValidPersistedState(state) {
  return typeof state === "object" && state !== null && "wallets" in state && "activeWallet" in state && "activeNetwork" in state && (!("customNetworkConfigs" in state) || typeof state.customNetworkConfigs === "object" && state.customNetworkConfigs !== null);
}

// src/utils.ts
import algosdk12 from "algosdk";

// src/wallets/walletconnect.ts
import algosdk2 from "algosdk";

// src/wallets/base.ts
var BaseWallet = class {
  id;
  metadata;
  store;
  getAlgodClient;
  subscribe;
  logger;
  constructor({
    id,
    metadata,
    store,
    subscribe,
    getAlgodClient
  }) {
    this.id = id;
    this.store = store;
    this.subscribe = subscribe;
    this.getAlgodClient = getAlgodClient;
    const ctor = this.constructor;
    this.metadata = { ...ctor.defaultMetadata, ...metadata };
    this.logger = logger.createScopedLogger(`Wallet:${this.id.toUpperCase()}`);
  }
  static defaultMetadata = { name: "Base Wallet", icon: "" };
  setActive = () => {
    this.logger.info(`Set active wallet: ${this.id}`);
    setActiveWallet(this.store, { walletId: this.id });
  };
  setActiveAccount = (account) => {
    this.logger.info(`Set active account: ${account}`);
    setActiveAccount(this.store, {
      walletId: this.id,
      address: account
    });
  };
  transactionSigner = async (txnGroup, indexesToSign) => {
    const signTxnsResult = await this.signTransactions(txnGroup, indexesToSign);
    const signedTxns = signTxnsResult.reduce((acc, value) => {
      if (value !== null) {
        acc.push(value);
      }
      return acc;
    }, []);
    return signedTxns;
  };
  canSignData = false;
  signData = async (_data, _metadata) => {
    this.logger.error("Method not supported: signData");
    throw new Error("Method not supported: signData");
  };
  // ---------- Derived Properties ------------------------------------ //
  get name() {
    return this.id.toUpperCase();
  }
  get accounts() {
    const state = this.store.state;
    const walletState = state.wallets[this.id];
    return walletState ? walletState.accounts : [];
  }
  get addresses() {
    return this.accounts.map((account) => account.address);
  }
  get activeAccount() {
    const state = this.store.state;
    const walletState = state.wallets[this.id];
    return walletState ? walletState.activeAccount : null;
  }
  get activeAddress() {
    return this.activeAccount?.address ?? null;
  }
  get activeNetwork() {
    const state = this.store.state;
    return state.activeNetwork;
  }
  get isConnected() {
    const state = this.store.state;
    const walletState = state.wallets[this.id];
    return walletState ? walletState.accounts.length > 0 : false;
  }
  get isActive() {
    const state = this.store.state;
    return state.activeWallet === this.id;
  }
  get activeNetworkConfig() {
    const { networkConfig, activeNetwork } = this.store.state;
    return networkConfig[activeNetwork];
  }
  // ---------- Protected Methods ------------------------------------- //
  onDisconnect = () => {
    this.logger.debug(`Removing wallet from store...`);
    removeWallet(this.store, { walletId: this.id });
  };
  manageWalletConnectSession = (action, targetWalletId) => {
    const walletId = targetWalletId || this.id;
    if (action === "backup") {
      const data = StorageAdapter.getItem("walletconnect");
      if (data) {
        StorageAdapter.setItem(`walletconnect-${walletId}`, data);
        StorageAdapter.removeItem("walletconnect");
        this.logger.debug(`Backed up WalletConnect session for ${walletId}`);
      }
    } else if (action === "restore") {
      const data = StorageAdapter.getItem(`walletconnect-${walletId}`);
      if (data) {
        StorageAdapter.setItem("walletconnect", data);
        StorageAdapter.removeItem(`walletconnect-${walletId}`);
        this.logger.debug(`Restored WalletConnect session for ${walletId}`);
      }
    }
  };
};

// src/wallets/walletconnect.ts
var SessionError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SessionError";
  }
};
var ICON = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 480 480" xmlns="http://www.w3.org/2000/svg">
  <rect width="480" height="480" fill="#FFFFFF" />
  <path fill="#3396FF" d="M126.6,168c62.6-61.3,164.2-61.3,226.8,0l7.5,7.4c3.1,3.1,3.1,8,0,11.1l-25.8,25.2c-1.6,1.5-4.1,1.5-5.7,0l-10.4-10.2c-43.7-42.8-114.5-42.8-158.2,0l-11.1,10.9c-1.6,1.5-4.1,1.5-5.7,0l-25.8-25.2c-3.1-3.1-3.1-8,0-11.1L126.6,168zM406.7,220.2l22.9,22.5c3.1,3.1,3.1,8,0,11.1L326.2,355.1c-3.1,3.1-8.2,3.1-11.3,0l-73.4-71.9c-0.8-0.8-2.1-0.8-2.8,0l-73.4,71.9c-3.1,3.1-8.2,3.1-11.3,0L50.3,253.8c-3.1-3.1-3.1-8,0-11.1l22.9-22.5c3.1-3.1,8.2-3.1,11.3,0l73.4,71.9c0.8,0.8,2.1,0.8,2.8,0 l73.4-71.9c3.1-3.1,8.2-3.1,11.3,0l73.4,71.9c0.8,0.8,2.1,0.8,2.8,0l73.4-71.9C398.5,217.1,403.6,217.1,406.7,220.2L406.7,220.2z" />
</svg>
`)}`;
var WalletConnect = class extends BaseWallet {
  client = null;
  options;
  modal = null;
  modalOptions;
  session = null;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options,
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    if (!options?.projectId) {
      this.logger.error("Missing required option: projectId");
      throw new Error("Missing required option: projectId");
    }
    const {
      projectId,
      relayUrl = "wss://relay.walletconnect.com",
      metadata: metadataOptions,
      ...modalOptions
    } = options;
    const clientMetadata = {
      ...this.getWindowMetadata(),
      ...metadataOptions
    };
    this.options = {
      projectId,
      relayUrl,
      metadata: clientMetadata
    };
    this.modalOptions = modalOptions;
    this.store = store;
  }
  static defaultMetadata = {
    name: "WalletConnect",
    icon: ICON
  };
  /**
   * Get metadata from the current window. This is adapted from the @walletconnect/utils
   * implementation, to avoid requiring the entire package as a dependency.
   * @see https://github.com/WalletConnect/walletconnect-utils/blob/master/browser/window-metadata/src/index.ts
   */
  getWindowMetadata() {
    let doc;
    let loc;
    const defaultMetadata = {
      name: "",
      description: "",
      url: "",
      icons: []
    };
    function getFromWindow(name2) {
      let res;
      if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
        res = window[name2];
      }
      return res;
    }
    function getFromWindowOrThrow(name2) {
      const res = getFromWindow(name2);
      if (!res) {
        throw new Error(`${name2} is not defined in Window`);
      }
      return res;
    }
    function getDocumentOrThrow() {
      return getFromWindowOrThrow("document");
    }
    function getLocationOrThrow() {
      return getFromWindowOrThrow("location");
    }
    try {
      doc = getDocumentOrThrow();
      loc = getLocationOrThrow();
    } catch (error) {
      this.logger.warn("Error getting window metadata:", error);
      return defaultMetadata;
    }
    function getIcons() {
      const links = doc.getElementsByTagName("link");
      const icons2 = [];
      for (let i = 0; i < links.length; i++) {
        const link = links[i];
        const rel = link.getAttribute("rel");
        if (rel) {
          if (rel.toLowerCase().indexOf("icon") > -1) {
            const href = link.getAttribute("href");
            if (href) {
              if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                let absoluteHref = loc.protocol + "//" + loc.host;
                if (href.indexOf("/") === 0) {
                  absoluteHref += href;
                } else {
                  const path = loc.pathname.split("/");
                  path.pop();
                  const finalPath = path.join("/");
                  absoluteHref += finalPath + "/" + href;
                }
                icons2.push(absoluteHref);
              } else if (href.indexOf("//") === 0) {
                const absoluteUrl = loc.protocol + href;
                icons2.push(absoluteUrl);
              } else {
                icons2.push(href);
              }
            }
          }
        }
      }
      return icons2;
    }
    function getWindowMetadataOfAny(...args) {
      const metaTags = doc.getElementsByTagName("meta");
      for (let i = 0; i < metaTags.length; i++) {
        const tag = metaTags[i];
        const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
          if (attr) {
            return args.includes(attr);
          }
          return false;
        });
        if (attributes.length && attributes) {
          const content = tag.getAttribute("content");
          if (content) {
            return content;
          }
        }
      }
      return "";
    }
    function getName() {
      let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
      if (!name2) {
        name2 = doc.title;
      }
      return name2;
    }
    function getDescription() {
      const description2 = getWindowMetadataOfAny(
        "description",
        "og:description",
        "twitter:description",
        "keywords"
      );
      return description2;
    }
    const name = getName();
    const description = getDescription();
    const url = loc.origin;
    const icons = getIcons();
    const meta = {
      description,
      url,
      icons,
      name
    };
    return meta;
  }
  async initializeClient() {
    this.logger.info("Initializing client...");
    const SignClient = (await import("@walletconnect/sign-client")).SignClient;
    const client = await SignClient.init(this.options);
    client.on("session_event", (args) => {
      this.logger.info("EVENT: session_event", args);
    });
    client.on("session_update", ({ topic, params }) => {
      this.logger.info("EVENT: session_update", { topic, params });
      const { namespaces } = params;
      const session = client.session.get(topic);
      const updatedSession = { ...session, namespaces };
      this.onSessionConnected(updatedSession);
    });
    client.on("session_delete", () => {
      this.logger.info("EVENT: session_delete");
      this.session = null;
    });
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  async initializeModal() {
    this.logger.info("Initializing modal...");
    const WalletConnectModal = (await import("@walletconnect/modal")).WalletConnectModal;
    const modal = new WalletConnectModal({
      projectId: this.options.projectId,
      ...this.modalOptions
    });
    modal.subscribeModal((state) => this.logger.info(`Modal ${state.open ? "open" : "closed"}`));
    this.modal = modal;
    this.logger.info("Modal initialized");
    return modal;
  }
  onSessionConnected(session) {
    const caipAccounts = session.namespaces.algorand.accounts;
    if (!caipAccounts.length) {
      this.logger.error("No accounts found!");
      throw new Error("No accounts found!");
    }
    const accounts = [...new Set(caipAccounts.map((account) => account.split(":").pop()))];
    const walletAccounts = accounts.map((address, idx) => ({
      name: `${this.metadata.name} Account ${idx + 1}`,
      address
    }));
    const state = this.store.state;
    const walletState = state.wallets[this.id];
    if (!walletState) {
      const newWalletState = {
        accounts: walletAccounts,
        activeAccount: walletAccounts[0]
      };
      addWallet(this.store, {
        walletId: this.id,
        wallet: newWalletState
      });
      this.logger.info("Connected", newWalletState);
    } else {
      const match = compareAccounts(walletAccounts, walletState.accounts);
      if (!match) {
        this.logger.warn("Session accounts mismatch, updating accounts", {
          prev: walletState.accounts,
          current: walletAccounts
        });
        setAccounts(this.store, {
          walletId: this.id,
          accounts: walletAccounts
        });
      }
    }
    this.session = session;
    return walletAccounts;
  }
  get activeChainId() {
    const network = this.activeNetworkConfig;
    if (!network?.caipChainId) {
      this.logger.warn(`No CAIP-2 chain ID found for network: ${this.activeNetwork}`);
      return "";
    }
    return network.caipChainId;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    try {
      const client = this.client || await this.initializeClient();
      const modal = this.modal || await this.initializeModal();
      const requiredNamespaces = {
        algorand: {
          chains: [this.activeChainId],
          methods: ["algo_signTxn"],
          events: []
        }
      };
      const { uri, approval } = await client.connect({ requiredNamespaces });
      if (!uri) {
        this.logger.error("No URI found");
        throw new Error("No URI found");
      }
      await modal.openModal({ uri });
      const session = await approval();
      const walletAccounts = this.onSessionConnected(session);
      this.logger.info("Connected successfully");
      return walletAccounts;
    } catch (error) {
      this.logger.error("Error connecting:", error.message);
      throw error;
    } finally {
      this.modal?.closeModal();
    }
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    try {
      this.onDisconnect();
      if (this.client && this.session) {
        await this.client.disconnect({
          topic: this.session.topic,
          reason: {
            message: "User disconnected.",
            code: 6e3
          }
        });
      }
      this.logger.info("Disconnected");
    } catch (error) {
      this.logger.error("Error disconnecting:", error.message);
      throw error;
    }
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      const client = this.client || await this.initializeClient();
      if (client.session.length) {
        const lastKeyIndex = client.session.keys.length - 1;
        const restoredSession = client.session.get(client.session.keys[lastKeyIndex]);
        this.onSessionConnected(restoredSession);
      }
      this.logger.info("Session resumed successfully");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk2.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk2.decodeSignedTransaction(txnBuffer).txn : algosdk2.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      if (!this.session) {
        this.logger.error("No session found!");
        throw new SessionError("No session found!");
      }
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", [txnsToSign]);
      const request = formatJsonRpcRequest("algo_signTxn", [txnsToSign]);
      const signTxnsResult = await client.request({
        chainId: this.activeChainId,
        topic: this.session.topic,
        request
      });
      this.logger.debug("Received signed transactions from wallet", signTxnsResult);
      const signedTxns = signTxnsResult.reduce((acc, value) => {
        if (value) {
          let signedTxn;
          if (typeof value === "string") {
            signedTxn = base64ToByteArray(value);
          } else if (value instanceof Uint8Array) {
            signedTxn = value;
          } else if (Array.isArray(value)) {
            signedTxn = new Uint8Array(value);
          } else {
            this.logger.warn("Unexpected type in signTxnsResult", value);
            signedTxn = new Uint8Array();
          }
          acc.push(signedTxn);
        }
        return acc;
      }, []);
      const result = txnsToSign.reduce((acc, txn) => {
        if (txn.signers && txn.signers.length == 0) {
          acc.push(null);
        } else {
          const signedTxn = signedTxns.shift();
          if (signedTxn) {
            acc.push(signedTxn);
          }
        }
        return acc;
      }, []);
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/wallets/biatec.ts
var ICON2 = `data:image/svg+xml;base64,${btoa(`
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 180"><path d="M94.27 151.629c-.861-.526-1.51-1.37-1.83-2.386-.197-.62-.18-.627 1.082-.437.705.105 1.6.356 1.988.557.696.36 1.815 1.876 1.815 2.459 0 .486-2.166.348-3.054-.193m23.953-.263c-.788-.419-2.095-2.123-2.108-2.75-.01-.433 2.467-.182 3.403.345.955.536 2.148 1.97 2.148 2.582 0 .503-2.397.38-3.443-.177m-9.024-1.165c-1.567-1.193-2.38-2.74-2.55-4.849-.075-.933-.054-1.697.045-1.697.866 0 2.714 1.67 3.439 3.107.398.789.657 3.888.351 4.195-.07.07-.648-.27-1.285-.756m-8.906-1.354c-.63-.684-1.21-1.648-1.387-2.305-.318-1.18-.136-3.416.278-3.416.555 0 2.108 1.697 2.505 2.737.472 1.237.457 3.905-.023 4.063-.16.053-.777-.433-1.373-1.08m-6.805-1.775c-2.764-.612-5.223-1.425-5.357-1.772-.08-.21.169-1.027.555-1.814s.701-1.469.701-1.515c0-.047-.803.067-1.786.253-.982.185-1.857.256-1.944.157-.088-.1-.365-.715-.618-1.367-.252-.652-.858-1.729-1.345-2.393-1.293-1.76-5.285-5.526-7.272-6.858-3.826-2.564-4.96-3.855-4.667-5.316.08-.402.692-1.574 1.359-2.606 1.65-2.551 2.51-4.472 2.512-5.62.002-.571-.364-1.69-.901-2.758l-.905-1.796.706-.532c1.936-1.46 4.649-4.916 4.205-5.36-.06-.06-.846.72-1.745 1.732-3.553 3.997-7.814 6.463-16.014 9.27-5.324 1.823-5.853 2.06-7.183 3.228-1.555 1.365-1.962 2.502-2.531 7.063-.284 2.275-.706 4.79-.937 5.591-.231.8-.403 2.17-.382 3.043.032 1.346-.157 2.06-1.248 4.698-1.498 3.622-1.068 3.708-4.138-.827l-2.036-3.008.747-.784c.411-.43 1.075-.978 1.475-1.216.955-.568.919-.922-.236-2.331-.53-.647-.917-1.209-.86-1.25s.43-.277.83-.526c1.788-1.12 2.7-4.727 2.987-11.822.214-5.274.595-6.46 2.195-6.83 6.634-1.535 7.58-1.98 8.618-4.066.926-1.858.9-3.701-.121-8.475-.87-4.072-1.047-7.21-.516-9.223.606-2.303 3.759-7.433 5.667-9.221.376-.353.684-.729.684-.835 0-.254-3.325-2.697-4.448-3.268-.482-.245-1.455-.45-2.163-.456-3.892-.03-6.628 1.877-8.722 6.08-.603 1.212-1.582 2.73-2.176 3.374-2.733 2.965-8.602 4.09-12.666 2.43l-.913-.374 1.323-.05c1.422-.054 3.498-.94 3.944-1.683.414-.69.076-.79-1.06-.314-1.443.605-4.075.597-5.039-.015-1.259-.8-2.23-1.81-2.795-2.908l-.535-1.042 1.243 1.095c1.51 1.328 2.691 1.752 4.425 1.585 1.506-.145 2.523-.851 1.65-1.147-3.195-1.08-5.834-3.078-7.07-5.35-.809-1.485-1.513-3.982-1.504-5.334l.006-.936.42.854c.232.47.941 1.333 1.576 1.918l1.155 1.064 2.189-.012 2.188-.011-1.012-.535c-.975-.514-3.353-2.766-3.353-3.175 0-.11.506.079 1.124.418 1.282.703 3.888 1.32 4.21.996.12-.118-.204-.612-.718-1.097-.513-.484-1.17-1.344-1.46-1.911l-.525-1.03 1.174.895c2.02 1.542 3.883 1.506 6.342-.123.69-.457 1.218-.863 1.175-.903s-.989.227-2.103.594c-1.87.618-2.11.64-3.151.305-1.284-.415-2.023-1.273-2.25-2.613l-.158-.926.486.595c1.07 1.31 2.652 1.255 6.363-.224 1.132-.451 2.892-1.036 3.91-1.3 2.732-.706 1.561-.926-2.298-.43-1.778.228-3.27.376-3.318.329-.047-.047.662-.415 1.575-.818 2.002-.883 4.78-1.152 6.858-.663 1.817.427 2.555.81 4.032 2.087 1.151.997 3.654 2.156 4.605 2.133.595-.015-2.96-3.395-4.552-4.328-1.639-.96-4.11-1.542-6.107-1.438-.92.049-1.627.016-1.571-.073.242-.388 3.44-.825 5.203-.71 4.048.265 6.96 2.546 10.902 8.537 2.553 3.883 4.234 5.67 6.137 6.524l1.092.49 2.215-1.027c4.747-2.2 8.797-2.518 16.097-1.26 2.25.387 4.717.704 5.482.704h1.39l.074 3.203.074 3.203.894-1.113c.88-1.096.894-1.152.846-3.516l-.049-2.402-1.61-1.721c-4.14-4.425-4.335-6.536-1.135-12.213 2.744-4.87 2.704-4.41.813-9.32-.883-2.292-1.696-4.167-1.807-4.167-.339 0-.205 4 .196 5.821.716 3.256.435 4.822-1.006 5.603-.371.2-2.144.33-4.904.36-3.6.036-4.348-.022-4.473-.348-.087-.227.102-.582.451-.845.53-.4.563-.53.274-1.09-.18-.35-.692-1.022-1.137-1.493s-.734-.933-.64-1.026c.093-.094 1.072-.036 2.175.128 3.023.45 3.76.398 4.211-.297.4-.615 2.887-9.725 2.704-9.907-.196-.196-1.55 1.62-2.759 3.7-1.782 3.068-3.14 3.895-6.379 3.889-2.485-.005-5.43-1.098-8.658-3.213-1.439-.943-3.02-1.855-3.514-2.027-1.524-.531-3.75-.392-5.163.324l-1.26.638.567-.603c.892-.95 3.048-2.004 4.432-2.167 1.94-.23 3.3.283 5.786 2.18 2.39 1.823 3.163 2.225 4.28 2.225.6 0 .497-.12-.745-.872-.792-.48-2.416-1.598-3.609-2.486-2.658-1.978-4.119-2.58-5.831-2.4l-1.26.132.926-.39c.667-.281 1.609-.36 3.373-.284 1.346.059 2.448.077 2.448.04 0-.278-2.537-1.455-3.71-1.722-.89-.202-1.231-.365-.884-.421.312-.051 1.86.225 3.44.614 2.564.63 3.167.687 5.602.525 5.536-.369 7.032-1.144 9.218-4.774l1.433-2.382-1.224 1.323c-.673.728-1.779 1.928-2.457 2.666-.677.739-1.53 1.417-1.893 1.508l-.662.165.61-.503c.334-.277 1.088-1.491 1.675-2.698 1.772-3.648 3.228-4.779 6.772-5.257 3.522-.476 4.797-.791 5.421-1.342.332-.293.429-.44.215-.329-.213.112-1.94.277-3.836.367-2.955.14-3.666.263-4.97.86-1.632.749-4.092 2.893-4.996 4.356-.764 1.236-.923.905-.224-.465 1.387-2.718 4.685-4.945 8.366-5.651l1.815-.349-1.058-.235c-.582-.13-1.952-.224-3.043-.209l-1.984.027 1.72-.82c1.427-.682 2.04-.822 3.611-.822 1.607 0 1.86-.06 1.679-.4-.539-1.005-1.377-1.452-2.69-1.432-.769.011-1.156-.067-.937-.19.534-.298 2.168-.34 4.169-.104 1.648.194 1.82.159 3.59-.733 1.023-.515 2.472-1.047 3.22-1.183 1.388-.253 3.607-.04 4.472.429.942.51 1.958 1.825 2.095 2.712.116.746 0 1.052-.671 1.777-.752.813-.811 1.018-.811 2.82 0 1.706-.105 2.127-.85 3.424-.467.814-.973 1.476-1.124 1.473s-.797-.242-1.435-.532c-1.277-.579-1.714-.435-1.988.655-.115.46.045.84.605 1.44.42.448 1.621 2.237 2.671 3.975 1.883 3.116 1.905 3.175 1.585 4.146-.258.78-.258 1.56 0 3.73.179 1.51.253 3.031.166 3.38-.128.509.033.795.805 1.432 1.367 1.126 5.02 2.947 5.914 2.947 1.268 0 1.588.247 1.588 1.227 0 1.057-.642 2.742-1.045 2.742-.153 0-.278-.298-.278-.662 0-.558-.123-.661-.793-.661-.436 0-2.162-.467-3.836-1.036l-3.044-1.036v1.788c0 .984-.077 3.057-.172 4.608l-.173 2.82h3.015l-.133.86c-.073.472-.206 2.11-.295 3.637-.373 6.42-.634 7.203-4.207 12.65-4.119 6.278-4.635 7.984-3.493 11.548.37 1.158.647 2.133.613 2.167-.246.246-2.569-1.19-3.783-2.34-2.616-2.473-2.922-3.975-1.146-5.619.954-.882 1.054-1.087.892-1.828-.417-1.91-.553-1.976-1-.482-.232.777-.693 1.849-1.024 2.382-.526.846-.603 1.318-.603 3.705v2.736l3.175 1.022c1.746.562 3.446 1.028 3.777 1.034.583.012.59-.012.194-.776-.224-.434-.479-1.307-.566-1.939-.208-1.523.53-3.065 3.905-8.159 4.537-6.845 5.478-9.25 5.681-14.513.07-1.82.19-3.93.267-4.692.137-1.353.17-1.398 1.379-1.933 2.27-1.004 4.245-3.717 6.253-8.589.526-1.274.459-1.204-1.891 1.985-1.019 1.382-2.13 2.751-2.47 3.042-.604.516-.603.506.048-.397.938-1.299 1.216-2.144 1.685-5.107.663-4.193 1.699-6.255 4.604-9.16 3.639-3.638 9.47-6.348 13.7-6.365.635-.003 1.201-.155 1.322-.356.117-.192 1.105-.92 2.196-1.615 1.092-.696 2.252-1.511 2.579-1.812.327-.3.66-.48.74-.4.081.081-.038.942-.263 1.914s-.41 1.88-.41 2.016c0 .37 1.393.3 1.992-.102.287-.192 1.296-.62 2.241-.953s1.998-.78 2.338-.994c.34-.215.665-.345.722-.288.302.302-1.982 3.526-2.927 4.132l-1.152.74c-.277.179 1.202 3.732 1.975 4.745.674.882.862 1.347.742 1.825-.089.354.045 1.273.296 2.044.645 1.98 2.913 6.751 3.698 7.779.808 1.06.82 1.416.075 2.363-.32.408-.648 1.225-.728 1.816-.118.879-.279 1.12-.89 1.335-1.457.512-2.298-.449-2.94-3.358-.113-.512-.325-.728-.715-.728-.634 0-.619.099.398 2.514.368.873.572 1.685.453 1.804-.12.119-.679.178-1.244.132-1.006-.082-1.03-.108-1.165-1.29-.11-.958-.407-1.515-1.444-2.716-1.28-1.483-1.523-1.617-3.974-2.186-.436-.102-1.235-.406-1.776-.677l-.981-.491-.311 1.124c-.462 1.668-.381 7.592.14 10.35.244 1.29.926 3.552 1.516 5.027 1.864 4.655 1.933 4.98 1.924 9.031-.006 2.853-.112 3.972-.461 4.87-.25.641-.415 1.204-.367 1.252.047.047 2.935.203 6.419.347 4.2.174 6.786.397 7.679.664 1.433.429 2.955 1.341 3.328 1.995.125.219 1.292 3.718 2.594 7.777 2.56 7.978 2.515 7.613 1.142 9.263-.582.7-.623.918-.458 2.455l.18 1.686-1.685 1.59c-2.476 2.335-2.487 2.338-2.833.702l-.825-3.894c-.497-2.344-.503-2.535-.09-2.844.245-.182.75-.332 1.121-.335 1.259-.007 1.444-.36.672-1.277l-.7-.833.461-1.209c.403-1.054.421-1.428.146-2.924-.856-4.647-3.463-7.755-6.516-7.769-1.198-.006-5.626.726-6.143 1.015-.419.235 1.36 2.035 4.026 4.073 1.954 1.494 2.487 2.265 2.708 3.918.115.858-.031 1.278-.963 2.753-1.122 1.776-2.596 4.941-4.015 8.62-.437 1.133-1.048 2.383-1.358 2.777-.546.695-.623.712-2.434.544-1.51-.14-2.034-.085-2.726.287-.933.503-1.032.488-5.234-.754l-1.852-.547 1.058-.93c2.452-2.155 4.96-4.035 5.375-4.028.245.004.743.417 1.107.919.364.5.74.914.835.918.336.014 2.673-2.777 3.423-4.09.928-1.622 1.429-3.721 1.19-4.992-.414-2.208-2.105-3.2-8.836-5.183-4.604-1.356-5.44-1.637-6.837-2.3-.81-.384-.92-.36-3.047.664-2.593 1.248-5.507 2.251-8.665 2.983-3.304.766-9.686.95-12.988.376-3.227-.562-7.639-2.035-9.626-3.214-.856-.508-1.618-.862-1.693-.787-.15.15 1.12 2.079 1.665 2.53.271.226.239.732-.166 2.586-1.245 5.713-2.66 8.612-7.189 14.73-2.852 3.852-3.402 5.685-2.327 7.762.66 1.274 9.278 9.763 11.016 10.85.797.498 1.576 1.26 1.929 1.889.496.883 2.158 5.275 2.158 5.704 0 .2-1.577.111-2.779-.154m46.76-1.68c-2.98-1.107-5.348-3.111-7.054-5.97-1.025-1.72-2.16-4.428-1.946-4.643.229-.229 3.039.644 4.916 1.527 3.417 1.608 6.275 5.198 6.594 8.283.178 1.723.063 1.76-2.51.803m-70.399.107c-2.923-.4-6.887-2.043-7.56-3.132-.23-.371 1.693-1.772 3.683-2.683 4.119-1.887 9.22-1.779 13.075.277 1.637.873 4.347 2.943 4.307 3.29-.014.122-.895.499-1.957.837-4.06 1.29-8.482 1.831-11.548 1.411m51.264-1.55c-1.687-.66-3.315-1.831-4.87-3.503l-1.323-1.421 2.116-.183c3.467-.298 6.424.354 8.757 1.932 1.096.742 2.753 2.456 2.753 2.848 0 .859-5.46 1.099-7.433.326m38.521-1.26c-3.84-.798-6.966-2.331-9.705-4.761-2.156-1.913-3.179-2.512-5.08-2.978-1.478-.362-3.339-1.249-3.339-1.591 0-.318 2.824-.81 5.689-.991 7.046-.446 13.549 2.741 16.133 7.908.513 1.024.932 2.025.932 2.224 0 .277-.479.354-2.05.33-1.128-.016-2.289-.08-2.58-.14m-61.217-2.076c-1.35-.421-2.52-1.449-3.238-2.845l-.51-.992h1.178c1.479 0 2.46.365 3.42 1.273.65.615 1.762 2.392 1.762 2.817 0 .255-1.426.117-2.612-.253m5.45-1.504c-1.583-1.153-2.396-3.509-1.878-5.442.192-.715.563-.742 1.334-.098 1.18.986 1.673 2.177 1.674 4.051 0 .974-.09 1.826-.2 1.895-.112.068-.53-.114-.93-.406m-26.254-1.075a150 150 0 0 0-3.968-1.97l-2.382-1.138 1.21-.001c2.527-.002 4.928 1.203 6.339 3.185.306.43.52.777.473.77-.046-.007-.799-.388-1.672-.845zm-14.354-3.608c-.764-.264-1.631-.699-1.927-.966-.59-.534-1.695-2.22-1.542-2.352.053-.045.573-.192 1.155-.325 1.324-.303 1.45-.925.662-3.265-.306-.908-.503-1.705-.438-1.77.066-.066.637.018 1.27.187.95.253 1.683.849 4.194 3.411 2.483 2.534 3.286 3.19 4.366 3.566.727.253 1.62.587 1.984.742l.662.28-.662.199c-.779.234-6.102.794-7.42.782-.503-.005-1.54-.225-2.304-.489m104.313-.83c-1.528-.484-4.719-2.704-4.75-3.303-.006-.145.88-.42 1.972-.61 2.368-.414 4.676-.11 6.582.864 1.41.721 3.082 2.35 2.83 2.756-.55.891-4.237 1.054-6.634.294m-56.58-.117c-2.06-.734-3.35-2.65-3.345-4.961.006-2.304.15-2.574 1.279-2.397 1.516.239 3.013.83 3.677 1.455l.609.572 1.523-1.507c.838-.829 1.593-1.507 1.679-1.507.085 0 .362.735.614 1.633.94 3.35-.383 5.974-3.431 6.806-1.302.356-1.35.354-2.605-.094m-75.315-.698c-6.533-.942-11.018-2.967-14.552-6.571-1.972-2.01-3.175-3.81-2.8-4.186.109-.109 1.32-.239 2.693-.29 5.235-.192 9.266 1.449 13.22 5.381 2.097 2.085 5.101 5.853 4.838 6.068-.05.041-1.58-.14-3.4-.402m97.327-1.25c4.267-5.096 8.959-7.442 13.334-6.666.982.174 1.84.405 1.906.513.198.32-1.54 2.713-2.834 3.904-2.314 2.13-5.42 3.148-10.492 3.438l-3.055.175zm17.502-.559c0-.646 1.702-5.318 2.447-6.715 1.472-2.762 4.84-5.965 5.538-5.267.161.161.234 1.18.176 2.481-.114 2.603-.705 4.023-2.51 6.03-1.524 1.695-5.651 4.23-5.651 3.471m8.04-1.157c3.728-2.356 7.725-5.133 8.864-6.158 1.353-1.218 1.403-1.24.984-.43-1.093 2.113-4.85 5.104-7.93 6.31-1.734.68-2.798.834-1.919.278m2.457-4.828c-.243-.511-.443-1.383-.443-1.937 0-1.018.973-3.223 1.5-3.399.368-.123 1.146 1.814 1.146 2.853 0 .855-.78 2.6-1.39 3.105-.298.247-.456.127-.813-.622m11.343.373c-1.157-.135-2.15-.292-2.206-.348-.16-.16 1.966-2.017 3.71-3.24 2.387-1.673 4.54-2.317 7.745-2.316 2.182 0 2.874.104 3.949.596l1.303.595-.907.936c-2.935 3.03-7.986 4.433-13.594 3.777m-135.543-5.98c-3.17-5.953-3.802-11.809-1.769-16.407.766-1.73 2.408-4.033 2.878-4.033.185 0 .7.685 1.142 1.522 2.02 3.82 2.643 8.569 1.708 13.03-.515 2.454-2.383 7.938-2.705 7.938-.089 0-.653-.923-1.254-2.05m131.543-.026c-2.11-1.55-3.023-3.093-3.023-5.108 0-1.215.77-3.056 1.587-3.796.494-.447.574-.438 1.965.243 1.713.838 2.676 1.892 3.072 3.363.464 1.725-.257 3.872-1.791 5.328l-.771.733zm-142.341-2.392c-.955-.434-3.028-2.462-3.028-2.963 0-.106.589-.273 1.309-.372 2.032-.28 3.923.381 5.269 1.84.602.654 1.095 1.295 1.095 1.426 0 .289-1.308.57-2.613.562-.527-.003-1.442-.225-2.032-.493m134.927-3.139c1.218-3.954 1.471-13.59.477-18.203a57 57 0 0 0-1.472-5.291c-1.025-3-1.187-3.508-1.031-3.229.06.11.227.199.369.199s.185-.12.095-.265-.099-.265-.019-.265c.285 0 2.284 4.27 2.94 6.28.942 2.884 1.488 6.584 1.481 10.037-.008 4.205-.63 7.156-2.126 10.088-.577 1.13-.974 1.491-.714.65m15.622-.53c.096-.4.694-1.798 1.33-3.108 1.78-3.673 4.396-6.043 7.61-6.899 2.261-.602 2.412-.555 2.244.699-.39 2.903-3.348 6.413-6.971 8.27-.455.233-1.63.726-2.608 1.094l-1.78.67zm-150.592-3.621c-5.551-2.683-8.865-5.295-11.436-9.013-2.092-3.028-3.72-7.066-3.72-9.231 0-.636.089-.69 1.135-.69 2.913 0 6.796 1.74 9.585 4.296 3.283 3.008 5.033 6.073 6.587 11.534 1.15 4.043 1.263 4.544 1.02 4.54-.111 0-1.539-.647-3.17-1.436m145.075.485c-.092-.241-.309-1.552-.48-2.914-.562-4.443.43-8.183 2.772-10.456.58-.562 1.164-1.022 1.3-1.022.405 0 1.01 1.75 1.186 3.43.324 3.1-.9 6.63-3.421 9.872-.926 1.19-1.226 1.431-1.357 1.09m-6.353-7.675c.34-1.413.908-2.21 1.957-2.745 1.55-.792 1.96-.718 1.754.314-.326 1.628-1.397 2.695-3.034 3.022-.84.168-.856.154-.677-.591m18.432-2.084c-.473-.206-.857-.469-.854-.585.01-.368 1.945-1.592 2.816-1.781.461-.1 1.34-.047 1.952.118l1.114.3-.882.909c-.764.789-2.17 1.45-3.022 1.422-.145-.005-.651-.178-1.124-.383m-4.19-2.014c.437-5.243 1.85-8.992 4.434-11.754 1.589-1.698 4.011-3.172 5.51-3.353.608-.073.669.016.745 1.087.125 1.742-.655 4.812-1.81 7.117-1.233 2.466-3.244 4.75-6.16 7-3.185 2.457-2.932 2.466-2.719-.097M164.535 96.2c.011-.601.996-2.432 1.613-2.997.74-.68 1.86-1.142 2.764-1.142.74 0 .783.213.287 1.402-.328.784-2.05 2.558-2.496 2.573-.105.004-.636.11-1.182.237-.703.163-.99.142-.986-.073M39.38 92.511l-1.19-.287 1.894-.184c2.429-.237 4.211-.836 5.755-1.933 1.705-1.212 2.43-2.3 3.187-4.777.358-1.173 1.027-2.644 1.487-3.27.855-1.16 1.328-1.354.772-.315-.17.317-.42 1.753-.555 3.191s-.371 2.944-.524 3.347c-1.29 3.39-6.255 5.33-10.826 4.228m132.353-3.022c-1.37-3.004-1.722-4.62-1.596-7.322.12-2.584.663-4.209 1.984-5.941l.698-.915.593.689c1.538 1.787 2.37 6.366 1.72 9.457-.375 1.79-1.903 5.61-2.293 5.734-.158.05-.656-.715-1.106-1.702m6.655.323c.094-.582.245-3.618.336-6.747.16-5.514-.097-11.175-.726-16.007-.66-5.078-2.584-11.438-4.788-15.834-.572-1.142-.914-1.998-.76-1.903.154.096.28.02.28-.17 0-.608 1.905 2.465 3.056 4.93 3.19 6.83 5.492 18.482 5.039 25.5-.219 3.379-.79 6.78-1.52 9.04-.672 2.084-1.164 2.722-.917 1.191m-5.129-39.936c0-.065-.119-.19-.264-.28s-.265-.038-.265.116.12.28.265.28.264-.052.264-.116M21.39 87.46c-6.885-6.262-9.634-10.983-10.312-17.71-.218-2.153.098-6.211.514-6.628.377-.377 2.86.757 4.714 2.153 4.287 3.228 7.128 8.67 7.976 15.276.349 2.717.746 9.923.547 9.92-.073-.001-1.62-1.356-3.44-3.01m141.818 1.495c.002-1.223.51-2.654 1.254-3.539.681-.81 2.635-1.902 2.999-1.677.248.154-.193 2.347-.65 3.224-.523 1.007-1.444 1.82-2.616 2.31l-.989.413zm19.715-9.65c.101-.48.414-1.25.694-1.712.53-.872 2.361-1.937 3.331-1.937.515 0 .537.075.29.992-.432 1.599-1.891 2.901-3.749 3.347-.733.176-.746.16-.566-.69m-1.078-4.864c-.434-3.474.426-7.949 2.004-10.427.992-1.557 3.308-3.704 3.996-3.704.79 0 1.023 5.098.34 7.427-.775 2.639-3.22 6.102-5.41 7.661l-.744.53zM27.106 70.74c-.83-2.163.852-9.285 3.442-14.577 3.414-6.977 9.876-14.173 15.518-17.28 1.338-.736 1.306-.696-.732.921-3.554 2.82-6.93 6.51-9.617 10.514-2.78 4.142-4.184 7.582-5.825 14.274-.593 2.419-1.273 4.885-1.512 5.482-.446 1.116-.991 1.401-1.274.666m148.415-4.429c-3.31-1.775-5.714-4.87-6.05-7.787-.123-1.073-.097-1.124.573-1.122 1.742.006 4.537 2.38 5.833 4.954.468.928 1.437 4.572 1.263 4.746-.028.028-.757-.328-1.62-.79M24.465 63.817c-1.392-2.767-2.046-5.175-2.208-8.138-.16-2.924.292-6.48.823-6.48.632 0 2.73 1.536 3.654 2.676 1.65 2.036 2.173 3.325 2.185 5.393.01 1.729-.094 2.069-1.554 5.094-.86 1.782-1.663 3.24-1.783 3.24s-.623-.803-1.117-1.785m155.049-4.47c-.602-3.045-.356-5.571.757-7.767.795-1.57 2.708-3.351 3.137-2.921.187.187.302 1.33.302 3 0 2.617-.03 2.756-1.001 4.573-.551 1.03-1.462 2.322-2.024 2.871l-1.022.998zm-68.432-2.831c0-.451.748-1.115 1.521-1.35.762-.233.743.064-.061.978-.678.77-1.46.969-1.46.372M33.59 54.752c1.046-1.877 3.42-4.082 5.433-5.045 1.457-.699 2.23-.892 3.93-.982 2.15-.115 3.863.18 4.728.812.444.324.393.442-.74 1.701-1.47 1.635-3.438 2.97-5.575 3.778-1.242.47-2.33.63-4.998.735l-3.41.135zm76.965.194c0-.802 1.282-2.19 2.17-2.35.969-.176 1.534.041 1.534.587 0 .382-.305.583-1.245.82-.685.172-1.518.608-1.852.968l-.607.655zm57.018-.605c-.437-.225-.965-.578-1.173-.783-.327-.323-.22-.446.794-.905 1.314-.597 2.774-.659 4.347-.184 1.386.417 1.347.95-.122 1.69-1.377.695-2.73.76-3.846.182m-58.306-1.16c.174-.5.815-1.406 1.424-2.015.918-.918 1.368-1.152 2.637-1.37 1.42-.246 2.024-.224 3.048.107.8.26-.765 1.148-2.022 1.148-1.584 0-2.915.6-4.27 1.928l-1.133 1.109zm65.577-2.87c-.75-1.497-.906-2.129-1.001-4.048-.094-1.886-.02-2.485.431-3.506.3-.677.655-1.231.79-1.231.33 0 1.475 1.777 1.856 2.883.497 1.442.383 4.31-.236 5.965-.3.803-.638 1.517-.75 1.586-.11.069-.602-.673-1.09-1.649m-65.359.239c.662-1.25 2.453-2.918 3.604-3.357 1.384-.53 4.318-.42 5.512.206l.757.397-.576.403c-.45.315-1.084.374-2.904.27-2.854-.163-3.938.155-5.54 1.625-.876.802-1.1.922-.853.456m-79.602-1.036c-1.895-1.894-2.474-3.183-2.62-5.824-.066-1.211-.008-2.314.128-2.45.332-.332 2.019.945 2.831 2.145.348.513.825 1.5 1.06 2.192.47 1.384.581 4.818.164 5.076-.144.089-.848-.423-1.563-1.139m78.698-.58c.528-1.848 2.227-3.934 3.94-4.841 1.648-.872 4.113-.74 7.331.392l2.55.897-.936.614c-.919.602-.967.606-2.55.2-2.732-.698-3.209-.739-5.014-.424-2.025.352-3.826 1.419-4.84 2.865-.543.777-.635.833-.481.297m54.957-.028c-.619-.306-1.125-.665-1.125-.797 0-.133.387-.477.86-.765 1.455-.887 4.475-.65 6.244.49l.621.401-1.15.602c-1.547.81-3.894.84-5.45.07m-113.51-5.029c-.621-.307-1.376-.872-1.677-1.255l-.548-.696.883-.372c2.07-.872 5.296-.261 6.675 1.263.498.55.494.556-.662 1.08-1.52.69-3.253.682-4.672-.02m69.126-.293c-2.905-1.128-5.647-1.179-7.871-.147-.837.388-1.522.665-1.522.615 0-.292 2.738-1.751 3.95-2.106 1.796-.525 4.726-.535 6.634-.023 1.759.472 3.564.489 4.61.043.696-.298.59-.32-1.07-.226-1.83.103-1.852.096-3.683-1.16-1.013-.694-2.318-1.413-2.9-1.596l-1.058-.333.988-.018c.544-.01 2.135.28 3.535.644 2.6.675 4.605.856 4.605.415 0-.347-1.479-1.36-2.616-1.791-.935-.355-.915-.361.9-.261 2.1.115 3.862.79 4.957 1.899.72.729.727.73.727.13 0-.934-1.81-2.484-3.47-2.973-1.732-.51-.9-.598.957-.102 2.68.716 5.39 2.515 6.21 4.124.295.578.537 1.15.537 1.273 0 .122-1.102.361-2.448.532s-3.511.671-4.812 1.112c-3.03 1.027-4.41 1.017-7.16-.05m-83.06-2.246c-.331-4.672.95-8.655 3.622-11.257l1.343-1.308.418.754c.31.56.419 1.506.419 3.664 0 2.803-.036 2.984-.958 4.895-.887 1.84-3.687 5.524-4.365 5.745-.197.064-.358-.772-.48-2.493m125.87-.33c-.464-.283-1.05-.829-1.301-1.212-.556-.848-.22-1.17 1.221-1.176 1.652-.007 4.104 1.78 3.588 2.615-.3.486-2.579.34-3.507-.227m-104.922-.902c-1.831-.683-4.166-2.965-3.74-3.655.203-.328 3.603-.26 4.628.093.494.17 1.341.6 1.882.955 1.055.692 2.477 2.374 2.223 2.628-.352.353-4.033.337-4.993-.021m.993-5.296c-.727-.191-2.034-.56-2.902-.82l-1.58-.473.898-.75c2.53-2.112 6.92-3.595 9.62-3.25 1.876.239 3.85 1.003 4.937 1.91l.907.758-1.14.825c-1.943 1.409-3.805 1.977-6.771 2.068-1.607.05-3.165-.056-3.969-.268" style="fill:teal;stroke-width:.264583"></path></svg>
`)}`;
var BiatecWallet = class extends WalletConnect {
  static defaultMetadata = {
    name: "BiatecWallet",
    icon: ICON2
  };
};

// src/wallets/custom.ts
var ICON3 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
  <rect width="24" height="24" fill="#525252" />
</svg>
`)}`;
var CustomWallet = class extends BaseWallet {
  provider;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options,
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    if (!options?.provider) {
      this.logger.error("Missing required option: provider");
      throw new Error("Missing required option: provider");
    }
    this.provider = options.provider;
    this.store = store;
  }
  static defaultMetadata = {
    name: "Custom",
    icon: ICON3
  };
  connect = async (args) => {
    this.logger.info("Connecting...");
    try {
      if (!this.provider.connect) {
        this.logger.error("Method not supported: connect");
        throw new Error("Method not supported: connect");
      }
      const walletAccounts = await this.provider.connect(args);
      if (walletAccounts.length === 0) {
        this.logger.error("No accounts found!");
        throw new Error("No accounts found!");
      }
      const activeAccount = walletAccounts[0];
      const walletState = {
        accounts: walletAccounts,
        activeAccount
      };
      addWallet(this.store, {
        walletId: this.id,
        wallet: walletState
      });
      this.logger.info("\u2705 Connected.", walletState);
      return walletAccounts;
    } catch (error) {
      this.logger.error("Error connecting:", error.message || error);
      throw error;
    }
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    this.onDisconnect();
    await this.provider.disconnect?.();
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      const result = await this.provider.resumeSession?.();
      if (Array.isArray(result)) {
        const walletAccounts = result;
        if (walletAccounts.length === 0) {
          this.logger.error("No accounts found!");
          throw new Error("No accounts found!");
        }
        const match = compareAccounts(walletAccounts, walletState.accounts);
        if (!match) {
          this.logger.warn("Session accounts mismatch, updating accounts", {
            prev: walletState.accounts,
            current: walletAccounts
          });
          setAccounts(this.store, {
            walletId: this.id,
            accounts: walletAccounts
          });
        }
      }
      this.logger.info("Session resumed.");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      throw error;
    }
  };
  signTransactions = async (txnGroup, indexesToSign) => {
    if (!this.provider.signTransactions) {
      this.logger.error("Method not supported: signTransactions");
      throw new Error("Method not supported: signTransactions");
    }
    this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
    return await this.provider.signTransactions(txnGroup, indexesToSign);
  };
  transactionSigner = async (txnGroup, indexesToSign) => {
    if (!this.provider.transactionSigner) {
      this.logger.error("Method not supported: transactionSigner");
      throw new Error("Method not supported: transactionSigner");
    }
    this.logger.debug("Transaction signer called...", { txnGroup, indexesToSign });
    return await this.provider.transactionSigner(txnGroup, indexesToSign);
  };
  signData = async (data, metadata) => {
    if (!this.provider.signData) {
      this.logger.error("Method not supported: signData");
      throw new Error("Method not supported: signData");
    }
    this.logger.debug("Signing data...", { data, metadata });
    return await this.provider.signData(data, metadata);
  };
};

// src/wallets/defly.ts
import algosdk3 from "algosdk";
var ICON4 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg">
  <rect width="1024" height="1024" />
  <path fill="#FFFFFF" d="M779.9,684.4L512,230L244.1,684.4L512,529.5L779.9,684.4z" />
  <path fill="#FFFFFF" d="M733.1,730L512,613.5L290.9,730L512,658L733.1,730z" />
</svg>
`)}`;
var DeflyWallet = class extends BaseWallet {
  client = null;
  options;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options = {},
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    this.options = options;
    this.store = store;
  }
  static defaultMetadata = {
    name: "Defly",
    icon: ICON4
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    const { DeflyWalletConnect } = await import("@blockshake/defly-connect");
    const client = new DeflyWalletConnect(this.options);
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    const currentActiveWallet = this.store.state.activeWallet;
    if (currentActiveWallet && currentActiveWallet !== this.id) {
      this.manageWalletConnectSession("backup", currentActiveWallet);
    }
    const client = this.client || await this.initializeClient();
    const accounts = await client.connect();
    client.connector?.on("disconnect", this.onDisconnect);
    if (accounts.length === 0) {
      this.logger.error("No accounts found!");
      throw new Error("No accounts found!");
    }
    const walletAccounts = accounts.map((address, idx) => ({
      name: `${this.metadata.name} Account ${idx + 1}`,
      address
    }));
    const activeAccount = walletAccounts[0];
    const walletState = {
      accounts: walletAccounts,
      activeAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("\u2705 Connected.", walletState);
    return walletAccounts;
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    const client = this.client || await this.initializeClient();
    const currentActiveWallet = this.store.state.activeWallet;
    if (currentActiveWallet && currentActiveWallet !== this.id) {
      this.manageWalletConnectSession("backup", currentActiveWallet);
      this.manageWalletConnectSession("restore", this.id);
      await client.disconnect();
      await new Promise((resolve) => setTimeout(resolve, 500));
      this.manageWalletConnectSession("restore", currentActiveWallet);
    } else {
      await client.disconnect();
    }
    this.onDisconnect();
    this.logger.info("Disconnected");
  };
  setActive = () => {
    this.logger.info(`Set active wallet: ${this.id}`);
    const currentActiveWallet = this.store.state.activeWallet;
    if (currentActiveWallet && currentActiveWallet === "pera" /* PERA */) {
      this.manageWalletConnectSession("backup", currentActiveWallet);
    }
    this.manageWalletConnectSession("restore");
    setActiveWallet(this.store, { walletId: this.id });
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      if (state.activeWallet === "pera" /* PERA */) {
        this.logger.info("Skipping reconnectSession for Defly (inactive)");
        return;
      }
      this.logger.info("Resuming session...");
      const client = this.client || await this.initializeClient();
      const accounts = await client.reconnectSession();
      if (accounts.length === 0) {
        this.logger.error("No accounts found!");
        throw new Error("No accounts found!");
      }
      const walletAccounts = accounts.map((address, idx) => ({
        name: `${this.metadata.name} Account ${idx + 1}`,
        address
      }));
      const match = compareAccounts(walletAccounts, walletState.accounts);
      if (!match) {
        this.logger.warn("Session accounts mismatch, updating accounts", {
          prev: walletState.accounts,
          current: walletAccounts
        });
        setAccounts(this.store, {
          walletId: this.id,
          accounts: walletAccounts
        });
      }
      this.logger.info("Session resumed");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn });
      } else {
        txnsToSign.push({ txn, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk3.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk3.decodeSignedTransaction(txnBuffer).txn : algosdk3.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn });
      } else {
        txnsToSign.push({ txn, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", [txnsToSign]);
      const signedTxns = await client.signTransaction([txnsToSign]);
      this.logger.debug("Received signed transactions from wallet", signedTxns);
      const result = txnsToSign.reduce((acc, txn) => {
        if (txn.signers && txn.signers.length == 0) {
          acc.push(null);
        } else {
          const signedTxn = signedTxns.shift();
          if (signedTxn) {
            acc.push(signedTxn);
          }
        }
        return acc;
      }, []);
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/wallets/avm-web-provider.ts
import algosdk4 from "algosdk";
function isAVMWebProviderSDKError(error) {
  return typeof error === "object" && "code" in error && "message" in error;
}
var AVMProvider = class extends BaseWallet {
  avmWebClient = null;
  avmWebProviderSDK = null;
  providerId;
  constructor(args) {
    super(args);
    this.providerId = args.providerId;
  }
  async _initializeAVMWebProviderSDK() {
    if (!this.avmWebProviderSDK) {
      this.logger.info("Initializing @agoralabs-sh/avm-web-provider...");
      const module = await import("@agoralabs-sh/avm-web-provider");
      this.avmWebProviderSDK = module.default ? module.default : module;
      if (!this.avmWebProviderSDK) {
        throw new Error(
          "Failed to initialize, the @agoralabs-sh/avm-web-provider SDK was not provided"
        );
      }
      if (!this.avmWebProviderSDK.AVMWebClient) {
        throw new Error(
          "Failed to initialize, AVMWebClient missing from @agoralabs-sh/avm-web-provider SDK"
        );
      }
      this.logger.info("@agoralabs-sh/avm-web-provider SDK initialized");
    }
    return this.avmWebProviderSDK;
  }
  async _initializeAVMWebClient() {
    const avmWebProviderSDK = await this._initializeAVMWebProviderSDK();
    if (!avmWebProviderSDK.AVMWebClient) {
      throw new Error("Failed to initialize, AVMWebClient not found");
    }
    if (!this.avmWebClient) {
      this.logger.info("Initializing new AVM Web Client...");
      this.avmWebClient = avmWebProviderSDK.AVMWebClient.init();
      this.logger.info("AVM Web Client initialized");
    }
    return this.avmWebClient;
  }
  async _getGenesisHash() {
    const network = this.activeNetworkConfig;
    if (network.genesisHash) {
      return network.genesisHash;
    }
    const algodClient = this.getAlgodClient();
    const version = await algodClient.versionsCheck().do();
    return algosdk4.bytesToBase64(version.genesisHashB64);
  }
  _mapAVMWebProviderAccountToWalletAccounts(accounts) {
    return accounts.map(({ address, name }, idx) => ({
      name: name || `[${this.metadata.name}] Account ${idx + 1}`,
      address
    }));
  }
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk4.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk4.decodeSignedTransaction(txnBuffer).txn : algosdk4.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  /**
   * Common methods
   * These methods can be overridden by specific wallet providers if needed
   */
  async connect() {
    try {
      this.logger.info("Connecting...");
      const result = await this._enable();
      this.logger.info(`Successfully connected on network "${result.genesisId}"`);
      const walletAccounts = this._mapAVMWebProviderAccountToWalletAccounts(result.accounts);
      const walletState = {
        accounts: walletAccounts,
        activeAccount: walletAccounts[0]
      };
      addWallet(this.store, {
        walletId: this.id,
        wallet: walletState
      });
      this.logger.info("\u2705 Connected.", walletState);
      return walletAccounts;
    } catch (error) {
      this.logger.error(
        "Error connecting: ",
        isAVMWebProviderSDKError(error) ? `${error.message} (code: ${error.code})` : error.message
      );
      throw error;
    }
  }
  async disconnect() {
    try {
      this.logger.info("Disconnecting...");
      this.onDisconnect();
      const result = await this._disable();
      this.logger.info(
        `Successfully disconnected${result.sessionIds && result.sessionIds.length ? ` sessions [${result.sessionIds.join(",")}]` : ""} on network "${result.genesisId}"`
      );
    } catch (error) {
      this.logger.error(
        "Error disconnecting: ",
        isAVMWebProviderSDKError(error) ? `${error.message} (code: ${error.code})` : error.message
      );
      throw error;
    }
  }
  async resumeSession() {
    const state = this.store.state;
    const walletState = state.wallets[this.id];
    if (!walletState) {
      this.logger.info("No session to resume");
      return;
    }
    try {
      this.logger.info("Resuming session...");
      const result = await this._enable();
      if (result.accounts.length === 0) {
        throw new Error("No accounts found!");
      }
      const walletAccounts = this._mapAVMWebProviderAccountToWalletAccounts(result.accounts);
      const match = compareAccounts(walletAccounts, walletState.accounts);
      if (!match) {
        this.logger.warn("Session accounts mismatch, updating accounts", {
          prev: walletState.accounts,
          current: walletAccounts
        });
        setAccounts(this.store, {
          walletId: this.id,
          accounts: walletAccounts
        });
      }
      this.logger.info("Session resumed successfully");
    } catch (error) {
      this.logger.error(
        "Error resuming session: ",
        isAVMWebProviderSDKError(error) ? `${error.message} (code: ${error.code})` : error.message
      );
      this.onDisconnect();
      throw error;
    }
  }
  async signTransactions(txnGroup, indexesToSign) {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      this.logger.debug("Sending processed transactions to wallet...", txnsToSign);
      const signTxnsResult = await this._signTransactions(txnsToSign);
      this.logger.debug("Received signed transactions from wallet", signTxnsResult);
      const result = signTxnsResult.stxns.map((value) => {
        if (value === null) {
          return null;
        }
        return base64ToByteArray(value);
      });
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error(
        "Error signing transactions: ",
        isAVMWebProviderSDKError(error) ? `${error.message} (code: ${error.code})` : error.message
      );
      throw error;
    }
  }
};

// src/wallets/defly-web.ts
var DEFLY_WEB_PROVIDER_ID = "95426e60-5f2e-49e9-b912-c488577be962";
var ICON5 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg">
  <rect width="1024" height="1024" />
  <path fill="#FFFFFF" d="M779.9,684.4L512,230L244.1,684.4L512,529.5L779.9,684.4z" />
  <path fill="#FFFFFF" d="M733.1,730L512,613.5L290.9,730L512,658L733.1,730z" />
</svg>
`)}`;
var DeflyWebWallet = class extends AVMProvider {
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    metadata = {}
  }) {
    super({
      id,
      metadata,
      getAlgodClient,
      store,
      subscribe,
      providerId: DEFLY_WEB_PROVIDER_ID
    });
  }
  static defaultMetadata = {
    name: "Defly Web Wallet",
    icon: ICON5
  };
  /**
   * Calls the "enable" method on the provider. This method will timeout after 3 minutes.
   * @returns {Promise<AVMWebProviderSDK.IEnableResult>} a promise that resolves to the result.
   * @protected
   * @throws {MethodCanceledError} if the method was cancelled by the user.
   * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
   * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
   * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
   * @throws {UnknownError} if the response result is empty.
   */
  async _enable() {
    const {
      ARC0027MethodEnum,
      ARC0027MethodTimedOutError,
      ARC0027UnknownError,
      DEFAULT_REQUEST_TIMEOUT
    } = await this._initializeAVMWebProviderSDK();
    const avmWebClient = await this._initializeAVMWebClient();
    const genesisHash = await this._getGenesisHash();
    return new Promise((resolve, reject) => {
      const timerId = window.setTimeout(() => {
        avmWebClient.removeListener(listenerId);
        reject(
          new ARC0027MethodTimedOutError({
            method: ARC0027MethodEnum.Enable,
            message: `no response from provider "${this.metadata.name}"`,
            providerId: DEFLY_WEB_PROVIDER_ID
          })
        );
      }, DEFAULT_REQUEST_TIMEOUT);
      const listenerId = avmWebClient.onEnable(({ error, method, result }) => {
        avmWebClient.removeListener(listenerId);
        window.clearTimeout(timerId);
        if (error) {
          return reject(error);
        }
        if (!result) {
          return reject(
            new ARC0027UnknownError({
              message: `received response, but "${method}" request details were empty for provider "${this.metadata.name}"`,
              providerId: DEFLY_WEB_PROVIDER_ID
            })
          );
        }
        return resolve(result);
      });
      avmWebClient.enable({
        genesisHash,
        providerId: DEFLY_WEB_PROVIDER_ID
      });
    });
  }
  /**
   * Calls the "disable" method on the provider. This method will timeout after 0.75 seconds.
   * @returns {Promise<AVMWebProviderSDK.IDisableResult>} a promise that resolves to the result.
   * @protected
   * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
   * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
   * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
   * @throws {UnknownError} if the response result is empty.
   */
  async _disable() {
    const {
      ARC0027MethodEnum,
      ARC0027MethodTimedOutError,
      ARC0027UnknownError,
      LOWER_REQUEST_TIMEOUT
    } = await this._initializeAVMWebProviderSDK();
    const avmWebClient = await this._initializeAVMWebClient();
    const genesisHash = await this._getGenesisHash();
    return new Promise((resolve, reject) => {
      const timerId = window.setTimeout(() => {
        avmWebClient.removeListener(listenerId);
        reject(
          new ARC0027MethodTimedOutError({
            method: ARC0027MethodEnum.Disable,
            message: `no response from provider "${this.metadata.name}"`,
            providerId: DEFLY_WEB_PROVIDER_ID
          })
        );
      }, LOWER_REQUEST_TIMEOUT);
      const listenerId = avmWebClient.onDisable(({ error, method, result }) => {
        avmWebClient.removeListener(listenerId);
        window.clearTimeout(timerId);
        if (error) {
          return reject(error);
        }
        if (!result) {
          return reject(
            new ARC0027UnknownError({
              message: `received response, but "${method}" request details were empty for provider "${this.metadata.name}"`,
              providerId: DEFLY_WEB_PROVIDER_ID
            })
          );
        }
        this.logger.debug("Disable successful", { result });
        return resolve(result);
      });
      this.logger.debug("Sending disable request...", { genesisHash });
      avmWebClient.disable({
        genesisHash,
        providerId: DEFLY_WEB_PROVIDER_ID
      });
    });
  }
  /**
   * Calls the "signTransactions" method to sign the supplied ARC-0001 transactions. This method will timeout after 3
   * minutes.
   * @returns {Promise<AVMWebProviderSDK.ISignTransactionsResult>} a promise that resolves to the result.
   * @protected
   * @throws {InvalidInputError} if computed group ID for the txns does not match the assigned group ID.
   * @throws {InvalidGroupIdError} if the unsigned txns is malformed or not conforming to ARC-0001.
   * @throws {MethodCanceledError} if the method was cancelled by the user.
   * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
   * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
   * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
   * @throws {UnauthorizedSignerError} if a signer in the request is not authorized by the provider.
   * @throws {UnknownError} if the response result is empty.
   */
  async _signTransactions(txns) {
    const {
      ARC0027MethodEnum,
      ARC0027MethodTimedOutError,
      ARC0027UnknownError,
      DEFAULT_REQUEST_TIMEOUT
    } = await this._initializeAVMWebProviderSDK();
    const avmWebClient = await this._initializeAVMWebClient();
    return new Promise((resolve, reject) => {
      const timerId = window.setTimeout(() => {
        avmWebClient.removeListener(listenerId);
        reject(
          new ARC0027MethodTimedOutError({
            method: ARC0027MethodEnum.SignTransactions,
            message: `no response from provider "${this.metadata.name}"`,
            providerId: DEFLY_WEB_PROVIDER_ID
          })
        );
      }, DEFAULT_REQUEST_TIMEOUT);
      const listenerId = avmWebClient.onSignTransactions(({ error, method, result }) => {
        avmWebClient.removeListener(listenerId);
        window.clearTimeout(timerId);
        if (error) {
          return reject(error);
        }
        if (!result) {
          return reject(
            new ARC0027UnknownError({
              message: `received response, but "${method}" request details were empty for provider "${this.metadata.name}"`,
              providerId: DEFLY_WEB_PROVIDER_ID
            })
          );
        }
        this.logger.debug("Sign transactions successful", { result });
        return resolve(result);
      });
      this.logger.debug("Sending sign transactions request...", { txns });
      avmWebClient.signTransactions({
        txns,
        providerId: DEFLY_WEB_PROVIDER_ID
      });
    });
  }
};

// src/wallets/exodus.ts
import algosdk5 from "algosdk";
var ICON6 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
  <linearGradient id="grad1" gradientUnits="userSpaceOnUse" x1="246.603" y1="9.2212" x2="174.158" y2="308.5426" gradientTransform="matrix(1 0 0 -1 0 302)">
    <stop offset="0" stop-color="#0B46F9" />
    <stop offset="1" stop-color="#BBFBE0" />
  </linearGradient>
  <path fill="url(#grad1)" d="M274.7,93.9L166.6,23v39.6l69.4,45.1l-8.2,25.8h-61.2v32.9h61.2l8.2,25.8l-69.4,45.1V277l108.2-70.7L257,150.1L274.7,93.9z" />
  
  <linearGradient id="grad2" gradientUnits="userSpaceOnUse" x1="129.3516" y1="-19.1573" x2="56.9066" y2="280.1641" gradientTransform="matrix(1 0 0 -1 0 302)">
    <stop offset="0" stop-color="#0B46F9" />
    <stop offset="1" stop-color="#BBFBE0" />
  </linearGradient>
  <path fill="url(#grad2)" d="M72.5,166.4h61v-32.9H72.2l-7.9-25.8l69.2-45.1V23L25.3,93.9L43,150.1l-17.7,56.2L133.7,277v-39.6l-69.4-45.1L72.5,166.4z" />
  
  <mask id="mask1" maskUnits="userSpaceOnUse" x="25.4" y="23" width="247.6" height="254">
    <path fill="url(#grad1)" d="M274.7,93.9L166.6,23v39.6l69.4,45.1l-8.2,25.8h-61.2v32.9h61.2l8.2,25.8l-69.4,45.1V277l108.2-70.7L257,150.1L274.7,93.9z" />
    <path fill="url(#grad2)" d="M72.5,166.4h61v-32.9H72.2l-7.9-25.8l69.2-45.1V23L25.3,93.9L43,150.1l-17.7,56.2L133.7,277v-39.6l-69.4-45.1L72.5,166.4z" />
  </mask>
  
  <linearGradient id="grad3" gradientUnits="userSpaceOnUse" x1="46.4662" y1="228.7554" x2="171.8638" y2="135.1039" gradientTransform="matrix(1 0 0 -1 0 302)">
    <stop offset="0.1198" stop-color="#8952FF" stop-opacity="0.87" />
    <stop offset="1" stop-color="#DABDFF" stop-opacity="0" />
  </linearGradient>
  <rect x="25.4" y="23" width="247.6" height="254" fill="url(#grad3)" mask="url(#mask1)" />
</svg>
`)}`;
var ExodusWallet = class extends BaseWallet {
  client = null;
  options;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options = {},
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    this.options = options;
    this.store = store;
  }
  static defaultMetadata = {
    name: "Exodus",
    icon: ICON6
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    if (typeof window === "undefined" || window.algorand === void 0) {
      this.logger.error("Exodus is not available.");
      throw new Error("Exodus is not available.");
    }
    const client = window.algorand;
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    const client = this.client || await this.initializeClient();
    const { accounts } = await client.enable(this.options);
    if (accounts.length === 0) {
      this.logger.error("No accounts found!");
      throw new Error("No accounts found!");
    }
    const walletAccounts = accounts.map((address, idx) => ({
      name: `${this.metadata.name} Account ${idx + 1}`,
      address
    }));
    const activeAccount = walletAccounts[0];
    const walletState = {
      accounts: walletAccounts,
      activeAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("\u2705 Connected.", walletState);
    return walletAccounts;
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    this.onDisconnect();
    this.logger.info("Disconnected.");
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      const client = await this.initializeClient();
      if (!client.isConnected) {
        this.logger.error("Exodus is not connected.");
        throw new Error("Exodus is not connected.");
      }
      this.logger.info("Session resumed");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk5.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk5.decodeSignedTransaction(txnBuffer).txn : algosdk5.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", txnsToSign);
      const signTxnsResult = await client.signTxns(txnsToSign);
      this.logger.debug("Received signed transactions from wallet", signTxnsResult);
      const result = signTxnsResult.map((value) => {
        if (value === null) {
          return null;
        }
        return base64ToByteArray(value);
      });
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/wallets/kibisis.ts
var KIBISIS_AVM_WEB_PROVIDER_ID = "f6d1c86b-4493-42fb-b88d-a62407b4cdf6";
var ICON7 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 480 480" xmlns="http://www.w3.org/2000/svg">
  <rect fill="#801C96" width="480" height="480" />
  <path fill="#FFFFFF" d="M393.5,223.2c0-7.3-0.6-14.6-1.6-21.6c-0.9-6.5-2.3-12.8-4-18.9c-18-64.9-77.4-112.5-148-112.5c-70.6,0-130,47.6-148,112.5c-1.7,6.2-3,12.5-4,19c-1,7.1-1.6,14.3-1.6,21.6h0v85.5h19.7v-85.5c0-7.2,0.6-14.4,1.8-21.4c14,1.1,27.6,4.3,40.5,9.5c15.9,6.4,30.3,15.6,42.6,27.3c12.3,11.7,22,25.4,28.7,40.6c6.9,15.6,10.5,32.2,10.5,49.2v81.4h0.1h19.6h0.1v-81.5c0.1-17.1,3.6-33.7,10.5-49.2c6.7-15.2,16.4-28.8,28.7-40.6c4.2-4,8.6-7.7,13.2-11.1v132.2h19.7V223.2h0c0-2.5-0.1-5-0.4-7.4c3.3-1.6,6.6-3.1,10-4.5c12.9-5.2,26.4-8.4,40.4-9.5c1.2,7,1.7,14.2,1.8,21.4v85.5h19.7L393.5,223.2L393.5,223.2z M240.1,277.3c-11.6-29.3-32.7-54.1-59.8-71c2.9-10,8.2-19.1,15.8-26.6c11.8-11.8,27.4-18.2,44-18.2s32.3,6.5,44,18.2c4.1,4.1,7.5,8.7,10.3,13.6c5.6-3.4,11.4-6.4,17.4-9.2c-14-25.2-40.9-42.3-71.8-42.3c-35.9,0-66.3,23-77.5,55.1c-15.5-7.1-32.5-11.8-50.4-13.5c1.3-4,2.7-7.9,4.3-11.8c6.7-15.9,16.4-30.3,28.7-42.6s26.6-22,42.6-28.7c16.5-7,34-10.5,52.1-10.5s35.6,3.5,52.1,10.5c15.9,6.7,30.3,16.4,42.6,28.7s22,26.6,28.7,42.6c1.6,3.9,3.1,7.8,4.3,11.8C309,189.2,260.1,226.5,240.1,277.3z" />
  <path fill="#FFFFFF" d="M158.1,359.8h19.7V245.5c-6.1-5.4-12.7-10-19.7-14V359.8z" />
</svg>
`)}`;
var KibisisWallet = class extends AVMProvider {
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    metadata = {}
  }) {
    super({
      id,
      metadata,
      getAlgodClient,
      store,
      subscribe,
      providerId: KIBISIS_AVM_WEB_PROVIDER_ID
    });
  }
  static defaultMetadata = {
    name: "Kibisis",
    icon: ICON7
  };
  /**
   * Calls the "enable" method on the provider. This method will timeout after 3 minutes.
   * @returns {Promise<AVMWebProviderSDK.IEnableResult>} a promise that resolves to the result.
   * @protected
   * @throws {MethodCanceledError} if the method was cancelled by the user.
   * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
   * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
   * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
   * @throws {UnknownError} if the response result is empty.
   */
  async _enable() {
    const {
      ARC0027MethodEnum,
      ARC0027MethodTimedOutError,
      ARC0027UnknownError,
      DEFAULT_REQUEST_TIMEOUT
    } = await this._initializeAVMWebProviderSDK();
    const avmWebClient = await this._initializeAVMWebClient();
    const genesisHash = await this._getGenesisHash();
    return new Promise((resolve, reject) => {
      const timerId = window.setTimeout(() => {
        avmWebClient.removeListener(listenerId);
        reject(
          new ARC0027MethodTimedOutError({
            method: ARC0027MethodEnum.Enable,
            message: `no response from provider "${this.metadata.name}"`,
            providerId: KIBISIS_AVM_WEB_PROVIDER_ID
          })
        );
      }, DEFAULT_REQUEST_TIMEOUT);
      const listenerId = avmWebClient.onEnable(({ error, method, result }) => {
        avmWebClient.removeListener(listenerId);
        window.clearTimeout(timerId);
        if (error) {
          return reject(error);
        }
        if (!result) {
          return reject(
            new ARC0027UnknownError({
              message: `received response, but "${method}" request details were empty for provider "${this.metadata.name}"`,
              providerId: KIBISIS_AVM_WEB_PROVIDER_ID
            })
          );
        }
        return resolve(result);
      });
      avmWebClient.enable({
        genesisHash,
        providerId: KIBISIS_AVM_WEB_PROVIDER_ID
      });
    });
  }
  /**
   * Calls the "disable" method on the provider. This method will timeout after 0.75 seconds.
   * @returns {Promise<AVMWebProviderSDK.IDisableResult>} a promise that resolves to the result.
   * @protected
   * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
   * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
   * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
   * @throws {UnknownError} if the response result is empty.
   */
  async _disable() {
    const {
      ARC0027MethodEnum,
      ARC0027MethodTimedOutError,
      ARC0027UnknownError,
      LOWER_REQUEST_TIMEOUT
    } = await this._initializeAVMWebProviderSDK();
    const avmWebClient = await this._initializeAVMWebClient();
    const genesisHash = await this._getGenesisHash();
    return new Promise((resolve, reject) => {
      const timerId = window.setTimeout(() => {
        avmWebClient.removeListener(listenerId);
        reject(
          new ARC0027MethodTimedOutError({
            method: ARC0027MethodEnum.Disable,
            message: `no response from provider "${this.metadata.name}"`,
            providerId: KIBISIS_AVM_WEB_PROVIDER_ID
          })
        );
      }, LOWER_REQUEST_TIMEOUT);
      const listenerId = avmWebClient.onDisable(({ error, method, result }) => {
        avmWebClient.removeListener(listenerId);
        window.clearTimeout(timerId);
        if (error) {
          return reject(error);
        }
        if (!result) {
          return reject(
            new ARC0027UnknownError({
              message: `received response, but "${method}" request details were empty for provider "${this.metadata.name}"`,
              providerId: KIBISIS_AVM_WEB_PROVIDER_ID
            })
          );
        }
        this.logger.debug("Disable successful", { result });
        return resolve(result);
      });
      this.logger.debug("Sending disable request...", { genesisHash });
      avmWebClient.disable({
        genesisHash,
        providerId: KIBISIS_AVM_WEB_PROVIDER_ID
      });
    });
  }
  /**
   * Calls the "signTransactions" method to sign the supplied ARC-0001 transactions. This method will timeout after 3
   * minutes.
   * @returns {Promise<AVMWebProviderSDK.ISignTransactionsResult>} a promise that resolves to the result.
   * @protected
   * @throws {InvalidInputError} if computed group ID for the txns does not match the assigned group ID.
   * @throws {InvalidGroupIdError} if the unsigned txns is malformed or not conforming to ARC-0001.
   * @throws {MethodCanceledError} if the method was cancelled by the user.
   * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
   * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
   * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
   * @throws {UnauthorizedSignerError} if a signer in the request is not authorized by the provider.
   * @throws {UnknownError} if the response result is empty.
   */
  async _signTransactions(txns) {
    const {
      ARC0027MethodEnum,
      ARC0027MethodTimedOutError,
      ARC0027UnknownError,
      DEFAULT_REQUEST_TIMEOUT
    } = await this._initializeAVMWebProviderSDK();
    const avmWebClient = await this._initializeAVMWebClient();
    return new Promise((resolve, reject) => {
      const timerId = window.setTimeout(() => {
        avmWebClient.removeListener(listenerId);
        reject(
          new ARC0027MethodTimedOutError({
            method: ARC0027MethodEnum.SignTransactions,
            message: `no response from provider "${this.metadata.name}"`,
            providerId: KIBISIS_AVM_WEB_PROVIDER_ID
          })
        );
      }, DEFAULT_REQUEST_TIMEOUT);
      const listenerId = avmWebClient.onSignTransactions(({ error, method, result }) => {
        avmWebClient.removeListener(listenerId);
        window.clearTimeout(timerId);
        if (error) {
          return reject(error);
        }
        if (!result) {
          return reject(
            new ARC0027UnknownError({
              message: `received response, but "${method}" request details were empty for provider "${this.metadata.name}"`,
              providerId: KIBISIS_AVM_WEB_PROVIDER_ID
            })
          );
        }
        this.logger.debug("Sign transactions successful", { result });
        return resolve(result);
      });
      this.logger.debug("Sending sign transactions request...", { txns });
      avmWebClient.signTransactions({
        txns,
        providerId: KIBISIS_AVM_WEB_PROVIDER_ID
      });
    });
  }
};

// src/wallets/kmd.ts
import algosdk6 from "algosdk";
var ICON8 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
  <linearGradient id="algokitGradient" gradientUnits="userSpaceOnUse" x1="0" y1="400" x2="400" y2="0">
    <stop offset="0" style="stop-color:#31D8EE"/>
    <stop offset="1" style="stop-color:#01DC94"/>
  </linearGradient>
  <rect fill="url(#algokitGradient)" width="400" height="400" />
  <path fill="#FFFFFF" d="M309.2,309.3H275l-22.2-82.7l-47.9,82.7h-38.3l73.9-128l-11.9-44.5l-99.6,172.6H90.8L217.1,90.6 h33.5l14.7,54.3h34.6l-23.6,41L309.2,309.3z" />
</svg>
`)}`;
var KmdWallet = class extends BaseWallet {
  client = null;
  options;
  walletName;
  walletId = "";
  password = null;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options,
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    const {
      token = "a".repeat(64),
      baseServer = "http://127.0.0.1",
      port = 4002,
      wallet = "unencrypted-default-wallet",
      promptForPassword = () => Promise.resolve(prompt("KMD password") || "")
    } = options || {};
    this.options = { token, baseServer, port, promptForPassword };
    this.walletName = wallet;
    this.store = store;
  }
  static defaultMetadata = {
    name: "KMD",
    icon: ICON8
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    const { token, baseServer, port } = this.options;
    const client = new algosdk6.Kmd(token, baseServer, port);
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    if (!this.client) {
      await this.initializeClient();
    }
    try {
      const token = await this.fetchToken();
      const accounts = await this.fetchAccounts(token);
      if (accounts.length === 0) {
        throw new Error("No accounts found!");
      }
      const walletAccounts = accounts.map((address, idx) => ({
        name: `${this.metadata.name} Account ${idx + 1}`,
        address
      }));
      const activeAccount = walletAccounts[0];
      const walletState = {
        accounts: walletAccounts,
        activeAccount
      };
      addWallet(this.store, {
        walletId: this.id,
        wallet: walletState
      });
      await this.releaseToken(token);
      this.logger.info("\u2705 Connected.", walletState);
      return walletAccounts;
    } catch (error) {
      this.logger.error("Error connecting:", error.message);
      throw error;
    }
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    this.onDisconnect();
    this.logger.info("Disconnected.");
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      await this.initializeClient();
      this.logger.info("Session resumed");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push(txn);
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk6.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk6.decodeSignedTransaction(txnBuffer).txn : algosdk6.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push(txn);
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const token = await this.fetchToken();
      const password = await this.getPassword();
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", txnsToSign);
      const signedTxns = await Promise.all(
        txnsToSign.map((txn) => client.signTransaction(token, password, txn))
      );
      this.logger.debug("Received signed transactions from wallet", signedTxns);
      await this.releaseToken(token);
      this.logger.debug("Transactions signed successfully", signedTxns);
      return signedTxns;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
  async fetchWalletId() {
    this.logger.debug("Fetching wallet data...", { walletName: this.walletName });
    const client = this.client || await this.initializeClient();
    const { wallets } = await client.listWallets();
    const wallet = wallets.find((wallet2) => wallet2.name === this.walletName);
    if (!wallet) {
      this.logger.error(`Wallet "${this.walletName}" not found!`);
      throw new Error(`Wallet "${this.walletName}" not found!`);
    }
    this.walletId = wallet.id;
    this.logger.debug("Wallet data fetched successfully", { walletId: this.walletId });
    return wallet.id;
  }
  async fetchToken() {
    this.logger.debug("Fetching token...", { walletId: this.walletId });
    const client = this.client || await this.initializeClient();
    const walletId = this.walletId || await this.fetchWalletId();
    const password = await this.getPassword();
    const { wallet_handle_token } = await client.initWalletHandle(
      walletId,
      password
    );
    this.logger.debug("Token fetched successfully");
    return wallet_handle_token;
  }
  async releaseToken(token) {
    this.logger.debug("Releasing token...");
    const client = this.client || await this.initializeClient();
    await client.releaseWalletHandle(token);
    this.logger.debug("Token released successfully");
  }
  async getPassword() {
    if (this.password !== null) {
      return this.password;
    }
    const password = await this.options.promptForPassword();
    this.password = password;
    return password;
  }
  async fetchAccounts(token) {
    this.logger.debug("Fetching accounts...");
    const client = this.client || await this.initializeClient();
    const { addresses } = await client.listKeys(token);
    this.logger.debug("Accounts fetched successfully", { addresses });
    return addresses;
  }
};

// src/wallets/lute.ts
import algosdk7 from "algosdk";
function isSignTxnsError(error) {
  return error instanceof Error && "code" in error;
}
function isSignDataError(error) {
  return error instanceof Error && "code" in error;
}
var ICON9 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
  <path fill="#AB47BC" d="M283.7,263.6c-0.6,0-1.3-0.1-1.8-0.4c-0.6-0.3-1.1-0.8-1.5-1.3c-0.4-0.6-0.7-1.3-0.8-2 c-0.1-0.8-0.1-1.7,0.1-2.5c0.2-0.9,0.6-1.8,1.2-2.6c0.6-0.8,1.4-1.7,2.2-2.3c0.9-0.7,2.1-1.2,3.2-1.6c1.2-0.4,2.7-0.5,4-0.5 c1.4,0,3,0.3,4.4,0.8c1.5,0.5,3.1,1.4,4.3,2.3c1.4,1,2.8,2.4,3.8,3.7c1.1,1.5,2.1,3.3,2.8,5.1c0.7,1.9,1.2,4.1,1.3,6.1 c0.2,2.1,0,4.6-0.4,6.7c-0.5,2.2-1.4,4.7-2.4,6.7c-1.1,2.1-2.8,4.4-4.4,6.2c-1.8,1.9-4.1,3.7-6.3,5c-2.3,1.4-5.2,2.6-7.9,3.3 c-2.8,0.7-6.1,1.1-8.9,1.1c-3,0-6.5-0.6-9.3-1.4c-3-0.9-6.4-2.4-9.1-4c-2.8-1.7-5.8-4.2-8-6.6c-2.3-2.5-4.6-5.8-6.2-8.9 c-1.7-3.2-3.1-7.1-3.8-10.7c-0.8-3.7-1.1-8-0.9-11.8c0.2-3.9,1.1-8.3,2.3-12c1.3-3.8,3.4-8.1,5.7-11.4c2.3-3.5,5.6-7.1,8.8-9.9 c3.3-2.8,7.5-5.6,11.5-7.5c4.1-1.9,9-3.5,13.5-4.3c4.6-0.8,10-1.1,14.6-0.7c4.8,0.4,10.2,1.6,14.7,3.3c4.7,1.7,9.7,4.4,13.8,7.3 c4.2,3,8.5,7,11.7,10.9c3.3,4.1,6.5,9.2,8.7,14c2.2,4.9,4,10.9,4.9,16.3c0.9,5.5,1,11.9,0.4,17.5c-0.6,5.7-2.2,12.1-4.3,17.4 c-2.1,5.5-5.4,11.4-8.9,16.1c-3.6,4.8-8.4,9.8-13.1,13.6c-4.8,3.8-11,7.5-16.6,9.9c-5.8,2.5-12.8,4.5-19.1,5.4 c-6.4,0.9-13.9,1-20.3,0.2c-6.6-0.8-14-2.7-20.1-5.2c-6.3-2.5-13.1-6.4-18.5-10.5c-5.5-4.2-11.2-9.8-15.4-15.3 c-4.3-5.6-8.4-12.7-11.2-19.2c-2.8-6.7-4.9-14.7-5.9-21.9c-0.9-5.9-2.8-12.6-5.2-18.1c-2.3-5.4-5.9-11.2-9.5-15.8 c-3.6-4.5-8.3-9-13-12.4c-4.5-3.3-10.1-6.4-15.3-8.3c-5-1.9-11.1-3.4-16.5-3.9c-5.2-0.5-11.3-0.3-16.5,0.5c-5,0.8-10.7,2.6-15.3,4.7 c-4.5,2.1-9.4,5.1-13.2,8.3c-3.7,3.1-7.5,7.2-10.2,11.1c-2.7,3.8-5.2,8.6-6.7,13c-1.5,4.2-2.6,9.3-3,13.8c-0.3,4.3-0.1,9.4,0.7,13.7 c0.8,4.1,2.3,8.8,4.2,12.5c1.8,3.6,4.4,7.6,7.1,10.6c2.6,2.9,6,5.9,9.3,8.1c3.1,2.1,7.1,4,10.6,5.1c3.4,1.1,7.5,1.9,11.1,2 c3.5,0.2,7.4-0.2,10.8-1c3.2-0.7,6.8-2.1,9.7-3.6c2.8-1.5,5.7-3.6,8-5.8c2.2-2.1,4.3-4.8,5.9-7.4c1.5-2.5,2.8-5.5,3.5-8.3 c0.7-2.6,1.1-5.7,1.1-8.5c0-2.6-0.5-5.5-1.2-8c-0.7-2.3-1.8-4.9-3.1-6.9c-1.2-1.9-2.9-3.9-4.6-5.4c-1.6-1.4-3.6-2.8-5.5-3.7 c-1.8-0.9-4-1.6-5.9-1.9c-1.8-0.3-3.9-0.4-5.8-0.1c-1.7,0.2-3.6,0.7-5.1,1.4c-1.4,0.6-2.9,1.6-4.1,2.6c-1.1,0.9-2.1,2.2-2.9,3.4 c-0.7,1.1-1.2,2.5-1.5,3.7c-0.3,1.1-0.4,2.4-0.3,3.6c0.1,1,0.4,2.2,0.8,3.1c0.4,0.8,1,1.7,1.6,2.3c0.6,0.5,1.3,1,2.1,1.3 c0.6,0.2,1.5,0.4,2.1,0.3c0.6-0.1,1.3-0.3,1.8-0.6c0.5-0.3,1-0.8,1.2-1.4c0.3-0.5,0.7-1,1.2-1.4c0.5-0.3,1.2-0.6,1.8-0.6 c0.7-0.1,1.5,0.1,2.1,0.3c0.7,0.3,1.5,0.8,2.1,1.3c0.6,0.6,1.3,1.5,1.6,2.3c0.4,0.9,0.7,2.1,0.8,3.1c0.1,1.1,0,2.5-0.3,3.6 c-0.3,1.2-0.9,2.6-1.5,3.7c-0.7,1.2-1.8,2.4-2.9,3.4c-1.2,1-2.7,2-4.1,2.6c-1.5,0.7-3.4,1.2-5.1,1.4c-1.8,0.2-4,0.2-5.8-0.1 c-2-0.3-4.1-1-5.9-1.9c-1.9-0.9-4-2.3-5.5-3.7c-1.7-1.5-3.4-3.5-4.6-5.4c-1.3-2-2.4-4.6-3.1-6.9c-0.7-2.5-1.2-5.4-1.2-8 c0-2.7,0.4-5.8,1.1-8.5c0.7-2.8,2-5.8,3.5-8.3c1.5-2.6,3.7-5.3,5.9-7.4c2.3-2.2,5.2-4.3,8-5.8c2.9-1.6,6.5-2.9,9.7-3.6 c3.4-0.8,7.4-1.1,10.8-1c3.6,0.2,7.7,0.9,11.1,2c3.6,1.2,7.5,3.1,10.6,5.1c3.3,2.1,6.7,5.1,9.3,8.1c2.7,3,5.3,7,7.1,10.6 c1.8,3.8,3.4,8.4,4.2,12.5c0.8,4.3,1.1,9.3,0.7,13.7c-0.4,4.5-1.5,9.6-3,13.8c-1.6,4.4-4.1,9.2-6.7,13c-2.8,3.9-6.5,8-10.2,11.1 c-3.8,3.2-8.7,6.2-13.2,8.3c-4.6,2.1-10.3,3.8-15.3,4.7c-5.2,0.9-11.3,1-16.5,0.5c-5.4-0.5-11.5-2-16.5-3.9 c-5.2-2-10.8-5.1-15.3-8.3c-4.6-3.4-9.4-7.9-13-12.4c-3.7-4.6-7.2-10.4-9.5-15.8c-2.4-5.5-4.3-12.2-5.2-18.1 c-0.9-6.1-1-13.2-0.3-19.3c0.7-6.3,2.5-13.4,4.9-19.2c2.4-6,6.1-12.5,10-17.7c4-5.3,9.3-10.7,14.6-14.8c5.3-4.2,12.1-8.1,18.3-10.7 c6.4-2.7,14.1-4.8,21-5.7c7-1,15.2-1,22.2-0.1c7.2,0.9,15.2,3.1,21.9,5.8c5.6,2.2,12.3,3.9,18.3,4.6c5.8,0.7,12.6,0.5,18.4-0.4 c5.6-0.9,12-2.7,17.2-5c5.1-2.3,10.6-5.6,14.9-9.1c4.2-3.4,8.5-8,11.7-12.3c3.1-4.3,6-9.6,7.8-14.5c1.8-4.8,3.1-10.5,3.6-15.6 c0.5-4.9,0.3-10.7-0.6-15.6c-0.8-4.7-2.5-10.1-4.5-14.4c-2-4.2-4.9-8.8-7.9-12.3c-2.9-3.4-6.8-6.9-10.5-9.5 c-3.6-2.5-8.1-4.8-12.2-6.2c-4-1.4-8.7-2.4-12.9-2.7c-4-0.3-8.7,0-12.7,0.8c-3.8,0.8-8.1,2.2-11.6,4c-3.4,1.7-7,4.1-9.7,6.6 c-2.7,2.4-5.4,5.6-7.3,8.6c-1.9,2.9-3.6,6.5-4.6,9.8c-1,3.2-1.6,6.9-1.7,10.2c-0.1,3.2,0.3,6.8,1,9.9c0.7,2.9,2,6.2,3.5,8.8 c1.4,2.5,3.4,5.1,5.4,7.2c1.9,1.9,4.4,3.8,6.8,5.2c2.2,1.3,5,2.4,7.5,3c2.3,0.6,5.1,0.9,7.6,0.8c2.3-0.1,4.9-0.5,7-1.3 c2-0.7,4.2-1.7,6-2.9c1.6-1.1,3.3-2.7,4.6-4.2c1.2-1.4,2.3-3.2,3-4.9c0.7-1.6,1.2-3.5,1.3-5.1c0.2-1.5,0.1-3.3-0.2-4.9 c-0.3-1.4-0.8-2.9-1.5-4.2c-0.6-1.1-1.5-2.3-2.4-3.2c-0.8-0.8-1.9-1.5-3-2c-0.9-0.4-2.1-0.7-3.1-0.8c-0.9-0.1-1.9,0-2.8,0.3 c-0.7,0.2-1.6,0.6-2.2,1.1c-0.5,0.4-1,1.1-1.3,1.7c-0.3,0.6-0.4,1.3-0.4,1.9c0,0.6,0.2,1.2,0.6,1.7c0.3,0.5,0.5,1.2,0.6,1.7 c0,0.6-0.1,1.3-0.4,1.9c-0.3,0.6-0.8,1.3-1.3,1.7c-0.6,0.5-1.4,0.9-2.2,1.1c-0.9,0.3-1.9,0.3-2.8,0.3c-1-0.1-2.2-0.4-3.1-0.8 c-1-0.5-2.1-1.2-3-2c-0.9-0.9-1.8-2.1-2.4-3.2c-0.7-1.2-1.2-2.8-1.5-4.2c-0.3-1.5-0.4-3.3-0.2-4.9c0.2-1.7,0.7-3.6,1.3-5.1 c0.7-1.7,1.8-3.5,3-4.9c1.3-1.5,3-3.1,4.6-4.2c1.8-1.2,4-2.3,6-2.9c2.2-0.7,4.8-1.2,7-1.3c2.4-0.1,5.2,0.2,7.6,0.8 c2.5,0.6,5.3,1.7,7.5,3c2.4,1.3,4.9,3.2,6.8,5.2c2,2,4,4.7,5.4,7.2c1.5,2.6,2.7,5.9,3.5,8.8c0.8,3.1,1.1,6.7,1,9.9 c-0.1,3.3-0.7,7.1-1.7,10.2c-1,3.3-2.7,6.9-4.6,9.8c-1.9,3-4.7,6.2-7.3,8.6c-2.8,2.5-6.4,5-9.7,6.6c-3.5,1.8-7.8,3.2-11.6,4 c-4,0.8-8.7,1.1-12.7,0.8c-4.2-0.3-9-1.3-12.9-2.7c-4.1-1.4-8.6-3.7-12.2-6.2c-3.7-2.6-7.6-6.1-10.5-9.5c-3-3.6-5.9-8.1-7.9-12.3 c-2-4.4-3.7-9.7-4.5-14.4c-0.8-4.9-1.1-10.6-0.6-15.6c0.5-5.1,1.8-10.8,3.6-15.6c1.8-4.9,4.7-10.3,7.8-14.5 c3.2-4.4,7.5-8.9,11.7-12.3c4.3-3.5,9.8-6.9,14.9-9.1c5.2-2.3,11.6-4.2,17.2-5c5.8-0.9,12.6-1,18.4-0.4c6,0.7,12.7,2.4,18.3,4.6 c5.7,2.3,12,5.7,16.9,9.4c5.1,3.8,10.3,8.9,14.2,13.8c4,5.1,7.8,11.5,10.3,17.5c2.6,6.1,4.6,13.5,5.5,20c0.9,6.7,1,14.5,0.1,21.2 c-0.9,6.9-2.9,14.6-5.5,21c-2.7,6.5-6.8,13.6-11,19.3c-4.4,5.7-10.3,11.7-16,16c-4.7,3.7-9.5,8.7-13.1,13.6 c-3.5,4.7-6.8,10.7-8.9,16.1c-2.1,5.3-3.6,11.7-4.3,17.4c-0.6,5.5-0.4,12,0.4,17.5c0.9,5.3,2.6,11.3,4.9,16.3c2.2,4.8,5.4,10,8.7,14 c3.2,3.9,7.6,8,11.7,10.9c4,2.9,9.1,5.6,13.8,7.3c4.5,1.7,9.9,2.9,14.7,3.3c4.6,0.4,10,0.2,14.6-0.7c4.4-0.8,9.4-2.4,13.5-4.3 c3.9-1.9,8.2-4.6,11.5-7.5c3.2-2.7,6.4-6.4,8.8-9.9c2.3-3.4,4.4-7.6,5.7-11.4c1.2-3.7,2.1-8.1,2.3-12c0.2-3.7-0.1-8.1-0.9-11.8 c-0.8-3.5-2.2-7.5-3.8-10.7c-1.6-3.1-3.9-6.3-6.2-8.9c-2.2-2.4-5.2-4.9-8-6.6c-2.7-1.7-6-3.2-9.1-4c-2.9-0.8-6.3-1.4-9.3-1.4 c-2.9,0-6.2,0.4-8.9,1.1c-2.6,0.7-5.5,1.9-7.9,3.3c-2.2,1.3-4.5,3.2-6.3,5c-1.7,1.8-3.3,4-4.4,6.2c-1.1,2-2,4.5-2.4,6.7 c-0.4,2.1-0.6,4.5-0.4,6.7c0.2,2,0.6,4.2,1.3,6.1c0.6,1.7,1.7,3.6,2.8,5.1c1,1.3,2.4,2.7,3.8,3.7c1.3,0.9,2.8,1.8,4.3,2.3 c1.3,0.5,2.9,0.8,4.4,0.8c1.3,0,2.7-0.1,4-0.5c1.1-0.3,2.3-0.9,3.2-1.6c0.8-0.6,1.7-1.4,2.2-2.3c0.5-0.7,0.9-1.7,1.2-2.6 c0.2-0.8,0.2-1.7,0.1-2.5c-0.1-0.7-0.4-1.4-0.8-2c-0.4-0.5-0.9-1-1.5-1.3C285,263.7,284.3,263.6,283.7,263.6L283.7,263.6z" />
</svg>
`)}`;
var LuteWallet = class extends BaseWallet {
  client = null;
  options;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options = {},
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    this.options = options;
    this.store = store;
  }
  static defaultMetadata = {
    name: "Lute",
    icon: ICON9
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    const module = await import("lute-connect");
    const LuteConnect = module.default;
    const client = new LuteConnect(this.options?.siteName);
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  async getGenesisId() {
    const network = this.activeNetworkConfig;
    if (network.genesisId) {
      return network.genesisId;
    }
    const algodClient = this.getAlgodClient();
    const genesisStr = await algodClient.genesis().do();
    const genesis = algosdk7.parseJSON(genesisStr, {
      intDecoding: algosdk7.IntDecoding.MIXED
    });
    return `${genesis.network}-${genesis.id}`;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    const client = this.client || await this.initializeClient();
    const genesisId = await this.getGenesisId();
    const accounts = await client.connect(genesisId);
    if (accounts.length === 0) {
      this.logger.error("No accounts found!");
      throw new Error("No accounts found!");
    }
    const walletAccounts = accounts.map((address, idx) => ({
      name: `${this.metadata.name} Account ${idx + 1}`,
      address
    }));
    const activeAccount = walletAccounts[0];
    const walletState = {
      accounts: walletAccounts,
      activeAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("Connected successfully", walletState);
    return walletAccounts;
  };
  disconnect = async () => {
    this.onDisconnect();
    this.logger.info("Disconnected");
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      await this.initializeClient();
      this.logger.info("Session resumed successfully");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk7.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk7.decodeSignedTransaction(txnBuffer).txn : algosdk7.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", txnsToSign);
      const signTxnsResult = await client.signTxns(txnsToSign);
      this.logger.debug("Transactions signed successfully", signTxnsResult);
      return signTxnsResult;
    } catch (error) {
      if (isSignTxnsError(error)) {
        this.logger.error("Error signing transactions:", error.message, `(code: ${error.code})`);
        throw new SignTxnsError(error.message, error.code);
      }
      this.logger.error("Unknown error signing transactions:", error);
      throw error;
    }
  };
  canSignData = true;
  signData = async (data, metadata) => {
    try {
      this.logger.debug("Signing data...", { data, metadata });
      const client = this.client || await this.initializeClient();
      const signDataResult = await client.signData(data, metadata);
      this.logger.debug("Data signed successfully", signDataResult);
      return signDataResult;
    } catch (error) {
      if (isSignDataError(error)) {
        this.logger.error("Error signing data:", error.message, `(code: ${error.code})`);
        throw new SignDataError(error.message, error.code);
      }
      this.logger.error("Unknown error signing data:", error);
      throw error;
    }
  };
};

// src/wallets/magic.ts
import algosdk8 from "algosdk";
var ICON10 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 47 47" xmlns="http://www.w3.org/2000/svg">
  <path fill="#6851FF" d="M 23.960861 1.80769 C 25.835077 4.103153 27.902216 6.23489 30.137539 8.178169 C 28.647968 13.009323 27.846092 18.142094 27.846092 23.462154 C 27.846092 28.782307 28.648062 33.915169 30.13763 38.746368 C 27.902216 40.689724 25.835077 42.821476 23.960861 45.116985 C 22.086554 42.821476 20.019415 40.689632 17.783998 38.746368 C 19.273476 33.915169 20.075445 28.7824 20.075445 23.462337 C 20.075445 18.142277 19.273476 13.009506 17.783998 8.178318 C 20.019415 6.235001 22.086554 4.10321 23.960861 1.80769 Z M 13.511427 35.406403 C 11.145139 33.747814 8.633816 32.282063 6.000269 31.031937 C 6.730776 28.637476 7.123754 26.095783 7.123754 23.462429 C 7.123754 20.828892 6.730762 18.287201 6.000235 15.892738 C 8.633816 14.642616 11.145175 13.176861 13.511501 11.518276 C 14.416311 15.352554 14.895074 19.351414 14.895074 23.462154 C 14.895074 27.572985 14.416283 31.571938 13.511427 35.406403 Z M 33.027046 23.462337 C 33.027046 27.572985 33.505753 31.571846 34.410553 35.406124 C 36.776859 33.747631 39.288094 32.281876 41.921539 31.031845 C 41.191017 28.637384 40.798061 26.095692 40.798061 23.462246 C 40.798061 20.8288 41.191017 18.287201 41.921539 15.89283 C 39.288094 14.642708 36.776768 13.177048 34.410553 11.518555 C 33.505753 15.352831 33.027046 19.351692 33.027046 23.462337 Z" />
</svg>
`)}`;
var MagicAuth = class extends BaseWallet {
  client = null;
  options;
  store;
  userInfo = null;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options,
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    if (!options?.apiKey) {
      this.logger.error("Missing required option: apiKey");
      throw new Error("Missing required option: apiKey");
    }
    this.options = options;
    this.store = store;
  }
  static defaultMetadata = {
    name: "Magic",
    icon: ICON10
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    const Magic = (await Promise.resolve().then(() => (init_es4(), es_exports))).Magic;
    const AlgorandExtension = (await Promise.resolve().then(() => (init_es5(), es_exports2))).AlgorandExtension;
    const client = new Magic(this.options.apiKey, {
      extensions: {
        algorand: new AlgorandExtension({
          rpcUrl: ""
        })
      }
    });
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  connect = async (args) => {
    this.logger.info("Connecting...");
    if (!args?.email || typeof args.email !== "string") {
      this.logger.error("Magic Link provider requires an email (string) to connect");
      throw new Error("Magic Link provider requires an email (string) to connect");
    }
    const { email } = args;
    const client = this.client || await this.initializeClient();
    this.logger.info(`Logging in ${email}...`);
    await client.auth.loginWithMagicLink({ email });
    const userInfo = await client.user.getInfo();
    if (!userInfo) {
      this.logger.error("User info not found!");
      throw new Error("User info not found!");
    }
    if (!userInfo.publicAddress) {
      this.logger.error("No account found!");
      throw new Error("No account found!");
    }
    this.userInfo = userInfo;
    this.logger.info("Login successful", userInfo);
    const walletAccount = {
      name: userInfo.email ?? "Magic Wallet 1",
      address: userInfo.publicAddress
    };
    const walletState = {
      accounts: [walletAccount],
      activeAccount: walletAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("Connected successfully", walletState);
    return [walletAccount];
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    this.onDisconnect();
    const client = this.client || await this.initializeClient();
    this.logger.info(`Logging out ${this.userInfo?.email || "user"}...`);
    await client.user.logout();
    this.logger.info("Disconnected");
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      const client = this.client || await this.initializeClient();
      const isLoggedIn = await client.user.isLoggedIn();
      if (!isLoggedIn) {
        this.logger.warn("Not logged in, please reconnect...");
        this.onDisconnect();
        return;
      }
      const userInfo = await client.user.getInfo();
      if (!userInfo) {
        await client.user.logout();
        this.logger.error("User info not found!");
        throw new Error("User info not found!");
      }
      if (!userInfo.publicAddress) {
        await client.user.logout();
        this.logger.error("No account found!");
        throw new Error("No account found!");
      }
      this.userInfo = userInfo;
      const walletAccount = {
        name: userInfo.email ?? `${this.metadata.name} Account 1`,
        address: userInfo.publicAddress
      };
      const storedAccount = walletState.accounts[0];
      const { name, address } = walletAccount;
      const { name: storedName, address: storedAddress } = storedAccount;
      const match = name === storedName && address === storedAddress;
      if (!match) {
        this.logger.warn("Session account mismatch, updating account", {
          prev: storedAccount,
          current: walletAccount
        });
        setAccounts(this.store, {
          walletId: this.id,
          accounts: [walletAccount]
        });
      }
      this.logger.info("Session resumed successfully");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk8.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk8.decodeSignedTransaction(txnBuffer).txn : algosdk8.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", txnsToSign);
      const signTxnsResult = await client.algorand.signGroupTransactionV2(
        txnsToSign
      );
      this.logger.debug("Received signed transactions from wallet", signTxnsResult);
      const result = signTxnsResult.map((value) => {
        if (value === void 0) {
          return null;
        }
        return base64ToByteArray(value);
      });
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/wallets/mnemonic.ts
import algosdk9 from "algosdk";
var LOCAL_STORAGE_MNEMONIC_KEY = `${LOCAL_STORAGE_KEY}_mnemonic`;
var ICON11 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
  <rect fill="#525252" width="400" height="400" />
  <path fill="#FFFFFF" d="M309.2,309.3H275l-22.2-82.7l-47.9,82.7h-38.3l73.9-128l-11.9-44.5l-99.6,172.6H90.8L217.1,90.6 h33.5l14.7,54.3h34.6l-23.6,41L309.2,309.3z" />
</svg>
`)}`;
var MnemonicWallet = class extends BaseWallet {
  account = null;
  options;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options,
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    const {
      persistToStorage = false,
      promptForMnemonic = () => Promise.resolve(prompt("Enter 25-word mnemonic passphrase:"))
    } = options || {};
    this.options = { persistToStorage, promptForMnemonic };
    this.store = store;
    if (this.options.persistToStorage) {
      this.logger.warn(
        "Persisting mnemonics to storage is insecure. Any private key mnemonics used should never hold real Algos (i.e., on MainNet). Use with caution!"
      );
    }
  }
  static defaultMetadata = {
    name: "Mnemonic",
    icon: ICON11
  };
  loadMnemonicFromStorage() {
    return StorageAdapter.getItem(LOCAL_STORAGE_MNEMONIC_KEY);
  }
  saveMnemonicToStorage(mnemonic) {
    StorageAdapter.setItem(LOCAL_STORAGE_MNEMONIC_KEY, mnemonic);
  }
  removeMnemonicFromStorage() {
    StorageAdapter.removeItem(LOCAL_STORAGE_MNEMONIC_KEY);
  }
  checkMainnet() {
    try {
      const network = this.activeNetworkConfig;
      if (!network.isTestnet) {
        this.logger.warn(
          "The Mnemonic wallet provider is insecure and intended for testing only. Any private key mnemonics used should never hold real Algos (i.e., on MainNet)."
        );
        throw new Error("Production network detected. Aborting.");
      }
    } catch (error) {
      this.disconnect();
      throw error;
    }
  }
  async initializeAccount() {
    let mnemonic = this.loadMnemonicFromStorage();
    if (!mnemonic) {
      mnemonic = await this.options.promptForMnemonic();
      if (!mnemonic) {
        this.account = null;
        this.logger.error("No mnemonic provided");
        throw new Error("No mnemonic provided");
      }
      if (this.options.persistToStorage) {
        this.logger.warn("Mnemonic saved to localStorage.");
        this.saveMnemonicToStorage(mnemonic);
      }
    }
    const account = algosdk9.mnemonicToSecretKey(mnemonic);
    this.account = account;
    return account;
  }
  connect = async () => {
    this.checkMainnet();
    this.logger.info("Connecting...");
    const account = await this.initializeAccount();
    const walletAccount = {
      name: `${this.metadata.name} Account`,
      address: account.addr.toString()
    };
    const walletState = {
      accounts: [walletAccount],
      activeAccount: walletAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("Connected successfully", walletState);
    return [walletAccount];
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    this.onDisconnect();
    this.account = null;
    this.removeMnemonicFromStorage();
    this.logger.info("Disconnected");
  };
  resumeSession = async () => {
    this.checkMainnet();
    const state = this.store.state;
    const walletState = state.wallets[this.id];
    if (!walletState) {
      this.logger.info("No session to resume");
      return;
    }
    this.logger.info("Resuming session...");
    if (this.options.persistToStorage) {
      try {
        await this.initializeAccount();
        this.logger.info("Session resumed successfully");
      } catch (error) {
        this.logger.error("Error resuming session:", error.message);
        this.disconnect();
        throw error;
      }
    } else {
      this.logger.info("No session to resume, disconnecting...");
      this.disconnect();
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = signer === this.account.addr.toString();
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push(txn);
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk9.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk9.decodeSignedTransaction(txnBuffer).txn : algosdk9.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && signer === this.account.addr.toString();
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push(txn);
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    this.checkMainnet();
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const signedTxns = txnsToSign.map((txn) => txn.signTxn(this.account.sk));
      this.logger.debug("Transactions signed successfully", { signedTxns });
      return signedTxns;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/wallets/pera.ts
import algosdk10 from "algosdk";
var ICON12 = `data:image/svg+xml;base64,${btoa(`
<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg">
  <rect fill="#FFEE55" width="200" height="200" />
  <path fill="#1C1C1C" d="M106.1,64.3c2.2,9.1,1.5,17-1.7,17.8c-3.1,0.8-7.4-6-9.6-15c-2.2-9.1-1.5-17,1.7-17.8 C99.6,48.5,103.9,55.2,106.1,64.3z" />
  <path fill="#1C1C1C" d="M142.2,72.1c-4.8-5.1-14.5-3.7-21.6,3.1c-7,6.9-8.8,16.6-4,21.7c4.8,5.1,14.5,3.7,21.6-3.1 C145.3,86.9,147.1,77.2,142.2,72.1z" />
  <path fill="#1C1C1C" d="M103.7,150.8c3.1-0.8,3.7-9.2,1.4-18.8c-2.3-9.6-6.7-16.8-9.8-16c-3.1,0.8-3.7,9.2-1.4,18.8 C96.2,144.3,100.6,151.5,103.7,150.8z" />
  <path fill="#1C1C1C" d="M72.1,76.8c9,2.6,15.5,7.3,14.6,10.3c-0.9,3.1-8.9,3.4-17.8,0.8s-15.5-7.3-14.6-10.3 C55.1,74.5,63.1,74.1,72.1,76.8z" />
  <path fill="#1C1C1C" d="M130.2,111.5c9.5,2.8,16.5,7.6,15.6,10.6c-0.9,3.1-9.3,3.3-18.8,0.5c-9.5-2.8-16.5-7.6-15.6-10.6 C112.2,108.9,120.7,108.7,130.2,111.5z" />
  <path fill="#1C1C1C" d="M82.1,105c-2.2-2.3-9.5,1-16.3,7.5c-6.8,6.4-10.4,13.5-8.2,15.8c2.2,2.3,9.5-1,16.3-7.5 C80.7,114.4,84.3,107.3,82.1,105z" />
</svg>
`)}`;
var PeraWallet = class extends BaseWallet {
  client = null;
  options;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    options = {},
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    this.options = options;
    this.store = store;
  }
  static defaultMetadata = {
    name: "Pera",
    icon: ICON12
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    const { PeraWalletConnect } = await import("@perawallet/connect");
    const client = new PeraWalletConnect(this.options);
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    const currentActiveWallet = this.store.state.activeWallet;
    if (currentActiveWallet && currentActiveWallet !== this.id) {
      this.manageWalletConnectSession("backup", currentActiveWallet);
    }
    const client = this.client || await this.initializeClient();
    const accounts = await client.connect();
    client.connector?.on("disconnect", this.onDisconnect);
    if (accounts.length === 0) {
      this.logger.error("No accounts found!");
      throw new Error("No accounts found!");
    }
    const walletAccounts = accounts.map((address, idx) => ({
      name: `${this.metadata.name} Account ${idx + 1}`,
      address
    }));
    const activeAccount = walletAccounts[0];
    const walletState = {
      accounts: walletAccounts,
      activeAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("Connected successfully", walletState);
    return walletAccounts;
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    const client = this.client || await this.initializeClient();
    const currentActiveWallet = this.store.state.activeWallet;
    if (currentActiveWallet && currentActiveWallet !== this.id) {
      this.manageWalletConnectSession("backup", currentActiveWallet);
      this.manageWalletConnectSession("restore", this.id);
      await client.disconnect();
      await new Promise((resolve) => setTimeout(resolve, 500));
      this.manageWalletConnectSession("restore", currentActiveWallet);
    } else {
      await client.disconnect();
    }
    this.onDisconnect();
    this.logger.info("Disconnected");
  };
  setActive = () => {
    this.logger.info(`Set active wallet: ${this.id}`);
    const currentActiveWallet = this.store.state.activeWallet;
    if (currentActiveWallet && currentActiveWallet === "defly" /* DEFLY */) {
      this.manageWalletConnectSession("backup", currentActiveWallet);
    }
    this.manageWalletConnectSession("restore");
    setActiveWallet(this.store, { walletId: this.id });
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (typeof window !== "undefined" && window.navigator) {
        const isPeraDiscover = window.navigator.userAgent.includes("pera");
        if (isPeraDiscover && !walletState && !state.activeWallet) {
          this.logger.info("Pera Discover browser detected, attempting auto-connect...");
          try {
            await this.connect();
            this.logger.info("Auto-connect successful");
            return;
          } catch (error) {
            this.logger.warn("Auto-connect failed:", error.message);
          }
        }
      }
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      if (state.activeWallet === "defly" /* DEFLY */) {
        this.logger.info("Skipping reconnectSession for Pera (inactive)");
        return;
      }
      this.logger.info("Resuming session...");
      const client = this.client || await this.initializeClient();
      const accounts = await client.reconnectSession();
      if (accounts.length === 0) {
        this.logger.error("No accounts found!");
        throw new Error("No accounts found!");
      }
      const walletAccounts = accounts.map((address, idx) => ({
        name: `${this.metadata.name} Account ${idx + 1}`,
        address
      }));
      const match = compareAccounts(walletAccounts, walletState.accounts);
      if (!match) {
        this.logger.warn("Session accounts mismatch, updating accounts", {
          prev: walletState.accounts,
          current: walletAccounts
        });
        setAccounts(this.store, {
          walletId: this.id,
          accounts: walletAccounts
        });
      }
      this.logger.info("Session resumed successfully");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn });
      } else {
        txnsToSign.push({ txn, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk10.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk10.decodeSignedTransaction(txnBuffer).txn : algosdk10.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn });
      } else {
        txnsToSign.push({ txn, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", [txnsToSign]);
      const signedTxns = await client.signTransaction([txnsToSign]);
      this.logger.debug("Received signed transactions from wallet", signedTxns);
      const result = txnsToSign.reduce((acc, txn) => {
        if (txn.signers && txn.signers.length == 0) {
          acc.push(null);
        } else {
          const signedTxn = signedTxns.shift();
          if (signedTxn) {
            acc.push(signedTxn);
          }
        }
        return acc;
      }, []);
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/wallets/w3wallet.ts
import algosdk11 from "algosdk";
var ICON13 = `data:image/svg+xml;base64,${btoa(`
<svg width="860" height="860" viewBox="0 0 860 860" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect width="860" height="860" rx="30" fill="#151923"/>
  <path d="M766 207L496.627 623.406C463.521 675.336 382.014 652.248 382.014 590.941V432.568L260.638 623.28C227.559 675.255 146 652.186 146 590.854V274.844H234.646V499.761L356.022 309.049C389.101 257.074 470.66 280.143 470.66 341.475V499.978L660.146 207L766 207Z" fill="#4BB7D1"/>
</svg>
`)}`;
var W3Wallet = class extends BaseWallet {
  client = null;
  store;
  constructor({
    id,
    store,
    subscribe,
    getAlgodClient,
    metadata = {}
  }) {
    super({ id, metadata, getAlgodClient, store, subscribe });
    this.store = store;
  }
  static defaultMetadata = {
    name: "W3 Wallet",
    icon: ICON13
  };
  async initializeClient() {
    this.logger.info("Initializing client...");
    if (typeof window === "undefined" || window.w3walletAlgorand === void 0) {
      this.logger.error("W3 Wallet is not available.");
      throw new Error("W3 Wallet is not available.");
    }
    const client = window.w3walletAlgorand;
    this.client = client;
    this.logger.info("Client initialized");
    return client;
  }
  connect = async () => {
    this.logger.info("Connecting...");
    const client = this.client || await this.initializeClient();
    const activeAccount = await client.account();
    const walletState = {
      accounts: [activeAccount],
      activeAccount
    };
    addWallet(this.store, {
      walletId: this.id,
      wallet: walletState
    });
    this.logger.info("\u2705 Connected.", walletState);
    return [activeAccount];
  };
  disconnect = async () => {
    this.logger.info("Disconnecting...");
    this.onDisconnect();
    this.logger.info("Disconnected.");
  };
  resumeSession = async () => {
    try {
      const state = this.store.state;
      const walletState = state.wallets[this.id];
      if (!walletState) {
        this.logger.info("No session to resume");
        return;
      }
      this.logger.info("Resuming session...");
      const client = await this.initializeClient();
      const isConnected = await client.isConnected();
      if (!isConnected) {
        this.logger.error("W3 Wallet is not connected.");
        throw new Error("W3 Wallet is not connected.");
      }
      this.logger.info("Session resumed");
    } catch (error) {
      this.logger.error("Error resuming session:", error.message);
      this.onDisconnect();
      throw error;
    }
  };
  processTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txn, index) => {
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  processEncodedTxns(txnGroup, indexesToSign) {
    const txnsToSign = [];
    txnGroup.forEach((txnBuffer, index) => {
      const decodedObj = algosdk11.msgpackRawDecode(txnBuffer);
      const isSigned = isSignedTxn(decodedObj);
      const txn = isSigned ? algosdk11.decodeSignedTransaction(txnBuffer).txn : algosdk11.decodeUnsignedTransaction(txnBuffer);
      const isIndexMatch = !indexesToSign || indexesToSign.includes(index);
      const signer = txn.sender.toString();
      const canSignTxn = !isSigned && this.addresses.includes(signer);
      const txnString = byteArrayToBase64(txn.toByte());
      if (isIndexMatch && canSignTxn) {
        txnsToSign.push({ txn: txnString });
      } else {
        txnsToSign.push({ txn: txnString, signers: [] });
      }
    });
    return txnsToSign;
  }
  signTransactions = async (txnGroup, indexesToSign) => {
    try {
      this.logger.debug("Signing transactions...", { txnGroup, indexesToSign });
      let txnsToSign = [];
      if (isTransactionArray(txnGroup)) {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processTxns(flatTxns, indexesToSign);
      } else {
        const flatTxns = flattenTxnGroup(txnGroup);
        txnsToSign = this.processEncodedTxns(flatTxns, indexesToSign);
      }
      const client = this.client || await this.initializeClient();
      this.logger.debug("Sending processed transactions to wallet...", txnsToSign);
      const signTxnsResult = await client.signTxns(txnsToSign);
      this.logger.debug("Received signed transactions from wallet", signTxnsResult);
      const result = signTxnsResult.map((value) => {
        if (value === null) {
          return null;
        }
        return base64ToByteArray(value);
      });
      this.logger.debug("Transactions signed successfully", result);
      return result;
    } catch (error) {
      this.logger.error("Error signing transactions:", error.message);
      throw error;
    }
  };
};

// src/utils.ts
function createWalletMap() {
  return {
    ["biatec" /* BIATEC */]: BiatecWallet,
    ["custom" /* CUSTOM */]: CustomWallet,
    ["defly" /* DEFLY */]: DeflyWallet,
    ["defly-web" /* DEFLY_WEB */]: DeflyWebWallet,
    ["exodus" /* EXODUS */]: ExodusWallet,
    ["kibisis" /* KIBISIS */]: KibisisWallet,
    ["kmd" /* KMD */]: KmdWallet,
    ["lute" /* LUTE */]: LuteWallet,
    ["magic" /* MAGIC */]: MagicAuth,
    ["mnemonic" /* MNEMONIC */]: MnemonicWallet,
    ["pera" /* PERA */]: PeraWallet,
    ["walletconnect" /* WALLETCONNECT */]: WalletConnect,
    ["w3-wallet" /* W3_WALLET */]: W3Wallet
  };
}
function compareAccounts(accounts, compareTo) {
  const addresses = new Set(accounts.map((account) => account.address));
  const compareAddresses = new Set(compareTo.map((account) => account.address));
  if (addresses.size !== compareAddresses.size) {
    return false;
  }
  for (const address of addresses) {
    if (!compareAddresses.has(address)) {
      return false;
    }
  }
  return true;
}
function base64ToByteArray(blob) {
  return stringToByteArray(atob(blob));
}
function byteArrayToBase64(array) {
  return btoa(byteArrayToString(array));
}
function stringToByteArray(str) {
  const array = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    array[i] = str.charCodeAt(i);
  }
  return array;
}
function byteArrayToString(array) {
  let result = "";
  for (let i = 0; i < array.length; i++) {
    result += String.fromCharCode(array[i]);
  }
  return result;
}
function isSignedTxn(txnObj) {
  if (!txnObj || typeof txnObj !== "object") return false;
  if (!("sig" in txnObj && "txn" in txnObj)) return false;
  if (!(txnObj.sig instanceof Uint8Array)) return false;
  const txn = txnObj.txn;
  if (!txn || typeof txn !== "object") return false;
  const hasRequiredProps = "type" in txn && "snd" in txn;
  return hasRequiredProps;
}
function isTransaction(item) {
  return item && typeof item === "object" && "sender" in item && (item.sender instanceof algosdk12.Address || typeof item.sender === "string");
}
function isTransactionArray(txnGroup) {
  if (!Array.isArray(txnGroup) || txnGroup.length === 0) {
    return false;
  }
  if (isTransaction(txnGroup[0])) {
    return true;
  }
  if (Array.isArray(txnGroup[0]) && txnGroup[0].length > 0 && isTransaction(txnGroup[0][0])) {
    return true;
  }
  return false;
}
function flattenTxnGroup(txnGroup) {
  if (!Array.isArray(txnGroup[0])) {
    return txnGroup;
  }
  return txnGroup.flat();
}
function getPayloadId() {
  const date = Date.now() * Math.pow(10, 3);
  const extra = Math.floor(Math.random() * Math.pow(10, 3));
  return date + extra;
}
function formatJsonRpcRequest(method, params) {
  return {
    id: getPayloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}

// src/manager.ts
var WalletManager = class {
  _clients = /* @__PURE__ */ new Map();
  baseNetworkConfig;
  store;
  subscribe;
  options;
  logger;
  constructor({
    wallets = [],
    networks,
    defaultNetwork = "testnet",
    options = {}
  } = {}) {
    this.logger = this.initializeLogger(options);
    this.logger.debug("Initializing WalletManager with config:", {
      wallets,
      networks,
      defaultNetwork,
      options
    });
    const persistedState = this.loadPersistedState();
    this.baseNetworkConfig = networks || createNetworkConfig();
    const networkConfig = this.initNetworkConfig(this.baseNetworkConfig, persistedState);
    this.options = { resetNetwork: options.resetNetwork || false };
    const activeNetwork = this.options.resetNetwork ? defaultNetwork : persistedState?.activeNetwork || defaultNetwork;
    if (!networkConfig[activeNetwork]) {
      throw new Error(`Network "${activeNetwork}" not found in network configuration`);
    }
    const algodClient = this.createAlgodClient(networkConfig[activeNetwork].algod);
    const initialState = {
      ...DEFAULT_STATE,
      ...persistedState,
      networkConfig,
      activeNetwork,
      algodClient
    };
    this.store = new Store(initialState, {
      onUpdate: () => this.savePersistedState()
    });
    this.savePersistedState();
    this.subscribe = (callback) => {
      const unsubscribe = this.store.subscribe(() => {
        callback(this.store.state);
      });
      return unsubscribe;
    };
    this.initializeWallets(wallets);
  }
  // ---------- Logging ----------------------------------------------- //
  initializeLogger(options) {
    const logLevel = this.determineLogLevel(options);
    Logger.setLevel(logLevel);
    return logger.createScopedLogger("WalletManager");
  }
  determineLogLevel(options) {
    if (options?.debug) {
      return 0 /* DEBUG */;
    }
    return options?.logLevel !== void 0 ? options.logLevel : 2 /* WARN */;
  }
  // ---------- Store ------------------------------------------------- //
  get algodClient() {
    return this.store.state.algodClient;
  }
  set algodClient(algodClient) {
    this.store.setState((state) => ({
      ...state,
      algodClient
    }));
  }
  loadPersistedState() {
    try {
      const serializedState = StorageAdapter.getItem(LOCAL_STORAGE_KEY);
      if (serializedState === null) {
        return null;
      }
      const parsedState = JSON.parse(serializedState);
      if (!isValidPersistedState(parsedState)) {
        this.logger.warn("Parsed state:", parsedState);
        throw new Error("Persisted state is invalid");
      }
      return parsedState;
    } catch (error) {
      this.logger.error(`Could not load state from local storage: ${error.message}`);
      return null;
    }
  }
  savePersistedState() {
    try {
      const { wallets, activeWallet, activeNetwork, networkConfig } = this.store.state;
      const persistedState = {
        wallets,
        activeWallet,
        activeNetwork,
        customNetworkConfigs: {}
      };
      for (const [networkId, currentConfig] of Object.entries(networkConfig)) {
        const baseNetworkConfig = this.baseNetworkConfig[networkId];
        if (!baseNetworkConfig) continue;
        const customizations = {};
        let hasCustomizations = false;
        if (JSON.stringify(currentConfig.algod) !== JSON.stringify(baseNetworkConfig.algod)) {
          customizations.algod = currentConfig.algod;
          hasCustomizations = true;
        }
        if (hasCustomizations) {
          persistedState.customNetworkConfigs = {
            ...persistedState.customNetworkConfigs || {},
            [networkId]: customizations
          };
        }
      }
      const serializedState = JSON.stringify(persistedState);
      StorageAdapter.setItem(LOCAL_STORAGE_KEY, serializedState);
    } catch (error) {
      this.logger.error("Could not save state to local storage:", error);
    }
  }
  // ---------- Status ------------------------------------------------ //
  get status() {
    return this.store.state.managerStatus;
  }
  get isReady() {
    return this.store.state.managerStatus === "ready";
  }
  // ---------- Wallets ----------------------------------------------- //
  initializeWallets(walletsConfig) {
    this.logger.info("Initializing wallets...");
    for (const walletConfig of walletsConfig) {
      let walletId;
      let walletOptions;
      let walletMetadata;
      if (typeof walletConfig === "string") {
        walletId = walletConfig;
      } else {
        const { id, options, metadata } = walletConfig;
        walletId = id;
        walletOptions = options;
        walletMetadata = metadata;
      }
      const walletMap = createWalletMap();
      const WalletClass = walletMap[walletId];
      if (!WalletClass) {
        this.logger.error(`Wallet not found: ${walletId}`);
        continue;
      }
      const walletInstance = new WalletClass({
        id: walletId,
        metadata: walletMetadata,
        options: walletOptions,
        getAlgodClient: this.getAlgodClient,
        store: this.store,
        subscribe: this.subscribe
      });
      this._clients.set(walletId, walletInstance);
      this.logger.info(`\u2705 Initialized ${walletId}`);
    }
    const state = this.store.state;
    const connectedWallets = Object.keys(state.wallets);
    for (const walletId of connectedWallets) {
      if (!this._clients.has(walletId)) {
        this.logger.warn(`Connected wallet not found: ${walletId}`);
        removeWallet(this.store, { walletId });
      }
    }
    if (state.activeWallet && !this._clients.has(state.activeWallet)) {
      this.logger.warn(`Active wallet not found: ${state.activeWallet}`);
      setActiveWallet(this.store, { walletId: null });
    }
  }
  get wallets() {
    return [...this._clients.values()];
  }
  getWallet(walletId) {
    return this._clients.get(walletId);
  }
  async resumeSessions() {
    try {
      const promises = this.wallets.map((wallet) => wallet?.resumeSession());
      await Promise.all(promises);
    } finally {
      this.store.setState((state) => ({
        ...state,
        managerStatus: "ready"
      }));
    }
  }
  async disconnect() {
    const promises = this.wallets.filter((wallet) => wallet.isConnected).map((wallet) => wallet?.disconnect());
    await Promise.all(promises);
  }
  // ---------- Network ----------------------------------------------- //
  initNetworkConfig(baseConfig, persistedState) {
    this.logger.info("Initializing network configuration...");
    const customConfigs = persistedState?.customNetworkConfigs || {};
    const config = {};
    for (const [networkId, baseNetworkConfig] of Object.entries(baseConfig)) {
      const customNetworkConfig = customConfigs[networkId];
      config[networkId] = {
        ...baseNetworkConfig,
        ...customNetworkConfig,
        // Ensure algod config is also deeply merged
        algod: {
          ...baseNetworkConfig.algod,
          ...customNetworkConfig?.algod || {}
        }
      };
    }
    for (const [id, network] of Object.entries(config)) {
      if (!isNetworkConfig(network)) {
        throw new Error(`Invalid network configuration for "${id}"`);
      }
    }
    this.logger.debug("Network configuration:", config);
    return config;
  }
  createAlgodClient(config) {
    this.logger.info(`Creating new Algodv2 client...`);
    const { token = "", baseServer, port = "", headers = {} } = config;
    return new algosdk13.Algodv2(token, baseServer, port, headers);
  }
  getAlgodClient = () => {
    return this.algodClient;
  };
  setActiveNetwork = async (networkId) => {
    if (this.activeNetwork === networkId) {
      return;
    }
    if (!this.networkConfig[networkId]) {
      throw new Error(`Network "${networkId}" not found in network configuration`);
    }
    const algodClient = this.createAlgodClient(this.networkConfig[networkId].algod);
    setActiveNetwork(this.store, { networkId, algodClient });
    this.logger.info(`\u2705 Active network set to ${networkId}`);
  };
  updateAlgodConfig(networkId, algodConfig) {
    if (!this.networkConfig[networkId]) {
      throw new Error(`Network "${networkId}" not found in network configuration`);
    }
    const updatedConfig = {
      ...this.networkConfig[networkId],
      algod: {
        ...this.networkConfig[networkId].algod,
        ...algodConfig
      }
    };
    if (!isNetworkConfig(updatedConfig)) {
      throw new Error("Invalid network configuration");
    }
    this.store.setState((state) => ({
      ...state,
      networkConfig: {
        ...state.networkConfig,
        [networkId]: updatedConfig
      }
    }));
    if (this.activeNetwork === networkId) {
      this.algodClient = this.createAlgodClient(updatedConfig.algod);
    }
    this.savePersistedState();
    this.logger.info(`\u2705 Updated algod configuration for ${networkId}`);
  }
  resetNetworkConfig(networkId) {
    if (!this.baseNetworkConfig[networkId]) {
      throw new Error(`Network "${networkId}" not found in network configuration`);
    }
    this.store.setState((state) => ({
      ...state,
      networkConfig: {
        ...state.networkConfig,
        [networkId]: { ...this.baseNetworkConfig[networkId] }
      }
    }));
    if (this.activeNetwork === networkId) {
      this.algodClient = this.createAlgodClient(this.baseNetworkConfig[networkId].algod);
    }
    const persistedState = this.loadPersistedState();
    if (persistedState?.customNetworkConfigs) {
      delete persistedState.customNetworkConfigs[networkId];
      StorageAdapter.setItem(LOCAL_STORAGE_KEY, JSON.stringify(persistedState));
    }
    this.logger.info(`\u2705 Reset network configuration for ${networkId}`);
  }
  get activeNetwork() {
    return this.store.state.activeNetwork;
  }
  get networkConfig() {
    return this.store.state.networkConfig;
  }
  get activeNetworkConfig() {
    const { networkConfig, activeNetwork } = this.store.state;
    return networkConfig[activeNetwork];
  }
  // ---------- Active Wallet ----------------------------------------- //
  get activeWallet() {
    const state = this.store.state;
    const activeWallet = this.wallets.find((wallet) => wallet.id === state.activeWallet);
    if (!activeWallet) {
      return null;
    }
    return activeWallet;
  }
  get activeWalletAccounts() {
    if (!this.activeWallet) {
      return null;
    }
    return this.activeWallet.accounts;
  }
  get activeWalletAddresses() {
    if (!this.activeWallet) {
      return null;
    }
    return this.activeWallet.accounts.map((account) => account.address);
  }
  get activeAccount() {
    if (!this.activeWallet) {
      return null;
    }
    return this.activeWallet.activeAccount;
  }
  get activeAddress() {
    if (!this.activeAccount) {
      return null;
    }
    return this.activeAccount.address;
  }
  // ---------- Sign Transactions ------------------------------------- //
  get signTransactions() {
    if (!this.activeWallet) {
      this.logger.error("No active wallet found!");
      throw new Error("No active wallet found!");
    }
    return this.activeWallet.signTransactions;
  }
  get transactionSigner() {
    if (!this.activeWallet) {
      this.logger.error("No active wallet found!");
      throw new Error("No active wallet found!");
    }
    return this.activeWallet.transactionSigner;
  }
};

// src/webpack.ts
var webpackFallback = {
  "@agoralabs-sh/avm-web-provider": false,
  "@blockshake/defly-connect": false,
  "@magic-ext/algorand": false,
  "@perawallet/connect": false,
  "@walletconnect/modal": false,
  "@walletconnect/sign-client": false,
  "lute-connect": false,
  "magic-sdk": false
};
export {
  BaseWallet,
  BiatecWallet,
  CustomWallet,
  DEFAULT_NETWORK_CONFIG,
  DEFAULT_STATE,
  DEFLY_WEB_PROVIDER_ID,
  DeflyWallet,
  DeflyWebWallet,
  ExodusWallet,
  ICON7 as ICON,
  KIBISIS_AVM_WEB_PROVIDER_ID,
  KibisisWallet,
  KmdWallet,
  LOCAL_STORAGE_MNEMONIC_KEY,
  LogLevel,
  LuteWallet,
  MagicAuth,
  MnemonicWallet,
  NetworkConfigBuilder,
  NetworkId,
  PeraWallet,
  ScopeType,
  SessionError,
  SignDataError,
  SignTxnsError,
  StorageAdapter,
  W3Wallet,
  WalletConnect,
  WalletId,
  WalletManager,
  webpackFallback
};
//# sourceMappingURL=index.js.map