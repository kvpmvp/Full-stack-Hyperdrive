import { Store } from '@tanstack/store';
import algosdk from 'algosdk';
import AVMWebProviderSDK from '@agoralabs-sh/avm-web-provider';
import { InstanceWithExtensions, SDKBase } from '@magic-sdk/provider';
import { AlgorandExtension } from '@magic-ext/algorand';
import { MagicUserMetadata } from 'magic-sdk';
import { WalletConnectModalConfig } from '@walletconnect/modal';
import { SignClientTypes } from '@walletconnect/types';

declare enum LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3
}
declare class Logger {
    private static instance;
    private level;
    private isClient;
    private constructor();
    static getInstance(): Logger;
    static setLevel(level: LogLevel): void;
    private log;
    createScopedLogger(scope: string): {
        debug: (message: string, ...args: any[]) => void;
        info: (message: string, ...args: any[]) => void;
        warn: (message: string, ...args: any[]) => void;
        error: (message: string, ...args: any[]) => void;
    };
    debug(message: string, ...args: any[]): void;
    info(message: string, ...args: any[]): void;
    warn(message: string, ...args: any[]): void;
    error(message: string, ...args: any[]): void;
    setIsClient(isClient: boolean): void;
}
declare const logger: Logger;

interface AlgodConfig {
    token: string | algosdk.AlgodTokenHeader | algosdk.CustomTokenHeader | algosdk.BaseHTTPClient;
    baseServer: string;
    port?: string | number;
    headers?: Record<string, string>;
}
interface NetworkConfig {
    algod: AlgodConfig;
    genesisHash?: string;
    genesisId?: string;
    isTestnet?: boolean;
    caipChainId?: string;
}
declare const DEFAULT_NETWORK_CONFIG: Record<string, NetworkConfig>;
type DefaultNetworkConfig = Omit<Partial<NetworkConfig>, 'genesisHash' | 'genesisId' | 'caipChainId'>;
declare class NetworkConfigBuilder {
    private networks;
    constructor();
    mainnet(config: DefaultNetworkConfig): this;
    testnet(config: DefaultNetworkConfig): this;
    betanet(config: DefaultNetworkConfig): this;
    fnet(config: DefaultNetworkConfig): this;
    localnet(config: Partial<NetworkConfig>): this;
    addNetwork(id: string, config: NetworkConfig): this;
    build(): {
        [k: string]: NetworkConfig;
    };
}
declare enum NetworkId {
    MAINNET = "mainnet",
    TESTNET = "testnet",
    BETANET = "betanet",
    FNET = "fnet",
    LOCALNET = "localnet"
}

declare abstract class BaseWallet {
    readonly id: WalletId;
    readonly metadata: WalletMetadata;
    protected store: Store<State>;
    protected getAlgodClient: () => algosdk.Algodv2;
    subscribe: (callback: (state: State) => void) => () => void;
    protected logger: ReturnType<typeof logger.createScopedLogger>;
    protected constructor({ id, metadata, store, subscribe, getAlgodClient }: WalletConstructor<WalletId>);
    static defaultMetadata: WalletMetadata;
    abstract connect(args?: Record<string, any>): Promise<WalletAccount[]>;
    abstract disconnect(): Promise<void>;
    abstract resumeSession(): Promise<void>;
    setActive: () => void;
    setActiveAccount: (account: string) => void;
    abstract signTransactions<T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]): Promise<(Uint8Array | null)[]>;
    transactionSigner: (txnGroup: algosdk.Transaction[], indexesToSign: number[]) => Promise<Uint8Array[]>;
    canSignData: boolean;
    signData: (_data: string, _metadata: SignMetadata) => Promise<SignDataResponse>;
    get name(): string;
    get accounts(): WalletAccount[];
    get addresses(): string[];
    get activeAccount(): WalletAccount | null;
    get activeAddress(): string | null;
    get activeNetwork(): string;
    get isConnected(): boolean;
    get isActive(): boolean;
    get activeNetworkConfig(): NetworkConfig;
    protected onDisconnect: () => void;
    protected manageWalletConnectSession: (action: "backup" | "restore", targetWalletId?: WalletId) => void;
}

type CustomProvider = {
    connect(args?: Record<string, any>): Promise<WalletAccount[]>;
    disconnect?(): Promise<void>;
    resumeSession?(): Promise<WalletAccount[] | void>;
    signTransactions?<T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]): Promise<(Uint8Array | null)[]>;
    transactionSigner?(txnGroup: algosdk.Transaction[], indexesToSign: number[]): Promise<Uint8Array[]>;
    signData?(data: string, metadata: SignMetadata): Promise<SignDataResponse>;
};
interface CustomWalletOptions {
    provider: CustomProvider;
}
declare class CustomWallet extends BaseWallet {
    private provider;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.CUSTOM>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    connect: (args?: Record<string, any>) => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
    transactionSigner: (txnGroup: algosdk.Transaction[], indexesToSign: number[]) => Promise<Uint8Array[]>;
    signData: (data: string, metadata: SignMetadata) => Promise<SignDataResponse>;
}

interface DeflyWalletConnectOptions {
    bridge?: string;
    shouldShowSignTxnToast?: boolean;
    chainId?: 416001 | 416002 | 416003 | 4160;
}
declare class DeflyWallet extends BaseWallet {
    private client;
    private options;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.DEFLY>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    setActive: () => void;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

declare abstract class AVMProvider extends BaseWallet {
    avmWebClient: AVMWebProviderSDK.AVMWebClient | null;
    protected avmWebProviderSDK: typeof AVMWebProviderSDK | null;
    protected providerId: string;
    constructor(args: WalletConstructor<WalletId> & {
        providerId: string;
    });
    protected _initializeAVMWebProviderSDK(): Promise<typeof AVMWebProviderSDK>;
    protected _initializeAVMWebClient(): Promise<AVMWebProviderSDK.AVMWebClient>;
    protected _getGenesisHash(): Promise<string>;
    protected _mapAVMWebProviderAccountToWalletAccounts(accounts: AVMWebProviderSDK.IAccount[]): WalletAccount[];
    protected processTxns(txnGroup: algosdk.Transaction[], indexesToSign?: number[]): AVMWebProviderSDK.IARC0001Transaction[];
    protected processEncodedTxns(txnGroup: Uint8Array[], indexesToSign?: number[]): AVMWebProviderSDK.IARC0001Transaction[];
    /**
     * Abstract methods
     * These methods must be implemented by specific wallet providers
     */
    protected abstract _enable(): Promise<AVMWebProviderSDK.IEnableResult>;
    protected abstract _disable(): Promise<AVMWebProviderSDK.IDisableResult>;
    protected abstract _signTransactions(txns: AVMWebProviderSDK.IARC0001Transaction[]): Promise<AVMWebProviderSDK.ISignTransactionsResult>;
    /**
     * Common methods
     * These methods can be overridden by specific wallet providers if needed
     */
    connect(): Promise<WalletAccount[]>;
    disconnect(): Promise<void>;
    resumeSession(): Promise<void>;
    signTransactions<T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]): Promise<(Uint8Array | null)[]>;
}

declare const DEFLY_WEB_PROVIDER_ID = "95426e60-5f2e-49e9-b912-c488577be962";
declare class DeflyWebWallet extends AVMProvider {
    constructor({ id, store, subscribe, getAlgodClient, metadata }: WalletConstructor<WalletId.DEFLY_WEB>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    /**
     * Calls the "enable" method on the provider. This method will timeout after 3 minutes.
     * @returns {Promise<AVMWebProviderSDK.IEnableResult>} a promise that resolves to the result.
     * @protected
     * @throws {MethodCanceledError} if the method was cancelled by the user.
     * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
     * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
     * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
     * @throws {UnknownError} if the response result is empty.
     */
    protected _enable(): Promise<AVMWebProviderSDK.IEnableResult>;
    /**
     * Calls the "disable" method on the provider. This method will timeout after 0.75 seconds.
     * @returns {Promise<AVMWebProviderSDK.IDisableResult>} a promise that resolves to the result.
     * @protected
     * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
     * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
     * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
     * @throws {UnknownError} if the response result is empty.
     */
    protected _disable(): Promise<AVMWebProviderSDK.IDisableResult>;
    /**
     * Calls the "signTransactions" method to sign the supplied ARC-0001 transactions. This method will timeout after 3
     * minutes.
     * @returns {Promise<AVMWebProviderSDK.ISignTransactionsResult>} a promise that resolves to the result.
     * @protected
     * @throws {InvalidInputError} if computed group ID for the txns does not match the assigned group ID.
     * @throws {InvalidGroupIdError} if the unsigned txns is malformed or not conforming to ARC-0001.
     * @throws {MethodCanceledError} if the method was cancelled by the user.
     * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
     * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
     * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
     * @throws {UnauthorizedSignerError} if a signer in the request is not authorized by the provider.
     * @throws {UnknownError} if the response result is empty.
     */
    protected _signTransactions(txns: AVMWebProviderSDK.IARC0001Transaction[]): Promise<AVMWebProviderSDK.ISignTransactionsResult>;
}

/** @see https://docs.exodus.com/api-reference/algorand-provider-arc-api/ */
interface EnableNetworkOpts {
    genesisID?: string;
    genesisHash?: string;
}
interface EnableAccountsOpts {
    accounts?: string[];
}
type ExodusOptions = EnableNetworkOpts & EnableAccountsOpts;
interface EnableNetworkResult {
    genesisID: string;
    genesisHash: string;
}
interface EnableAccountsResult {
    accounts: string[];
}
type EnableResult = EnableNetworkResult & EnableAccountsResult;
type SignTxnsResult = (string | null)[];
interface Exodus {
    isConnected: boolean;
    address: string | null;
    enable: (options?: ExodusOptions) => Promise<EnableResult>;
    signTxns: (transactions: WalletTransaction[]) => Promise<SignTxnsResult>;
}
type WindowExtended = {
    algorand: Exodus;
} & Window & typeof globalThis;
declare class ExodusWallet extends BaseWallet {
    private client;
    private options;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.EXODUS>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

declare const KIBISIS_AVM_WEB_PROVIDER_ID = "f6d1c86b-4493-42fb-b88d-a62407b4cdf6";
declare const ICON: string;
declare class KibisisWallet extends AVMProvider {
    constructor({ id, store, subscribe, getAlgodClient, metadata }: WalletConstructor<WalletId.KIBISIS>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    /**
     * Calls the "enable" method on the provider. This method will timeout after 3 minutes.
     * @returns {Promise<AVMWebProviderSDK.IEnableResult>} a promise that resolves to the result.
     * @protected
     * @throws {MethodCanceledError} if the method was cancelled by the user.
     * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
     * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
     * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
     * @throws {UnknownError} if the response result is empty.
     */
    protected _enable(): Promise<AVMWebProviderSDK.IEnableResult>;
    /**
     * Calls the "disable" method on the provider. This method will timeout after 0.75 seconds.
     * @returns {Promise<AVMWebProviderSDK.IDisableResult>} a promise that resolves to the result.
     * @protected
     * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
     * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
     * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
     * @throws {UnknownError} if the response result is empty.
     */
    protected _disable(): Promise<AVMWebProviderSDK.IDisableResult>;
    /**
     * Calls the "signTransactions" method to sign the supplied ARC-0001 transactions. This method will timeout after 3
     * minutes.
     * @returns {Promise<AVMWebProviderSDK.ISignTransactionsResult>} a promise that resolves to the result.
     * @protected
     * @throws {InvalidInputError} if computed group ID for the txns does not match the assigned group ID.
     * @throws {InvalidGroupIdError} if the unsigned txns is malformed or not conforming to ARC-0001.
     * @throws {MethodCanceledError} if the method was cancelled by the user.
     * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
     * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
     * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
     * @throws {UnauthorizedSignerError} if a signer in the request is not authorized by the provider.
     * @throws {UnknownError} if the response result is empty.
     */
    protected _signTransactions(txns: AVMWebProviderSDK.IARC0001Transaction[]): Promise<AVMWebProviderSDK.ISignTransactionsResult>;
}

interface KmdConstructor {
    token: string | algosdk.KMDTokenHeader | algosdk.CustomTokenHeader;
    baseServer?: string;
    port?: string | number;
    headers?: Record<string, string>;
    promptForPassword: () => Promise<string>;
}
type KmdOptions = Partial<Pick<KmdConstructor, 'token' | 'promptForPassword'>> & Omit<KmdConstructor, 'token' | 'promptForPassword'> & {
    wallet?: string;
};
declare class KmdWallet extends BaseWallet {
    private client;
    private options;
    private walletName;
    private walletId;
    private password;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.KMD>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
    private fetchWalletId;
    private fetchToken;
    private releaseToken;
    private getPassword;
    private fetchAccounts;
}

interface LuteConnectOptions {
    siteName?: string;
}
declare class LuteWallet extends BaseWallet {
    private client;
    private options;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.LUTE>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    private getGenesisId;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
    canSignData: boolean;
    signData: (data: string, metadata: SignMetadata) => Promise<SignDataResponse>;
}

/** @see https://magic.link/docs/blockchains/other-chains/other/algorand */
interface MagicAuthOptions {
    apiKey?: string;
}
type MagicAuthClient = InstanceWithExtensions<SDKBase, {
    algorand: AlgorandExtension;
}>;
declare class MagicAuth extends BaseWallet {
    private client;
    private options;
    protected store: Store<State>;
    userInfo: MagicUserMetadata | null;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.MAGIC>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    connect: (args?: Record<string, any>) => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

interface MnemonicConstructor {
    persistToStorage?: boolean;
    promptForMnemonic: () => Promise<string | null>;
}
type MnemonicOptions = Partial<Pick<MnemonicConstructor, 'promptForMnemonic'>> & Omit<MnemonicConstructor, 'promptForMnemonic'>;
declare const LOCAL_STORAGE_MNEMONIC_KEY = "@txnlab/use-wallet:v4_mnemonic";
declare class MnemonicWallet extends BaseWallet {
    private account;
    private options;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.MNEMONIC>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private loadMnemonicFromStorage;
    private saveMnemonicToStorage;
    private removeMnemonicFromStorage;
    private checkMainnet;
    private initializeAccount;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

interface PeraWalletConnectOptions {
    bridge?: string;
    shouldShowSignTxnToast?: boolean;
    chainId?: 416001 | 416002 | 416003 | 4160;
    compactMode?: boolean;
}
declare class PeraWallet extends BaseWallet {
    private client;
    private options;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.PERA>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    setActive: () => void;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

interface SignClientOptions {
    projectId: string;
    relayUrl?: string;
    metadata?: SignClientTypes.Metadata;
}
type WalletConnectModalOptions = Pick<WalletConnectModalConfig, 'enableExplorer' | 'explorerRecommendedWalletIds' | 'privacyPolicyUrl' | 'termsOfServiceUrl' | 'themeMode' | 'themeVariables'>;
type WalletConnectOptions = SignClientOptions & WalletConnectModalOptions;
type SignTxnsResponse = Array<Uint8Array | number[] | string | null | undefined>;
declare class SessionError extends Error {
    constructor(message: string);
}
declare class WalletConnect extends BaseWallet {
    private client;
    private options;
    private modal;
    private modalOptions;
    private session;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.WALLETCONNECT>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    /**
     * Get metadata from the current window. This is adapted from the @walletconnect/utils
     * implementation, to avoid requiring the entire package as a dependency.
     * @see https://github.com/WalletConnect/walletconnect-utils/blob/master/browser/window-metadata/src/index.ts
     */
    private getWindowMetadata;
    private initializeClient;
    private initializeModal;
    private onSessionConnected;
    get activeChainId(): string;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

declare class BiatecWallet extends WalletConnect {
    static defaultMetadata: {
        name: string;
        icon: string;
    };
}

interface W3WalletProvider {
    isConnected: () => Promise<boolean>;
    account: () => Promise<WalletAccount>;
    signTxns: (transactions: WalletTransaction[]) => Promise<(string | null)[]>;
}
declare class W3Wallet extends BaseWallet {
    private client;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, metadata }: WalletConstructor<WalletId.W3_WALLET>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

declare enum WalletId {
    BIATEC = "biatec",
    DEFLY = "defly",
    DEFLY_WEB = "defly-web",
    CUSTOM = "custom",
    EXODUS = "exodus",
    KIBISIS = "kibisis",
    KMD = "kmd",
    LUTE = "lute",
    MAGIC = "magic",
    MNEMONIC = "mnemonic",
    PERA = "pera",
    WALLETCONNECT = "walletconnect",
    W3_WALLET = "w3-wallet"
}
type WalletMap = {
    [WalletId.BIATEC]: typeof BiatecWallet;
    [WalletId.CUSTOM]: typeof CustomWallet;
    [WalletId.DEFLY]: typeof DeflyWallet;
    [WalletId.DEFLY_WEB]: typeof DeflyWebWallet;
    [WalletId.EXODUS]: typeof ExodusWallet;
    [WalletId.KIBISIS]: typeof KibisisWallet;
    [WalletId.KMD]: typeof KmdWallet;
    [WalletId.LUTE]: typeof LuteWallet;
    [WalletId.MAGIC]: typeof MagicAuth;
    [WalletId.MNEMONIC]: typeof MnemonicWallet;
    [WalletId.PERA]: typeof PeraWallet;
    [WalletId.WALLETCONNECT]: typeof WalletConnect;
    [WalletId.W3_WALLET]: typeof W3Wallet;
};
type WalletOptionsMap = {
    [WalletId.BIATEC]: WalletConnectOptions;
    [WalletId.CUSTOM]: CustomWalletOptions;
    [WalletId.DEFLY]: DeflyWalletConnectOptions;
    [WalletId.DEFLY_WEB]: Record<string, never>;
    [WalletId.EXODUS]: ExodusOptions;
    [WalletId.KIBISIS]: Record<string, never>;
    [WalletId.KMD]: KmdOptions;
    [WalletId.LUTE]: LuteConnectOptions;
    [WalletId.MAGIC]: MagicAuthOptions;
    [WalletId.MNEMONIC]: MnemonicOptions;
    [WalletId.PERA]: PeraWalletConnectOptions;
    [WalletId.WALLETCONNECT]: WalletConnectOptions;
    [WalletId.W3_WALLET]: Record<string, never>;
};
type SupportedWallet = WalletIdConfig<WalletId> | WalletId;
type WalletConfigMap = {
    [K in keyof WalletOptionsMap]: {
        options?: WalletOptionsMap[K];
        metadata?: Partial<WalletMetadata>;
    };
};
type WalletOptions<T extends keyof WalletOptionsMap> = WalletOptionsMap[T];
type WalletConfig<T extends keyof WalletConfigMap> = WalletConfigMap[T];
type WalletIdConfig<T extends keyof WalletConfigMap> = {
    [K in T]: {
        id: K;
    } & WalletConfigMap[K];
}[T];
type NonEmptyArray<T> = [T, ...T[]];
type SupportedWallets = NonEmptyArray<SupportedWallet>;
type WalletMetadata = {
    name: string;
    icon: string;
};
interface BaseWalletConstructor {
    id: WalletId;
    metadata: Partial<WalletMetadata> | undefined;
    getAlgodClient: () => algosdk.Algodv2;
    store: Store<State>;
    subscribe: (callback: (state: State) => void) => () => void;
}
type WalletConstructor<T extends keyof WalletOptionsMap> = BaseWalletConstructor & {
    options?: WalletOptions<T>;
    defaultMetadata?: WalletMetadata;
};
type WalletAccount = {
    name: string;
    address: string;
};
/** @see https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0001.md#interface-multisigmetadata */
interface MultisigMetadata {
    /**
     * Multisig version.
     */
    version: number;
    /**
     * Multisig threshold value. Authorization requires a subset of signatures,
     * equal to or greater than the threshold value.
     */
    threshold: number;
    /**
     * List of Algorand addresses of possible signers for this
     * multisig. Order is important.
     */
    addrs: string[];
}
/** @see https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0001.md#interface-wallettransaction */
interface WalletTransaction {
    /**
     * Base64 encoding of the canonical msgpack encoding of a Transaction.
     */
    txn: string;
    /**
     * Optional authorized address used to sign the transaction when the account
     * is rekeyed. Also called the signor/sgnr.
     */
    authAddr?: string;
    /**
     * Multisig metadata used to sign the transaction
     */
    msig?: MultisigMetadata;
    /**
     * Optional list of addresses that must sign the transactions
     */
    signers?: string[];
    /**
     * Optional base64 encoding of the canonical msgpack encoding of a
     * SignedTxn corresponding to txn, when signers=[]
     */
    stxn?: string;
    /**
     * Optional message explaining the reason of the transaction
     */
    message?: string;
    /**
     * Optional message explaining the reason of this group of transaction
     * Field only allowed in the first transaction of a group
     */
    groupMessage?: string;
}
/** @see https://github.com/perawallet/connect/blob/1.3.4/src/util/model/peraWalletModels.ts */
interface SignerTransaction {
    txn: algosdk.Transaction;
    /**
     * Optional authorized address used to sign the transaction when
     * the account is rekeyed. Also called the signor/sgnr.
     */
    authAddr?: string;
    /**
     * Optional list of addresses that must sign the transactions.
     * Wallet skips to sign this txn if signers is empty array.
     * If undefined, wallet tries to sign it.
     */
    signers?: string[];
    /**
     * Optional message explaining the reason of the transaction
     */
    message?: string;
}
interface JsonRpcRequest<T = any> {
    id: number;
    jsonrpc: string;
    method: string;
    params: T;
}
declare class SignTxnsError extends Error {
    code: number;
    data?: any;
    constructor(message: string, code: number, data?: any);
}
interface Siwa {
    domain: string;
    account_address: string;
    uri: string;
    version: string;
    statement?: string;
    nonce?: string;
    'issued-at'?: string;
    'expiration-time'?: string;
    'not-before'?: string;
    'request-id'?: string;
    chain_id: '283';
    resources?: string[];
    type: 'ed25519';
}
declare class SignDataError extends Error {
    code: number;
    data?: any;
    constructor(message: string, code: number, data?: any);
}
interface SignData {
    data: string;
    signer: Uint8Array;
    domain: string;
    authenticatorData: Uint8Array;
    requestId?: string;
    hdPath?: string;
    signature?: Uint8Array;
}
interface SignDataResponse extends SignData {
    signature: Uint8Array;
}
declare enum ScopeType {
    UNKNOWN = -1,
    AUTH = 1
}
interface SignMetadata {
    scope: ScopeType;
    encoding: string;
}

type WalletState = {
    accounts: WalletAccount[];
    activeAccount: WalletAccount | null;
};
type WalletStateMap = Partial<Record<WalletId, WalletState>>;
type ManagerStatus = 'initializing' | 'ready';
interface State {
    wallets: WalletStateMap;
    activeWallet: WalletId | null;
    activeNetwork: string;
    algodClient: algosdk.Algodv2;
    managerStatus: ManagerStatus;
    networkConfig: Record<string, NetworkConfig>;
    customNetworkConfigs: Record<string, Partial<NetworkConfig>>;
}
declare const DEFAULT_STATE: State;

interface WalletManagerOptions {
    resetNetwork?: boolean;
    debug?: boolean;
    logLevel?: LogLevel;
}
interface WalletManagerConfig {
    wallets?: SupportedWallet[];
    networks?: Record<string, NetworkConfig>;
    defaultNetwork?: string;
    options?: WalletManagerOptions;
}
declare class WalletManager {
    _clients: Map<WalletId, BaseWallet>;
    private baseNetworkConfig;
    store: Store<State>;
    subscribe: (callback: (state: State) => void) => () => void;
    options: {
        resetNetwork: boolean;
    };
    private logger;
    constructor({ wallets, networks, defaultNetwork, options }?: WalletManagerConfig);
    private initializeLogger;
    private determineLogLevel;
    get algodClient(): algosdk.Algodv2;
    set algodClient(algodClient: algosdk.Algodv2);
    private loadPersistedState;
    private savePersistedState;
    get status(): ManagerStatus;
    get isReady(): boolean;
    private initializeWallets;
    get wallets(): BaseWallet[];
    getWallet(walletId: WalletId): BaseWallet | undefined;
    resumeSessions(): Promise<void>;
    disconnect(): Promise<void>;
    private initNetworkConfig;
    private createAlgodClient;
    getAlgodClient: () => algosdk.Algodv2;
    setActiveNetwork: (networkId: NetworkId | string) => Promise<void>;
    updateAlgodConfig(networkId: string, algodConfig: Partial<AlgodConfig>): void;
    resetNetworkConfig(networkId: string): void;
    get activeNetwork(): string;
    get networkConfig(): Record<string, NetworkConfig>;
    get activeNetworkConfig(): NetworkConfig;
    get activeWallet(): BaseWallet | null;
    get activeWalletAccounts(): WalletAccount[] | null;
    get activeWalletAddresses(): string[] | null;
    get activeAccount(): WalletAccount | null;
    get activeAddress(): string | null;
    get signTransactions(): BaseWallet['signTransactions'];
    get transactionSigner(): algosdk.TransactionSigner;
}

declare class StorageAdapter {
    static getItem(key: string): string | null;
    static setItem(key: string, value: string): void;
    static removeItem(key: string): void;
}

/**
 * Fallback configuration for Webpack to handle optional wallet dependencies.
 * This allows applications to build without these packages installed,
 * enabling users to include only the wallet packages they need.
 * Each package is set to 'false', which means Webpack will provide an empty module
 * if the package is not found, preventing build errors for unused wallets.
 */
declare const webpackFallback: {
    '@agoralabs-sh/avm-web-provider': boolean;
    '@blockshake/defly-connect': boolean;
    '@magic-ext/algorand': boolean;
    '@perawallet/connect': boolean;
    '@walletconnect/modal': boolean;
    '@walletconnect/sign-client': boolean;
    'lute-connect': boolean;
    'magic-sdk': boolean;
};

export { type AlgodConfig, BaseWallet, type BaseWalletConstructor, BiatecWallet, type CustomProvider, CustomWallet, type CustomWalletOptions, DEFAULT_NETWORK_CONFIG, DEFAULT_STATE, DEFLY_WEB_PROVIDER_ID, DeflyWallet, type DeflyWalletConnectOptions, DeflyWebWallet, type EnableResult, type Exodus, type ExodusOptions, ExodusWallet, ICON, type JsonRpcRequest, KIBISIS_AVM_WEB_PROVIDER_ID, KibisisWallet, type KmdOptions, KmdWallet, LOCAL_STORAGE_MNEMONIC_KEY, LogLevel, type LuteConnectOptions, LuteWallet, MagicAuth, type MagicAuthClient, type MagicAuthOptions, type ManagerStatus, type MnemonicOptions, MnemonicWallet, type MultisigMetadata, type NetworkConfig, NetworkConfigBuilder, NetworkId, PeraWallet, type PeraWalletConnectOptions, ScopeType, SessionError, type SignData, SignDataError, type SignDataResponse, type SignMetadata, SignTxnsError, type SignTxnsResponse, type SignTxnsResult, type SignerTransaction, type Siwa, type State, StorageAdapter, type SupportedWallet, type SupportedWallets, W3Wallet, type W3WalletProvider, type WalletAccount, type WalletConfig, type WalletConfigMap, WalletConnect, type WalletConnectOptions, type WalletConstructor, WalletId, type WalletIdConfig, WalletManager, type WalletManagerConfig, type WalletManagerOptions, type WalletMap, type WalletMetadata, type WalletOptions, type WalletOptionsMap, type WalletState, type WalletTransaction, type WindowExtended, webpackFallback };
